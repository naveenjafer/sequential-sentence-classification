<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A39_C09_Large_Steps_in_Cloth_Simulation_ASPECT_v1.xml">


  
    017b6d2b25319c95a2cd999a36ac1d494fe88ccc7fad3ade48ad7264a95db1a8
    3wzw
    http://dx.doi.org/10.1145/280814.280821
  
  
    
      SIGGRAPH 98, Orlando, July 19–24
      C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
        <Title>Large Steps in Cloth Simulation</Title>
      
      
        
          David Baraff Andrew Witkin Robotics Institute Carnegie Mellon University
        
      
      <Abstract>
<Sentence aspectClass="NONE" inAbstract="true">The bottle-neck in most cloth simulation systems is that time steps must be small to avoid numerical instability.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">This paper describes a cloth simulation system that can stably take large time steps.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The simulation system couples a new technique for enforcing constraints on individual cloth particles with an implicit integration method.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The simulator models cloth as a triangular mesh, with internal cloth forces derived using a simple continuum formulation that supports modeling operations such as local anisotropic stretch or compression; a unified treatment of damping forces is included as well.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The implicit integration method generates a large, unbanded sparse linear system at each time step which is solved using a modified conjugate gradient method that simultaneously enforces particles’ constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The constraints are always maintained exactly, independent of the number of conjugate gradient iterations, which is typically small.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The resulting simulation system is significantly faster than previous accounts of cloth simulation systems in the literature.</Sentence>
</Abstract>
	   Keywords: Cloth, simulation, constraints, implicit integration, physically-based modeling.
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence aspectClass="NONE" inAbstract="false">Physically-based cloth animation has been a problem of interest to the graphics community for more than a decade.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Early work by Terzopoulos et al. <CitSpan>[ 17 ]</CitSpan> and Terzopoulos and Fleischer <CitSpan>[ 15 , 16 ]</CitSpan> on deformable models correctly characterized cloth simulation as a problem in deformable surfaces, and applied techniques from the mechanical engineering and finite element communities to the problem.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since then, other research groups (notably Carignan et al. <CitSpan>[ 4 ]</CitSpan> and Volino et al. <CitSpan>[ 20 , 21 ]</CitSpan>; Breen et al. <CitSpan>[ 3 ]</CitSpan>; and Eberhardt et al. <CitSpan>[ 5 ]</CitSpan>) have taken up the challenge of cloth.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Although specific details vary (underlying representations, numerical solution methods, collision detection and constraint methods, etc.), there is a deep commonality amongst all the approaches: physically-based cloth simulation is formulated as a time-varying partial differential equation which, after discretization, is numerically solved as an ordinary differential equation</Sentence>
      
        1
        ẍ = M −1 − ∂E + F . ∂x
      
      <Sentence aspectClass="NONE" inAbstract="false">In this equation the vector x and diagonal matrix M represent the geometric state and mass distribution of the cloth, E—a scalar funcAuthor affiliation <CitSpan>(September 1998)</CitSpan>: David Baraff, Andrew Witkin, Pixar Animation Studios, 1001 West Cutting Blvd.</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">, Richmond, CA 94804.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Email: deb@pixar.com , aw@pixar.com .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is an electronic reprint.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Permission is granted to copy part or all of this paper for noncommercial use provided that the title and this copyright notice appear.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This electronic reprint is ©1998 by CMU.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The original printed paper is ©1998 by the ACM.</Sentence>
      <Sentence aspectClass="NONE" inAbstract="false">tion of x—yields the cloth’s internal energy, and F (a function of x and x) describes other forces (air-drag, contact and constraint forces, internal damping, etc.) acting on the cloth.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In this paper, we describe a cloth simulation system that is much faster than previously reported simulation systems.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our system’s faster performance begins with the choice of an implicit numerical integration method to solve equation <CitSpan>(1)</CitSpan>.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">The reader should note that the use of implicit integration methods in cloth simulation is far from novel: initial work by Terzopoulos et al. <CitSpan>[ 15 , 16 , 17 ]</CitSpan> applied such methods to the problem.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">1 Since this time though, research on cloth simulation has generally relied on explicit numerical integration (such as Euler’s method or Runge-Kutta methods) to advance the simulation, or, in the case of of energy minimization, analogous methods such as steepest-descent <CitSpan>[ 3 , 10 ]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is unfortunate.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Cloth strongly resists stretching motions while being comparatively permissive in allowing bending or shearing motions.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This results in a “stiff” underlying differential equation of motion <CitSpan>[ 12 ]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Explicit methods are ill-suited to solving stiff equations because they require many small steps to stably advance the simulation forward in time.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">2 In practice, the computational cost of an explicit method greatly limits the realizable resolution of the cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For some applications, the required spatial resolution—that is, the dimension n of the state vector x—can be quite low: a resolution of only a few hundred particles (or nodal points, depending on your formulation/terminology) can be sufficient when it comes to modeling flags or tablecloths.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To animate clothing, which is our main concern, requires much higher spatial resolution to adequately represent realistic (or even semi-realistic) wrinkling and folding configurations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this paper, we demonstrate that implicit methods for cloth overcome the performance limits inherent in explicit simulation methods.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We describe a simulation system that uses a triangular mesh for cloth surfaces, eliminating topological restrictions of rectangular meshes, and a simple but versatile formulation of the internal cloth energy forces.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Unlike previous metric-tensor-based formulations <CitSpan>[ 15 , 16 , 17 , 4 ]</CitSpan> which model some deformation energies as quartic functions of positions, we model deformation energies only as quadratic functions with suitably large scaling.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Quadratic energy models mesh well with implicit integration’s numerical properties.) We also introduce a simple, unified treatment of damping forces, a subject which has been largely ignored thus far.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A key step in our simulation process is the solution of an O(n) × O(n) sparse linear system, which arises from the implicit integration method.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this respect, our implementation differs greatly from the implementation by Terzopoulos et al. <CitSpan>[ 15 , 17 ]</CitSpan>, which for large simulations
      1 Additional use of implicit methods in animation and dynamics work includes Kass and Miller <CitSpan>[ 8 ]</CitSpan>, Terzopoulos and Qin <CitSpan>[ 18 ]</CitSpan>, and Tu <CitSpan>[ 19 ]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">2 Even worse, the number of time steps per frame tends to increase along with the problem size, for an explicit method.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Cloth simulations of size n— meaning x ∈ IR O(n) —generally require O(n) explicit steps per unit simulated time.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Because the cost of an explicit step is also O(n) (setting aside complications such as collision detection for now) explicit methods for cloth require time O(n 2 )—or worse.</Sentence>
      43
      SIGGRAPH 98, Orlando, July 19–24
      C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      used an “alternating-direction” implicit (ADI) method <CitSpan>[ 12 ]</CitSpan>. <Sentence aspectClass="NONE" inAbstract="false">An ADI method generates a series of tightly banded (and thus quickly solved) linear systems rather than one large sparse system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(The price, however, is that some of the forces in the system—notably between diagonally-adjacent and non-adjacent nodes involved in self-collisions—are treated explicitly, not implicitly.) The speed (and ease) with which our sparse linear systems can be robustly solved—even for systems involving 25,000 variables or more—has convinced us that there is no benefit to be gained from using an ADI method instead (even if ADI methods could be applied to irregular triangular meshes).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus, regardless of simulation size, we treat all forces as part of the implicit formulation.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Even for extremely stiff systems, numerical stability has not been an issue for our simulator.</Sentence>
      
        <H2>1.1 Specific Contributions</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Much of the performance of our system stems from the development of an implicit integration formulation that handles contact and geometric constraints in a direct fashion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Specifically, our simulator enforces constraints without introducing additional penalty terms in the energy function E or adding Lagrange-multiplier forces into the force F. (This sort of direct constraint treatment is trivial if equation <CitSpan>(1)</CitSpan> is integrated using explicit techniques, but is problematic for implicit methods.) Our formulation for directly imposing and maintaining constraints is harmonious with the use of an extremely fast iterative solution algorithm—a modified version of the conjugate gradient (CG) method—to solve the O(n) × O(n) linear system generated by the implicit integrator.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Iterative methods do not in general solve linear systems exactly—they are run until the solution error drops below some tolerance threshold.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A property of our approach, however, is that the constraints are maintained exactly, regardless of the number of iterations taken by the linear solver.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Additionally, we introduce a simple method, tailored to cloth simulation, for dynamically adapting the size of time steps over the course of a simulation.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The combination of implicit integration and direct constraint satisfaction is very powerful, because this approach almost always allows us to take large steps forward.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In general, most of our simulations require on average from two to three time steps per frame of 30 Hz animation, even for (relatively) fast moving cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The large step sizes complement the fact that the CG solver requires relatively few iterations to converge.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, in simulating a 6, 000 node system, the solver takes only 50–100 iterations to solve the 18, 000 × 18, 000 linear system formed at each step.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Additionally, the running time of our simulator is remarkably insensitive to the cloth’s material properties (quite the opposite behavior of explicit methods).</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">All of the above advantages translate directly into a fast running time.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, we demonstrate results similar to those in Breen et al. <CitSpan>[ 3 ]</CitSpan> and Eberhardt et al. <CitSpan>[ 5 ]</CitSpan> (draping of a 2,600 node cloth) with a running time just over 2 seconds per frame on an SGI Octane R10000 195 Mhz processor.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, we show garments (shirts, pants, skirts) exhibiting complex wrinkling and folding behavior on both key-framed and motion-captured characters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Representative running times include a long skirt with 4,530 nodes (8,844 triangles) on a dancing character at a cost of 10 seconds per frame, and a shirt with 6,450 nodes (12,654 triangles) with a cost varying between 8 to 14 seconds per frame, depending on the underlying character’s motion.</Sentence>
      
      
        <H2>1.2 Previous Work</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Terzopoulos et al. <CitSpan>[ 15 , 17 ]</CitSpan> discretized cloth as a rectangular mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Energy functions were derived using a continuum formulation.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This work recognized the need for damping forces; however, only a simple viscous drag force −k x was used.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The linear systems result- ing from the use of implicit integration techniques were solved, for small systems, by direct methods such as Choleski factorization, or using iterative techniques such as Gauss-Seidel relaxation or conjugate gradients.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(For a square √ system of n nodes, the resulting linear system has bandwidth n.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this case, banded Choleski factorization <CitSpan>[ 6 ]</CitSpan> requires time O(n 2 ).) As previously discussed, Terzopoulos et al. made use of an ADI method for larger cloth simulations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Following Terzopoulos et al.’s treatment of deformable surfaces, work by Carignan et al. <CitSpan>[ 4 ]</CitSpan> described a cloth simulation system using rectangular discretization and the same formulation as Terzopoulos et al. Explicit integration was used.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Carignan et al. recognized the need for damping functions which do not penalize rigidbody motions of the cloth (as simple viscous damping does) and they added a force which damps cloth stretch and shear (but not bend).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Later work by the same group includes Volino et al. <CitSpan>[ 20 ]</CitSpan>, which focuses mainly on collision detection/response and uses a triangular mesh; no mention is made of damping forces.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The system uses the midpoint method (an explicit method) to advance the simulation.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Thus far, the accumulated work by this group (see Volino et al. <CitSpan>[ 21 ]</CitSpan> for an overview) gives the only published results we know of for simulated garments on moving characters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Reported resolutions of the garments are approximately two thousand triangles per garment (roughly 1,000 nodal points) <CitSpan>[ 21 ]</CitSpan> with running times of several minutes per frame for each garment on an SGI R4400 150 Mhz processor.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Breen et al. <CitSpan>[ 3 ]</CitSpan> depart completely from continuum formulations of the energy function, and describe what they call a “particlebased” approach to the problem.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">By making use of real-world cloth material properties (the Kawabata measuring system) they produced highly realistic static images of draped rectangular cloth meshes with reported resolutions of up to 51 × 51 nodes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The focus of this work is on static poses for cloth, as opposed to animation: thus, their simulation process is best described as energy minimization, although methods analogous to explicit methods are used.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Speed was of secondary concern in this work.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Refinements by Eberhardt et al. <CitSpan>[ 5 ]</CitSpan>—notably, the use of higher-order explicit integration methods and Maple-optimized code, as well as a dynamic, not static treatment of the problem—obtain similarly realistic results, while dropping the computational cost to approximately 20–30 minutes per frame on an SGI R8000 processor.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">No mention is made of damping terms.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Provot <CitSpan>[ 13 ]</CitSpan> focuses on improving the performance of explicit methods by a post-step modification of nodal positions.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">He iteratively adjusts nodal positions to eliminate unwanted stretch; the convergence properties of this method are unclear.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A more comprehensive discussion on cloth research can be found in the survey paper by Ng and Grimsdale <CitSpan>[ 9 ]</CitSpan>.</Sentence>
      
      
        <H1>2 Simulation Overview</H1>
        <Sentence aspectClass="NONE" inAbstract="false">In this section, we give a brief overview of our simulator’s architecture and introduce some notation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The next section derives the linear system used to step the simulator forward implicitly while section 4 describes the specifics of the internal forces and their derivatives that form the linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Section 5 describes how constraints are maintained (once established), with a discussion in section 6 on collision detection and constraint initialization.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Section 7 describes our adaptive step-size control, and we conclude in section 8 with some simulation results.</Sentence>
      
      
        <H2>2.1 Notation and Geometry</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Our simulator models cloth as a triangular mesh of particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given a mesh of n particles, the position in world-space of the ith particle is x i ∈ IR 3 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The geometric state of all the particles is simply x ∈ IR 3n .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The same component notation applies to forces: a force f ∈ IR 3n acting on the cloth exerts a force f i on the ith particle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Real-world cloth is cut from flat sheets of material and tends to resist deformations away from this initial flat state (creases and pleats not withstanding).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We capture the rest state of cloth by assigning each particle an unchanging coordinate (u i , v i ) in the plane.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">3 Section 4 makes use of these planar coordinates.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Collisions between cloth and solid objects are handled by preventing cloth particles from interpenetrating solid objects.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our current implementation models solid objects as triangularly faced polyhedra.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Each face has an associated thickness and an orientation; particles found to be sufficiently near a face, and on the wrong side, are deemed to have collided with that face, and become subject to a contact constraint.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(If relative velocities are extremely high, this simple test may miss some collisions.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In this case, analytically checking for intersection between previous and current positions can guarantee that no collisions are missed.) For cloth/cloth collisions, we detect both face-vertex collisions between cloth particles and triangles, as well as edge/edge collisions between portions of the cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As in the case of solids, close proximity or actual intersection of cloth with itself initiates contact handling.</Sentence>
        44
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
      
        <H2>2.2 Energy and Forces</H2>
        <Sentence aspectClass="NONE" inAbstract="false">The most critical forces in the system are the internal cloth forces which impart much of the cloth’s characteristic behavior.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Breen et al. <CitSpan>[ 3 ]</CitSpan> describes the use of the Kawabata system of measurement for realistic determination of the in-plane shearing and out-of-plane bending forces in cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We call these two forces the shear and bend forces.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We formulate the shear force on a per triangle basis, while the bend force is formulated on a per edge basis—between pairs of adjacent triangles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The strongest internal force—which we call the stretch force— resists in-plane stretching or compression, and is also formulated per triangle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Under normal conditions, cloth does not stretch appreciably under its own weight.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This requires the stretch force to have a high coefficient of stiffness, and in fact, it is the stretch force that is most responsible for the stiffness of equation <CitSpan>(1)</CitSpan>.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">A common practice in explicitly integrated cloth systems is to improve running time by decreasing the strength of the stretch force; however, this leads to “rubbery” or “bouncy” cloth.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our system uses a very stiff stretch force to combat this problem, without any detrimental effects on the run-time performance.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While the shear and bend force stiffness coefficients depend on the material being simulated, the stretch coefficient is essentially the same (large) value for all simulations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Of course, if stretchy cloth is specifically called for, the stretch coefficient can be made smaller.) Complementing the above three internal forces are three damping forces.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In section 5, we formulate damping forces that subdue any oscillations having to do with, respectively, stretching, shearing, and bending motions of the cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The damping forces do not dissipate energy due to other modes of motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Additional forces include air-drag, gravity, and user-generated generated mouse-forces (for interactive simulations).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Cloth/cloth contacts generate strong repulsive linear-spring forces between cloth particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Combining all forces into a net force vector f, the acceleration ẍ i of the ith particle is simply ẍ i = f i /m i , where m i is the ith particle’s mass.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The mass m i is determined by summing one third the mass
        3 In general, each particle has a unique (u, v) coordinate; however, to accommodate pieces of cloth that have been topologically seamed together (such as a sleeve), particles lying on the seam must have multiple (u, v) coordinates.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For these particles, we let the (u, v) coordinate depend on which triangle we are currently examining.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The (u, v) coordinates are useful for texturing.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">of all triangles containing the ith particle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(A triangle’s mass is the product of the cloth’s density and the triangle’s fixed area in the uv coordinate system.) Defining the diagonal mass matrix M ∈ IR 3n×3n by diag(M) = (m 1 , m 1 , m 1 , m 2 , m 2 , m 2 , . . . , m n , m n , m n ), we can write simply that</Sentence>
        
          2
          ẍ = M −1 f(x, x).
        
      
      
        <H2>2.3 Sparse Matrices</H2>
        <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The use of an implicit integration method, described in the next section, generates large unbanded sparse linear systems.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We solve these systems through a modified conjugate gradient (CG) iterative method, described in section 5.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">CG methods exploit sparsity quite easily, since they are based solely on matrix-vector multiplies, and require only rudimentary sparse storage techniques.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The sparsity of the matrix generated by the implicit integrator is best represented in block-fashion: for a system with n particles, we deal with an n × n matrix, whose non-zero entries are represented as dense 3 × 3 matrices of scalars.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The matrix is represented as an array of n rows; each row is a linked list of the non-zero elements of that row, to accommodate possible run-time changes in the sparsity pattern, due to cloth/cloth contact.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The (dense) vectors that are multiplied against this matrix are stored simply as n element arrays of threecomponent vectors.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The overall implementation of sparsity is completely straightforward.</Sentence>
      
      
        <H2>2.4 Constraints</H2>
        <Sentence aspectClass="NONE" inAbstract="false">An individual particle’s position and velocity can be completely controlled in either one, two, or three dimensions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Particles can thus be attached to a fixed or moving point in space, or constrained to a fixed or moving surface or curve.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Constraints are either user-defined (the time period that a constraint is active is user-controlled) or automatically generated, in the case of contact constraints between cloth and solids.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">During cloth/solid contacts, the particle may be attached to the surface, depending on the magnitudes of the frictional forces required; otherwise, the particle is constrained to remain on the surface, with sliding allowed.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The mechanism for releasing a contact constraint, or switching between sliding or not sliding, is described in section 5.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The constraint techniques we use on individual particles work just as well for collections of particles; thus, we could handle cloth/cloth intersections using the technique described in section 5, but the cost is potentially large.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For that reason, we have chosen to deal with cloth/cloth contacts using penalty forces: whenever a particle is near a cloth triangle or is detected to have passed through a cloth triangle, we add a stiff spring with damping to pull the particle back to the correct side of the triangle.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The implicit solver easily tolerates these stiff forces.</Sentence>
      
      
        <H1>3 Implicit Integration</H1>
        <Sentence aspectClass="NONE" inAbstract="false">Given the known position x(t 0 ) and velocity x(t 0 ) of the system at time t 0 , our goal is to determine a new position x(t 0 + h) and velocity x(t 0 + h) at time t 0 + h.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To compute the new state and velocity using an implicit technique, we must first transform equation <CitSpan>(2)</CitSpan> into a first-order differential equation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is accomplished simply by defining the system’s velocity v as v = x and then writing</Sentence>
        
          3
          dt d x x = dt d v x = M −1 f(x, v v) .
        
        <Sentence aspectClass="NONE" inAbstract="false">To simplify notation, we will define x 0 = x(t 0 ) and v 0 = v(t 0 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also define x = x(t 0 + h) − x(t 0 ) and v = v(t 0 + h) − v(t 0 ).</Sentence>
        45
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        The explicit forward Euler method applied to equation <CitSpan>(3)</CitSpan> approximates x and v as x v = h M v −1 0 f 0
        where the force f 0 is defined by f 0 = f(x 0 , v 0 ). <Sentence aspectClass="NONE" inAbstract="false">As previously discussed, the step size h must be quite small to ensure stability when using this method.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The implicit backward Euler method appears similar at first: x and v are approximated by</Sentence>
        
          4
          v x = h M −1 f(x 0 v + 0 + x, v v 0 + v) .
        
        <Sentence aspectClass="NONE" inAbstract="false">The difference in the two methods is that the forward method’s step is based solely on conditions at time t 0 while the backward method’s step is written in terms of conditions at the terminus of the step itself.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">4 The forward method requires only an evaluation of the function f but the backward method requires that we solve for values of x and v that satisfy equation <CitSpan>(4)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Equation <CitSpan>(4)</CitSpan> is a nonlinear equation: rather than solve this equation exactly (which would require iteration) we apply a Taylor series expansion to f and make the firstorder approximation ∂f ∂f f(x 0 + x, v 0 + v) = f 0 + ∂x x + ∂v v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this equation, the derivative ∂f/∂x is evaluated for the state (x 0 , v 0 ) and similarly for ∂f/∂v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Substituting this approximation into equation <CitSpan>(4)</CitSpan> yields the linear system</Sentence>
        
          5
          v x = h M −1 (f 0 + v 0 ∂x ∂f + x v + ∂v ∂f v) .
        
        <Sentence aspectClass="NONE" inAbstract="false">Taking the bottom row of equation <CitSpan>(5)</CitSpan> and substituting x = h(v 0 + v) yields v = hM −1 f 0 + ∂x ∂f h(v 0 + v) + ∂v ∂f v .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Letting I denote the identity matrix, and regrouping, we obtain</Sentence>
        
          6
          I − hM −1 ∂v ∂f − h 2 M −1 ∂x ∂f v = hM −1 f 0 + h ∂x ∂f v 0
        
        <Sentence aspectClass="NONE" inAbstract="false">which we then solve for v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given v, we trivially compute x = h(v 0 + v).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus, the backward Euler step consists of evaluating f 0 , ∂f/∂x and ∂f/∂v; forming the system in equation <CitSpan>(6)</CitSpan>; solving the system for v; and then updating x and v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We use the sparse data structures described in section 2.3 to store the linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The sparsity pattern of equation <CitSpan>(6)</CitSpan> is described in the next section, while solution techniques are deferred to section 5.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">4 The method is called “backward” Euler because starting from the output state (x 0 + x, v 0 + v) and using a forward Euler step to run the system backward in time (i.e. taking the step −h(v(t 0 + h), f(x(t 0 + h), v(t 0 + h))) brings you back to (x 0 , v 0 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">What is the value in this?</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Forward Euler takes no notice of wildly changing derivatives, and proceeds forward quite blindly.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Backward Euler, however, forces one to find an output state whose derivative at least points back to where you came from, imparting, essentially, an additional layer of consistency (or sanity-checking, if you will).</Sentence>
      
      
        <H1>4 Forces</H1>
        <Sentence aspectClass="NONE" inAbstract="false">Cloth’s material behavior is customarily described in terms of a scalar potential energy function E(x); the force f arising from this energy is f = −∂E/∂x.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Equation <CitSpan>(6)</CitSpan> requires both the vector f and the matrix ∂f/∂x.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Expressing the energy E as a single monolithic function—encompassing all aspects of the cloth’s internal behavior—and then taking derivatives is impractical, from a bookkeeping point of view.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">A better approach is decompose E into a sum of sparse energy functions; that is, to write E(x) = α E α (x) where each E α depends on as few elements of x—as few particles—as possible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, even decomposing E into sparse energy functions is not enough.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Energy functions are an undesirable starting point because sensible damping functions cannot be derived from energy functions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Instead, we define internal behavior by formulating a vector condition C(x) which we want to be zero, and then defining the associated energy as k C(x) T C(x) where k is a stiffness constant.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">2 In section 4.5, we show how sensible damping functions can be constructed based on this formulation.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">An added bonus is that starting from this vector-based energy description tends to result in a simpler, more compact, and more easily coded formulation for ∂f/∂x than proceeding from an energy function in which the structure of C has been lost.</Sentence>
      
      
        <H2>4.1 Forces and Force Derivatives</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Given a condition C(x) which we want to be zero, we associate an energy function E C with C by writing E C (x) = k 2 C(x) T C(x) where k is a stiffness constant of our choice.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Assuming that C depends on only a few particle, C gives rise to a sparse force vector f.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Recall from section 2.1 that we view the vector f in block form; each element f i is a vector in IR 3 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For each particle i that C depends on,</Sentence>
        
          7
          f i = − ∂E ∂x C i = −k ∂C(x) ∂x i C(x);
        
        <Sentence aspectClass="NONE" inAbstract="false">all the other elements of f are zero.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, the derivative of f is also sparse.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Defining the derivative matrix K = ∂f/∂x, the nonzero entries of K are K ij for all pairs of particles i and j that C depends on.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Again, we treat K in block fashion: K ∈ IR 3n×3n , so an element K ij is a 3 × 3 matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">From equation <CitSpan>(7)</CitSpan>, we have</Sentence>
        
          8
          K ij = ∂x ∂f i j = −k ∂C(x) ∂x i ∂C(x) ∂x j T + ∂ ∂x 2 C(x) i ∂x j C(x) .
        
        <Sentence aspectClass="NONE" inAbstract="false">Additionally, since K ij is a second derivative—that is, K ij = ∂f i /∂x j = ∂ 2 E/∂x i ∂x j —we have K ij = K T ji so K is symmetric.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that since C does not depend on v, the matrix ∂f/∂v is zero.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We can now easily describe the internal forces acting on the cloth, by just writing condition functions.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Forces and their derivatives are easily derived using equations <CitSpan>(7) and (8)</CitSpan>.</Sentence>
      
      
        <H2>4.2 Stretch Forces</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Recall that every cloth particle has a changing position x i in world space, and a fixed plane coordinate (u i , v i ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Even though our cloth is modeled as a discrete set of points, grouped into triangles, it will be convenient to pretend momentarily that we have a single continuous function w(u, v) that maps from plane coordinates to world space.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Stretch can be measured at any point in the cloth surface by examining the derivatives w u = ∂w/∂u and w v = ∂w/∂v at that point.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The magnitude of w u describes the stretch or compression in the u direction; the material is unstretched wherever w u = 1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Stretch in the v direction is measured by w v .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Some previous continuum formulations have modeled stretch energy along an axis as essentially (w u T w u − 1) 2 , which is a quartic function of position <CitSpan>[ 15 , 16 , 17 , 4 ]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">We find this to be needlessly stiff; worse, near the rest state, the force gradient—a quadratic function of position—is quite small, which partially negates the advantage implicit integration has in exploiting knowledge of the force gradient.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">A quadratic model for energy is, numerically, a better choice.) We apply this stretch/compression measure to a triangle as follows.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let us consider a triangle whose vertices are particles i, j and k.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Define x 1 = x j − x i and x 2 = x k − x i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, let u 1 = u j − u i , while u 2 = u k − u i and similarly for v 1 and v 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We approximate w(u, v) as a linear function over each triangle; this is equivalent to saying that w u and w v are constant over each triangle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This lets us write x 1 = w u u 1 + w v v 1 and x 2 = w u u 2 + w v v 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Solving for w u and w v yields</Sentence>
        46
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          9
          −1 (w u w v ) = ( x 1 x 2 ) v u 1 1 v u 2 2 .
        
        <Sentence aspectClass="NONE" inAbstract="false">Note that x 1 and x 2 vary during the simulation but the matrix in the above equation does not.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can treat w u and w v as functions of x, realizing that they depend only on x i , x j and x k and using equation <CitSpan>(9)</CitSpan> to obtain derivatives.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The condition we use for the stretch energy is</Sentence>
        
          10
          C(x) = a w w u v (x) (x) − − b b v u
        
        <Sentence aspectClass="NONE" inAbstract="false">where a is the triangle’s area in uv coordinates.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Usually, we set b u = b v = 1, though we need not always do so.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In particular, if we want to slightly lengthen a garment (for example, a sleeve) in the u direction, we can increase b u , which causes w u to seek a larger value, and tends to induce wrinkles across the u direction.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Likewise, we might decrease b v near the end of a sleeve, inducing a tight cuff, as on a sweatshirt.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We have found the ability to control shrink/stretch anisotropically to be an indispensable modeling tool.</Sentence>
      
      
        <H2>4.3 Shear and Bend Forces</H2>
        <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Cloth likewise resists shearing in the plane.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can measure the extent to which cloth has sheared in a triangle by considering the inner product w u T w v .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In its rest state, this product is zero.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since the stretch term prevents the magnitudes of w u and w v from changing overly much, we need not normalize.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">By the small angle approximation, the product w u T w v is a reasonable approximation to the shear angle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The condition for shearing is simply C(x) = aw u (x) T w v (x) with a the triangle’s area in the uv plane.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We measure bend between pairs of adjacent triangles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The condition we write for the bend energy depends upon the four particles defining the two adjoining triangles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we let n 1 and n 2 denote the unit normals of the two triangles and let e be a unit vector parallel to the common edge, the angle θ between the two faces is defined by the relations sin θ = (n 1 × n 2 ) · e and cos θ = n 1 · n 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We define a condition for bending by writing simply C(x) = θ which results in a force that counters bending.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">5 The assumption that the stretch energy will keep the cloth from stretching much allows us to treat n 1 , 5 For reasonably equilateral triangles, as edge lengths decrease, the curvature represented by a particular angle θ between triangles increases.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since the square of the curvature—a a good measure of the bend energy in cloth— increases at the same rate that the triangle’s area decreases, the condition C should not be scaled by the triangles’ areas.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">See Breen et al. <CitSpan>[ 3 ]</CitSpan> for a further discussion of relating curvature to bend angle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">n 2 and e as having a constant length at each step of the simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This makes differentiating θ with respect to x a manageable task.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Rectangular meshes make it simple to treat bending anisotropically.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The uv coordinates associated with particles make this possible for triangular meshes as well.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given material for which bending in the u and v directions are weighted by stiffnesses k u and k v , we can emulate this anisotropy as follows.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let the edge between the triangles be between particles i and j, and define u = u i − u j and v = v i − v j .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The stiffness weighting for this edge should simply be k u ( u) 2 + k v ( v) 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">( u) 2 + ( v) 2</Sentence>
      
      
        <H2>4.4 Additional Forces</H2>
        <Sentence aspectClass="ADVANTAGE" inAbstract="false">To the above forces we also add easily implemented forces such as gravity and air-drag (which is formulated on a per-triangle basis, and opposes velocities along the triangle’s normal direction).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When the simulation is fast enough to interact with, we add user-controlled “mouse” forces.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">These forces and their gradients are easily derived.</Sentence>
      
      
        <H2>4.5 Damping</H2>
        <Sentence aspectClass="NONE" inAbstract="false">The energies we have just described are functions of position only.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Robust dynamic cloth simulation, however, is critically dependent on well-chosen damping forces that are a function of both position and velocity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, the strong stretch force must be accompanied by a suitably strong damping force if we are to prevent anomalous in-plane oscillations from arising between connected particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, this strong damping force must confine itself solely to damping in-plane stretching/compressing motions: stretch damping should not arise due to motions that are not causing stretch or compression.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Terzopoulos et al.’s <CitSpan>[ 16 , 17 ]</CitSpan> treatment of cloth used a simple viscous damping function which dissipated kinetic energy, independent of the type of motion.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Carignan et al. <CitSpan>[ 4 ]</CitSpan> improved upon this somewhat, borrowing a formulation due to Platt and Barr <CitSpan>[ 11 ]</CitSpan>; however, their damping function—a linear function of velocity—does not match the quartic energy functions of their continuum formulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this section we describe a general treatment for damping that is independent of the specific energy function being damped.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It is tempting to formulate a damping function for an energy function E(x) by measuring the velocity of the energy, E  ̇ = d E(x).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">dt This is an easy trap to fall into, but it gives nonsensical results.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At an equilibrium point of E, the gradient ∂E/∂x vanishes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since E  ̇ = (∂E/∂x) T x, we find that E  ̇ is zero when E is at its minimum, regardless of the system’s velocity x = v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In general, E  ̇ is always too small near the system’s rest state.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Clearly, basing the damping force on E  ̇ is not what we want to do.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We believe that the damping function should be defined not in terms of the energy E, but in terms of the condition C(x) we have been using to define energies.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The force f arising from the energy acts only in the direction ∂C(x)/∂x, and so should the damping force.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Additionally, the damping force should depend on the component of the system’s velocity in the ∂C(x)/∂x direction; in other words, the damping strength should depend on (∂C(x)/∂x) T x = C(x).</Sentence>  <Sentence aspectClass="NONE" inAbstract="false">̇ Putting this together, we propose that the damping force d associated with a condition C have the form</Sentence>
        
          11
          d = −k d ∂C(x) ∂x C(x).  ̇
        
        <Sentence aspectClass="NONE" inAbstract="false">∂C(x) This neatly parallels the fact that f = −k s ∂x C(x).</Sentence>
        47
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        Given the condition functions C we have defined in this section for stretch, bend and shear forces, we can now add accompanying damping forces by applying equation <CitSpan>(11)</CitSpan>. <Sentence aspectClass="NONE" inAbstract="false">As before, d i is nonzero only for those particles that C depends on, and ∂d/∂x has the same sparsity pattern as ∂f/∂x.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Differentiating equation <CitSpan>(11)</CitSpan>, we obtain</Sentence>
        
          12
          ∂x ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂x  ̇ j T + ∂ ∂x C(x) i ∂x j C(x)  ̇ .
        
        <Sentence aspectClass="NONE" inAbstract="false">Note that ∂d/∂x is not a second derivative of some function as was the case in equation <CitSpan>(8)</CitSpan> so we cannot expect ∂d/∂x to be symmetrical.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In equation <CitSpan>(12)</CitSpan>, it is the term (∂C(x)/∂x i )(∂ C(x)/∂x  ̇ j ) T which breaks the symmetry.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Anticipating section 5.2, we find it expedient simply to leave this term out, thereby restoring symmetry.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This simplification is clearly not physically justifiable, but we have not observed any ill effects from this omission.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Omitting all of equation <CitSpan>(12)</CitSpan>, however, causes serious problems.) Finally, equation <CitSpan>(6)</CitSpan> requires the derivative ∂d/∂v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since C(x)  ̇ = (∂C(x)/∂x) T v, we have ∂ C(x)  ̇ ∂ ∂C(x) T ∂C(x) = v = .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">∂v ∂v ∂x ∂x Using this fact, we can write ∂v ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂v  ̇ j T = −k d ∂C(x) ∂x i ∂C(x) ∂x j T .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this case, the result is symmetrical without dropping any terms.</Sentence>
      
      
        <H1>5 Constraints</H1>
        <Sentence aspectClass="NONE" inAbstract="false">In this section, we describe how constraints are imposed on individual cloth particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The constraints we discuss in this section are either automatically determined by the user (such as geometric attachment constraints on a particle) or are contact constraints (generated by the system) between a solid object and a particle.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">The techniques we describe in this section could be used for multi-particle constraints; however, constraints that share particle would need to be merged.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Thus, a set of four-particle constraints (such as vertex/triangle or edge/edge contacts in the cloth) might merge to form a single constraint on arbitrarily many particles, which would be expensive to maintain.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Because of this, we handle cloth/cloth contacts with strong springs (easily dealt with, given the simulator’s underlying implicit integration base) and “position alteration,” a technique described in section 6.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At any given step of the simulation, a cloth particle is either completely unconstrained (though subject to forces), or the particle may be constrained in either one, two or three dimensions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given the differential nature of our formulation, it is the particle’s acceleration, or equivalently, the change in the particle’s velocity, that is constrained.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the particle is constrained in all three dimensions, then we are explicitly setting the particle’s velocity (at the next step).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the constraint is in two or one dimensions, we are constraining the particle’s velocity along either two or one mutually orthogonal axes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Before describing our constraint method, we discuss several other possible enforcement mechanisms and explain why we chose not to use them.</Sentence>
      
      
        <Sentence aspectClass="NONE" inAbstract="false">Reduced Coordinates
        An obvious and quite exact method for constraining a particle is to reduce the number of coordinates describing the particle’s position and velocity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A completely constrained particle would have no coordinates, while a particle with one dimension of constraint would have two coordinates.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This is possible—but it complicates the system immensely.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we change the number of coordinates per particle, we alter the size of the derivative matrices in equation <CitSpan>(6)</CitSpan>, as well as the sparsity pattern (this happens when a particle changes from having no coordinates to some coordinates, or vice versa).</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Given the transient nature of contact constraints between cloth and solids, this is most unappealing.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The computation of the derivative matrices’ entries is also greatly complicated, because we must now introduce extra Jacobian matrices that relate a particle’s reduced coordinates to its motion in world-space.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Finally, correct constraint-release behavior between cloth and solid objects is difficult to achieve using a reduced coordinate formulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Considering all of this, we immediately rejected this method of constraints.</Sentence>
      
      
        <Sentence aspectClass="NONE" inAbstract="false">Penalty Methods
        We could constrain particles through the use of strong energy functions—essentially, stiff springs that attempt to prevent illegal particle motions.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Since our entire formulation is geared to handle stiffness, the usual objections to enforcing constraints with springs—very stiff equations—do not carry as much weight.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">We tried this for a time, and found it to be a not unreasonable constraint enforcement mechanism.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, penalty methods do not enforce constraints exactly, and they do add some additional stiffness to the system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since the mechanism we describe enforces constraints exactly, and adds no extra stiffness, we turned away from penalty methods except in the case of cloth/cloth interactions.</Sentence>
      
      
        <Sentence aspectClass="NONE" inAbstract="false">Lagrange Multipliers
        We could introduce additional constraint forces—that is, Lagrange multipliers—into our system to satisfy the constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This involves augmenting the linear system of equation <CitSpan>(6)</CitSpan> with extra variables (the multipliers) and extra equations (the constraint conditions).</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Unfortunately, this turns a positive definite system into an indefinite system, which means that iterative methods such as CG will need to square the system first, thereby doubling the running time and degrading the numerical conditionining of the linear system.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Additionally, an iterative method will generally not enforce the constraints exactly without a large number of iterations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(A direct method for solving the augmented system would, however, avoid this problem.) Again, the constraint method we describe steps past these difficulties, so we turned away from using Lagrange multipliers.</Sentence>
      
      
        <H2>5.1 Mass Modification</H2>
        <Sentence aspectClass="NONE" inAbstract="false">The idea behind our constraint enforcement mechanism is described quite simply, although the actual implementation is somewhat more complicated, to maximize performance.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A dynamic simulation usually requires knowledge of the inverse mass of objects; for example, note the appearance of M −1 , and not M in equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the case of a single particle, we write x  ̈ i = m 1 i f i to describe a particle’s acceleration.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When inverse mass is used, it becomes trivial to enforce constraints by altering the mass.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Suppose for example that we want to keep particle i’s velocity from changing.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we take 1/m i to be zero, we give the particle an infinite mass, making it ignore all forces exerted on it.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Complete control over a particle’s acceleration is thus taken care of by storing a value of zero for the particle’s inverse mass.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">What if we wish to constrain the particle’s acceleration in only one or two dimensions?</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Although we normally think of a particle’s mass as a scalar, we need not always do so.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Suppose we write ẍ i = 1/m 0 i 1/m 0 i 0 0 f i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Now ẍ i 0 0 0 must lie in the xy plane; no acceleration in the z direction is possible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note than an unconstrained particle can be considered to have the 3 × 3 inverse mass matrix 1 I, with I the identity matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">m i Of course, we are not restricted to coordinate-aligned constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More generally, given a unit vector p ∈ IR 3 , a particle is prevented from accelerating along p by using an inverse mass matrix 1 (I − m i pp T ); this follows from the fact that (I − pp T )p = 0.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, given two mutually orthogonal unit vectors p and q, we prevent a particle from accelerating in either the p or q direction by using the inverse mass matrix 1 (I − pp T − qq T ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">m i By allowing constrained particles to have these sorts of inverse masses, we can build constraints directly into equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will create a modified version W of M −1 ; W will be a block-diagonal matrix, with off-diagonal blocks being zero, and diagonal blocks defined as follows: let ndof(i) indicate the number of degrees of freedom particle i has, and let particle i’s prohibited directions be p i (if ndof(i) = 2) or p i and q i (if ndof(i) = 1) with p i and q i mutually orthogonal unit vectors.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">W’s diagonal blocks are W ii = m 1 i S i where</Sentence>
        48
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          13
           S i =         I 0 (I (I − − p p i i p p i i T T ) − q i q i T ) if if if ndof(i) ndof(i) ndof(i) ndof(i) = = = = 1 2 3 0.
        
        <Sentence aspectClass="NONE" inAbstract="false">We are not limited to constraining particles to have zero accelerations in certain directions; rather, we control exactly what the change in velocity is along the constrained directions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For every particle i, let z i be the change in velocity we wish to enforce in the particle’s constrained direction(s).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(This implies we can choose any value of z i for a completely constrained particle, since all directions are constrained; an unconstrained particle must have z i = 0 since it has no constrained directions.) Using W and z, we rewrite equation <CitSpan>(6)</CitSpan> to directly enforce constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we solve</Sentence>
        
          14
          I − hW ∂v ∂f − h 2 W ∂x ∂f v = hW f 0 + h ∂x ∂f v 0 + z
        
        <Sentence aspectClass="NONE" inAbstract="false">for v, we will obtain a v which is consistent with our constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Completely constrained particles will have v i = z i , while partially constrained particles will have a v i whose component in the constrained direction(s) is equal to z i .</Sentence>
      
      
        <H2>5.2 Implementation</H2>
        <Sentence aspectClass="ADVANTAGE" inAbstract="false">We initially implemented constraints using equation <CitSpan>(14)</CitSpan> and found that it worked exactly as advertised.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">For very small test systems, we solved equation <CitSpan>(14)</CitSpan> using a direct method (Gaussian elimination) without any problems.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">For larger systems, we planned to use the iterative, sparsity-exploiting CG method, which immediately presents us with a problem: equation <CitSpan>(14)</CitSpan> is not a symmetric linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(For that matter, neither is equation <CitSpan>(6)</CitSpan> unless all particles have the same mass.) CG methods, however, require symmetric matrices.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">6 We could apply a CG method to the unsymmetric matrix of equation <CitSpan>(14)</CitSpan> by use of the “normal equations”; but this involves multiplying the matrix of equation <CitSpan>(14)</CitSpan> with its transpose which doubles the cost of each iteration while squaring the condition number of the system <CitSpan>[ 14 ]</CitSpan>—a less than desirable plan.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">We decided that using a CG method to solve the unsymmetric problem was not acceptable.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that without constraints, applying a CG method to equation <CitSpan>(6)</CitSpan> is not difficult, because we can transform this equation to 6 In fact, they work best on positive definite symmetric matrices.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The matrices we ultimately hand to our CG method are positive definite.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">a symmetric (and positive definite) system by left-multiplying the entire equation by M: the system</Sentence>
        
          15
          M − h ∂v ∂f − h 2 ∂x ∂f v = h f 0 + h ∂x ∂f v 0
        
        <Sentence aspectClass="NONE" inAbstract="false">is symmetric and has the same solution v as equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Unfortunately, we cannot apply the same transformation to equation <CitSpan>(14)</CitSpan>, because W is singular—the filtering blocks in equation <CitSpan>(13)</CitSpan> are rank deficient—so we cannot multiply through by W −1 .</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The solution to the problem of asymmetry is to modify the CG method so that it can operate on equation <CitSpan>(15)</CitSpan>, while procedurally applying the constraints inherent in the matrix W at each iteration.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The modified method will need to know about the particles’ constraints and the vector z.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let us define the symmetric positive definite matrix A by</Sentence>
        
          16
          A = M − h ∂f − h 2 ∂f ∂v ∂x
        
        <Sentence aspectClass="NONE" inAbstract="false">and the vector b and residual vector r as ∂f b = h f 0 + h ∂x v 0 and r = A v − b.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given A, b, constraints on the particles, and z, our modified CG method will try to find v that satisfies two conditions: • For each particle i, the component of r i in the particle’s unconstrained direction(s) will be made equal to zero (assuming the method is run for sufficiently many iterations).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">• For each particle i, the component of v i in the particle’s constrained direction(s) will be exactly z i (no matter how many iterations are taken).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that these two conditions imply that unconstrained particles have r i close to zero, while completely constrained particles have v i = z i .</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Thus in the case when no particles are constrained, our modified CG method should produce the same result as the regular CG method.</Sentence>
      
      
        <H2>5.3 The Modified Conjugate Gradient Method</H2>
        <Sentence aspectClass="NONE" inAbstract="false">The CG method (technically, the preconditioned CG method) takes a symmetric positive semi-definite matrix A, a symmetric positive definite preconditioning matrix P of the same dimension as A, a vector b and iteratively solves A v = b.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The iteration stops when b − A v is less than b where is a user-defined tolerance value.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The preconditioning matrix P, which must be easily invertible, speeds convergence to the extent that P −1 approximates A. We wholeheartedly refer the reader to Shewchuk <CitSpan>[ 14 ]</CitSpan> for information on the CG method.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We derive our modified conjugate gradient method by observing that the effect of the matrix W in equation <CitSpan>(14)</CitSpan> is to filter out velocity changes in the constrained directions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our idea then is to define an invariant— for all i, the component of v i in the constrained direction(s) of particle i is equal to z i —and then establish and maintain the invariant at each iteration, by defining a filtering procedure filter.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The role of filter is to take a vector a and perform the same filtering operation (see equation <CitSpan>(13)</CitSpan>) as multiplying by W, but leaving out the scaling by 1/m i : procedure filter(a) for i = 1 to n a i = S i a i return a</Sentence>
        49
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        Using filter, we define the modified CG method modified-pcg as follows:
        1 procedure modified-pcg 2 v = z 3 δ 0 = filter(b) T P filter(b) 4 r = filter(b − A v) 5 c = filter(P −1 r) 6 δ new = r T c 7 while δ new &gt; 2 δ 0 8 q = filter(Ac) 9 α = δ new /(c T q) 10 v = v + αc 11 r = r − αq 12 s = P −1 r 13 δ old = δ new 14 δ new = r T s 15 c = filter(s + δ new c) δ old Line 2 of the procedure establishes our invariant. <Sentence aspectClass="NONE" inAbstract="false">Lines 5 and 15 maintain the invariant by filtering c before adding it to v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The unmodified conjugate gradient method establishes a stopping criterion based on b T Pb.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Since our constrained formulation ignores certain components of b, our stopping criterion should as well, so we add filtering to line 3.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The vector r measures the solution error b − A v, and should not include error due to the constraints; hence we add filtering at lines 4 and 8.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Note that removing the calls to filter and changing line 2 to v = 0 yields the standard preconditioned conjugate gradient method.) We use a simple preconditioner P by making P be a diagonal matrix with P ii = 1/A ii so products involving P −1 are trivially computed.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More elaborate preconditioners could be used, though we doubt there is a large speedup to be gained.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Matrix-vector products with A are of course implemented in sparse matrix-vector fashion, using the data structures defined in section 2.3.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given modified-pcg, obvious questions are “does it work?</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">” followed by “how does it compare with the unmodified CG method?</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">” Proofs about CG methods are difficult in general; in practice, our method always converges, which answers the first question.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Prior to implementing modified-pcg, we used a penalty method and applied the standard CG method to equation <CitSpan>(15)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When we began using procedure modified-pcg, we did not notice any substantial change in the number of iterations required by the method.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Empirically, we conclude that the two methods have similar convergence behavior.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Result in section 8 indicate that the running time is close to O(n 1.5 ), which is what unmodified CG would be expected to deliver on this sort of problem <CitSpan>[ 14 ]</CitSpan>.</Sentence>
      
      
        <H2>5.4 Determining the Constraint Forces</H2>
        <Sentence aspectClass="NONE" inAbstract="false">For contact constraints (between cloth and solid objects) we need to know what the actual force of constraint is, in order to determine when to terminate a constraint.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Additionally, we need to know the constraint force actually exerted in order to model frictional forces properly.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Fortunately, it is easy to add one more step to modified-pcg to determine the constraint force.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When modified-pcg terminates, the residual error e = A v − b has the property that e i need not be close to zero if particle i is constrained.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In fact, e i is exactly the extra constraint force that must have been supplied to enforce the constraint.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus, we can compute constraint forces at the end of modified-pcg by performing one last matrixvector product to compute A v − b.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(The vector r in modified-pcg is equal to filter(A v − b), so the extra matrix-vector product to compute e really is necessary.) The particles’ accelerations are inherently dependent on one another through the matrix A of equation <CitSpan>(16)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This means that the correct approach to determing constraint release is combinatoric, as in Baraff <CitSpan>[ 2 ]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We reject this approach as impractical given the dimension of A. Instead, we allow contacts to release when the constraint force between a particle and a solid switches from a repulsive force to an attractive one.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In practice, this has proven to work well.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Friction presents a similar problem.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When cloth contacts a solid, we lock the particle onto the surface, if the relative tangential velocity is low.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We monitor the constraint force, and if the tangential force exceeds some fraction of the normal force, we allow the particle to slide on the surface.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">For high sliding velocities, we apply a dissipative tangential force, opposite the relative sliding direction, proportional to the normal force.</Sentence>
      
      
        <H1>6 Collisions</H1>
        <Sentence aspectClass="NONE" inAbstract="false">Much has been written about collision detection for cloth; we have nothing substantial to add to the subject of collision detection per se.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Cloth/cloth collisions are detected by checking pairs ( p, t) and (e 1 , e 2 ) for intersections, where p and t are a cloth particle and a cloth triangle respectively, and e 1 and e 2 are edges of cloth triangles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given a previous known legal state of the cloth, we postulate a linear motion for the cloth particles to the current (possibly illegal) state and check for either particle/triangle or edge/edge crossings.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">To avoid O(n 2 ) comparisons, we use a coherency-based boundingbox approach <CitSpan>[ 1 ]</CitSpan> to cull out the majority of pairs.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">When collisions between a cloth vertex and triangle, or two cloth edges are detected, we insert a strong damped spring force to push the cloth apart.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">A dissipative force tangent to the contact is also applied, countering any sliding motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The force is not, strictly speaking, a frictional force: rather it is proportional to the slip velocity, so it is in actuality a damping force, although it reasonably emulates dynamic friction.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">Applying static friction forces to cloth contacts is far more difficult, and is a problem we have not solved yet.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The forces, and their derivatives with respect to position and velocity, are of course included in equation <CitSpan>(15)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our system detects collisions between cloth particles and solid objects by testing each individual cloth particle against the faces of each solid object.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A solid object’s faces are grouped in a hierarchical bounding box tree, with the leaves of the tree being individual faces of the solid.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The tree is created by a simple recursive splitting along coordinate axes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The maintenance of contacts and the application of friction forces was described in the previous section.</Sentence>
      
      
        <H2>6.1 Constraint Initiation</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Both cloth/cloth and cloth/solid collisions give rise to the same problem whenever two contacts form.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For both types of collisions, our detection algorithm reports an intersection, and then takes action to remedy the situation: either by enforcing a constraint (cloth/solid collisions) or by adding a penalty force (cloth/cloth) collisions.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, since our simulator proceeds in discrete steps, collisions resulting in a reasonably substantial interpenetration depth can occur between one step and the next.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Clearly, this situation needs to be remedied.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">For cloth/cloth collisions, this would not appear to be a problem: the spring forces that are added work to counter the colliding velocities and then push the cloth apart.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">For cloth/solid collisions, however, the situation is more complicated.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">If we simply enforce a constraint which causes the colliding cloth particle to have a velocity consistent with the solid object’s velocity, and continue to enforce that constraint, the cloth particle will continue to remain embedded somewhere below the solid object’s surface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is unacceptable.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">One solution is to use Baumgarte stabilization <CitSpan>[ 18 ]</CitSpan>, which schedules the particle’s acceleration so that the position and velocity error of the particle with respect to the surface decay asymptotically to zero.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We experimented with this technique, but found it lacking.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">In particular, a fast rise to the surface was prone to noise and “jumpiness”; this could be eliminated, but at the cost of decreasing the step size.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">A slower rise to the surface caused visual artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We tried a simpler solution: when intersections occurred, rather than wait for a scheduled constraint or a penalty force to eliminate the intersection, we simply altered the positions of the cloth particles, effecting an instantaneous (and discontinuous) change in position.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">While this would be problematic when using a multi-step differential equation solver which expects continuity (such as a RungeKutta method), it should not interfere with a one-step solver such as the backward Euler method.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Unfortunately, simply changing particle positions produced disastrous results.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The stretch energy term in a cloth system is extremely strong, and altering particle positions arbitrarily introduced excessively large deformation energies in an altered particle’s neighborhood.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This resulted in visibly “jumpy” behavior of the cloth in localized regions.</Sentence>
        50
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
      
        <H2>6.2 Position Alteration</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Despite its initial failure, the ability to make arbitrary small changes in a particle’s position continued to attract our attention.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The entire process of implicit integration can be considered to be a filtering process <CitSpan>[ 7 ]</CitSpan>, and we postulated that a mechanism for filtering energy changes caused by displacing particles might make position alteration a viable technique.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">We considered that perhaps some sort of extra implicit step could be used as a filter, but forming and solving an additional linear system at each step seemed too expensive.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Happily, we can make use of the filtering effect of implicit integration without any extra work.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Consider a particle that has collided with a solid object.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The particle’s change in velocity at each step is under our control, using the constraint techniques described in section 5.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Meanwhile, the particle’s position at the next step follows from equation <CitSpan>(4)</CitSpan>: x i = h(v 0i + v i ) (recall that v 0i is the particle’s current velocity).</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The reason that changing positions after a step has been taken doesn’t work is because the particle’s neighbors receive no advance notification of the change in position: they are confronted with the alteration at the beginning of the next step.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This presents an obvious solution: we simply modify the top row of equation <CitSpan>(4)</CitSpan> to</Sentence>
        
          17
          x i = h(v 0i + v i ) + y i
        
        <Sentence aspectClass="NONE" inAbstract="false">where y i is an arbitrary correction term of our choice, introduced solely to move a particle to a desired location during the backward Euler step.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Having modified the top row of equation <CitSpan>(4)</CitSpan>, we must follow this change through: using equation <CitSpan>(17)</CitSpan> and repeating the derivation of section 3 and the symmetric transform from section 5 yields the modified symmetric system</Sentence>
        
          18
          M − h ∂v ∂f − h 2 ∂x ∂f v = h f 0 + h ∂x ∂f v 0 + ∂x ∂f y .
        
        <Sentence aspectClass="ADVANTAGE" inAbstract="false">This modification gives us complete control over both the position and velocity of a constrained particle in just one step, without any extra computational cost.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We use this technique to bring particles quickly and stably to the surface of solid objects without creating visual artifacts or limiting the allowable step size.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can also add correction terms to particles involved in cloth/cloth collisions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Without a constraint on those particles’ velocities there is no guarantee that they will go exactly where we want in one step, but the ability to induce sizeable jumps in position without excessively stiff spring forces adds greatly to the stability of the simulation.</Sentence>
      
      
        <H1>7 Adaptive Time Stepping</H1>
        <Sentence aspectClass="ADVANTAGE" inAbstract="false">The methods introduced in all of the previous sections usually allow us to take sizeable steps forward, without loss of stability.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Even so, there are still times when the step size must be reduced to avoid divergence.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">There are a large number of methods for altering the size of a time step, for both explicit and implicit integrators, but these methods tend to concentrate on the accuracy of the simulation, and not the stability.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our goal is animation, not engineering; thus visually pleasing results, meaning a numerically stable solution, rather than overall accuracy, is the deciding voice.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The trick is to recognize instability before you see it on your screen—by then it’s too late.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Stiffness, and thus any potential instability, arises almost completely from the strong stretch forces in the cloth.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">After each implicit step, we treat the resulting x as a proposed change in the cloth’s state, and examine the stretch terms (section 4.2) for each triangle in the newly proposed state.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If any triangle undergoes a drastic change in its stretch (in either the u or v direction) we discard the proposed state, reduce the step size, and try again.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Subtlety is not required: we find that an unstable step invariably results in stretch changes that are quite large, and are thus easily detected.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our simulation is run with a parameter that indicates the maximum allowable step size: this parameter is set by the user, and is always less than or equal to one frame.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(Most of our simulations involving human motions use a step size of 0.02 seconds.) Whenever the simulator reduces the step size, after two successes with the reduced step size the simulator tries to increase the step size.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the simulator fails at the larger step size, it reduces the size again, and waits for a longer period of time before retrying to increase the step size.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At its limit, the simulator will try increasing the step size every 40 steps; thus, if the user chooses too large a step, the simulator settles down to wasting only one out of every 40 steps in attempting too large a step.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">This method, though simple, has served us well.</Sentence>
      
      
        <H1>8 Results</H1>
         <Sentence aspectClass="NONE" inAbstract="false">Table 1 gives a performance summary of assorted animations, shown in figures 1–6.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Unaccounted overhead of the simulation (typically about 5%) includes tasks such as geometry transformations, memory allocation, etc.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The clothes in figures 3–6 were modeled as discrete planar panels, and then topologically seamed.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The simulator was used to relax the clothing from an initial deformed state, that got the clothes around the characters, to a well-fitting state on the characters.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The b u and b v parameters (see equation <CitSpan>(10)</CitSpan>) were then made smaller in certain regions to produce cuffs and waistbands, or strategically increased to induce wrinkling behavior in other regions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also ran the simulation in figure 1 with a range of stiffnesses for the bend term.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Using the stiffness parameters in figure 1 as a reference, we ran the simulation with those bend stiffnesses multiplied by 0.1, 1.0, 10, 100 and 1,000 (for a total range of 10,000 in the stiffness).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The variance in the running times was under 5%.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We doubt that simulators based on explicit integration methods could make a similar claim.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, we tried to estimate our simulator’s performance as a function of n, the number of cloth particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We ran the simulation in figure 1 with cloth resolutions of 500, 899, 2,602 (shown in figure 1 ) and 7,359 particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The running times were, respectively, 0.23 seconds/frame, 0.46 seconds/frame, 2.23 seconds/frame, and 10.3 seconds/frame.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is slightly better than O(n 1.5 ) performance, which is in line with the convergence rates of the conjugate gradient method <CitSpan>[ 14 ]</CitSpan> for systems such as equation <CitSpan>(18)</CitSpan>.</Sentence>
        51
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
            
              
                
                  
                   figure
                   no. vertices/no. triangles
                   time/frame
                
              
              
                
                  
                  
                   cloth solid
                   (CPU sec.)
                
                
                   1
                  
                   2,602/4,9442 322/640
                   2.23
                
                
                   2
                  
                   2,602/4,9442 322/640
                   3.06
                
                
                   3
                  
                   6,450/12,654 9,941/18,110
                   7.32
                
                
                   4
                   (shirt)
                   6,450/12,654 9,941/18,110
                   14.5
                
                
                  
                   (pants)
                   8,757/17,352 9,941/18,110
                   38.5
                
                
                   5
                   (skirt)
                   2,153/4,020 7,630/14,008
                   3.68
                
                
                  
                   (blouse)
                   5,108/10,016 7,630/14,008
                   16.7
                
                
                   6
                   (skirt)
                   4,530/8,844 7,630/14,008
                   10.2
                
                
                  
                   (blouse)
                   5,188/10,194 7,630/14,008
                   16.6
                
              
            
          
          figure no. vertices/no. triangles time/frame cloth solid (CPU sec.) 1 2,602/4,9442 322/640 2.23 2 2,602/4,9442 322/640 3.06 3 6,450/12,654 9,941/18,110 7.32 4 (shirt) 6,450/12,654 9,941/18,110 14.5 (pants) 8,757/17,352 9,941/18,110 38.5 5 (skirt) 2,153/4,020 7,630/14,008 3.68 (blouse) 5,108/10,016 7,630/14,008 16.7 6 (skirt) 4,530/8,844 7,630/14,008 10.2 (blouse) 5,188/10,194 7,630/14,008 16.6
          Table 1: System performance for simulations in figures 1–6. Minimum and maximum time steps are in milliseconds of simulation time. Time/frame indicates actual CPU time for each frame, averaged over the simulation. Percentages of total running time are given for four tasks: EVAL— forming the linear system of equation <CitSpan>(18)</CitSpan>; CG—solving equation <CitSpan>(18)</CitSpan>; C/C—cloth/cloth collision detection; and C/S—cloth/solid collision detection.
        
      
      
        <H1>9 Acknowledgments</H1>
        <Sentence aspectClass="NONE" inAbstract="false">This research was supported in part by an ONR Young Investigator award, an NSF CAREER award, and grants from the Intel Corporation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We thank Alias|Wavefront for supplying the models and motion capture data used in figures 5 and 6.</Sentence>
      
      
        <H1>References</H1>
        
          [1] D. Baraff. Dynamic Simulation of Non-penetrating Rigid Bodies. PhD thesis, Cornell University, May 1992.
          [2] D. Baraff. Fast contact force computation for nonpenetrating rigid bodies. Computer Graphics (Proc. SIGGRAPH), 28:23– 34, 1994.
          [3] D.E. Breen, D.H. House, and M.J. Wozny. Predicting the drape of woven cloth using interacting particles. Computer Graphics (Proc. SIGGRAPH), pages 365–372, 1994.
          [4] M. Carignan, Y. Yang, N. Magenenat-Thalmann, and D. Thalmann. Dressing animated synthetic actors with complex deformable clothes. Computer Graphics (Proc. SIGGRAPH), pages 99–104, 1992.
          [5] B. Eberhardt, A. Weber, and W. Strasser. A fast, flexible, particle-system model for cloth draping. IEEE Computer Graphics and Applications, 16:52–59, 1996.
          [6] G. Golub and C. Van Loan. Matrix Computations. John Hopkins University Press, 1983.
          [7] M. Kass. An Introduction To Physically Based Modeling, chapter Introduction to Continuum Dynamics for Computer Graphics. SIGGRAPH Course Notes, ACM SIGGRAPH, 1995.
          [8] M. Kass and G. Miller. Rapid, stable fluid dynamics for computer graphics. Computer Graphics (Proc. SIGGRAPH), pages 49–58, 1990.
          [9] H.N. Ng and R.L. Grimsdale. Computer graphics techniques for modeling cloth. IEEE Computer Graphics and Applications, 16:28–41, 1996.
          [10] H. Okabe, H. Imaoka, T. Tomiha, and H. Niwaya. Three dimensional apparel cad system. Computer Graphics (Proc. SIGGRAPH), pages 105–110, 1992.  step size total frames/ task breakdown percentage min/max (ms) total steps EVAL CG C/C C/S 16.5/33 75/80 25.7 50.4 18.3 1.4 16.5/33 75/80 17.9 63.6 15.3 0.2 16.5/33 50/52 18.9 37.9 30.9 2.6 2.5/20 430/748 16.7 29.9 46.1 2.2 0.625/20 430/1214 16.4 35.7 42.5 1.7 5/20 393/715 18.1 30.0 44.5 1.5 5/20 393/701 11.2 26.0 57.7 1.3 10/20 393/670 20.1 36.8 29.7 2.6 1.25/20 393/753 13.2 30.9 50.2 1.4
          [11] J.C. Platt and A.H. Barr. Constraint methods for flexible models. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 279–288. ACM, July 1988.
          [12] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling. Numerical Recipes. Cambridge University Press, 1986.
          [13] X. Provot. Deformation constraints in a mass-spring model to describe rigid cloth behavior. In Graphics Interface, pages 147–155, 1995.
          [14] J. Shewchuk. An introduction to the conjugate gradient method without the agonizing pain. Technical Report CMUCS-TR-94-125, Carnegie Mellon University, 1994. (See also http://www.cs.cmu.edu/ ~quake-papers/ painless-conjugate-gradient.ps.).
          [15] D. Terzopoulos and K. Fleischer. Deformable models. Visual Computer, 4:306–331, 1988.
          [16] D. Terzopoulos and K. Fleischer. Modeling inelastic deformation: Viscoelasticity, plasticity, fracture. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 269–278. ACM, August 1988.
          [17] D. Terzopoulos, J.C. Platt, and A.H. Barr. Elastically deformable models. Computer Graphics (Proc. SIGGRAPH), 21:205–214, 1987.
          [18] D. Terzopoulos and H. Qin. Dynamics nurbs with geometric constraints for interactive sculpting. ACM Transactions on Graphics, 13:103–136, 1994.
          [19] X. Tu. Artificial Animals for Computer Animation: Biomechanics, Locomotion, Perception and Behavior. PhD thesis, University of Toronto, May 1996.
          [20] P. Volino, M. Courchesne, and N. Magnenat Thalmann. Versatile and efficient techniques for simulating cloth and other deformable objects. Computer Graphics (Proc. SIGGRAPH), pages 137–144, 1995.
          [21] P. Volino, N. Magnenat Thalmann, S. Jianhua, and D. Thalmann. An evolving system for simulating clothes on virtual actors. IEEE Computer Graphics and Applications, 16:42–51, 1996.
        
        52
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
        
         Figure 1 (top row): Cloth draping on cylinder; frames 8, 13 and 35. Figure 2 (second row): Sheet with two fixed particles; frames 10, 29 and 67. Figure 3 (third row): Shirt on twisting figure; frames 1, 24 and 46. Figure 4 (bottom row): Walking man; frames 30, 45 and 58.
        53
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
        
        Figure 5 (top row): Dancer with short skirt; frames 110, 136 and 155. Figure 6 (middle row): frames 185, 215 and 236. Figure 7 (bottom row): Closeups from figures 4 and 6.
        Dancer with long skirt;
        54
      
    
  

</Document>
