<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A39_C09_Large_Steps_in_Cloth_Simulation_RHETORICAL_v1.xml">


  
    017b6d2b25319c95a2cd999a36ac1d494fe88ccc7fad3ade48ad7264a95db1a8
    3wzw
    http://dx.doi.org/10.1145/280814.280821
  
  
    
      SIGGRAPH 98, Orlando, July 19–24
      C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
        <Title>Large Steps in Cloth Simulation</Title>
      
      
        
          David Baraff Andrew Witkin Robotics Institute Carnegie Mellon University
        
      
      <Abstract>
<Sentence inAbstract="true" rhetoricalClass="DRI_Challenge">The bottle-neck in most cloth simulation systems is that time steps must be small to avoid numerical instability.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Outcome_Contribution">This paper describes a cloth simulation system that can stably take large time steps.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Approach">The simulation system couples a new technique for enforcing constraints on individual cloth particles with an implicit integration method.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Approach">The simulator models cloth as a triangular mesh, with internal cloth forces derived using a simple continuum formulation that supports modeling operations such as local anisotropic stretch or compression; a unified treatment of damping forces is included as well.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Approach">The implicit integration method generates a large, unbanded sparse linear system at each time step which is solved using a modified conjugate gradient method that simultaneously enforces particles’ constraints.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Approach">The constraints are always maintained exactly, independent of the number of conjugate gradient iterations, which is typically small.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Outcome_Contribution">The resulting simulation system is significantly faster than previous accounts of cloth simulation systems in the literature.</Sentence>
</Abstract>
	   Keywords: Cloth, simulation, constraints, implicit integration, physically-based modeling.
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">Physically-based cloth animation has been a problem of interest to the graphics community for more than a decade.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Early work by Terzopoulos et al. <CitSpan>[ 17 ]</CitSpan> and Terzopoulos and Fleischer <CitSpan>[ 15 , 16 ]</CitSpan> on deformable models correctly characterized cloth simulation as a problem in deformable surfaces, and applied techniques from the mechanical engineering and finite element communities to the problem.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Since then, other research groups (notably Carignan et al. <CitSpan>[ 4 ]</CitSpan> and Volino et al. <CitSpan>[ 20 , 21 ]</CitSpan>; Breen et al. <CitSpan>[ 3 ]</CitSpan>; and Eberhardt et al. <CitSpan>[ 5 ]</CitSpan>) have taken up the challenge of cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Although specific details vary (underlying representations, numerical solution methods, collision detection and constraint methods, etc.), there is a deep commonality amongst all the approaches: physically-based cloth simulation is formulated as a time-varying partial differential equation which, after discretization, is numerically solved as an ordinary differential equation</Sentence>
      
        1
        ẍ = M −1 − ∂E + F . ∂x
      
      <Sentence inAbstract="false" rhetoricalClass="Sentence">In this equation the vector x and diagonal matrix M represent the geometric state and mass distribution of the cloth, E—a scalar funcAuthor affiliation <CitSpan>(September 1998)</CitSpan>: David Baraff, Andrew Witkin, Pixar Animation Studios, 1001 West Cutting Blvd.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="Sentence">, Richmond, CA 94804.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Email: deb@pixar.com , aw@pixar.com .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">This is an electronic reprint.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Permission is granted to copy part or all of this paper for noncommercial use provided that the title and this copyright notice appear.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">This electronic reprint is ©1998 by CMU.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The original printed paper is ©1998 by the ACM.</Sentence>
      <Sentence inAbstract="false" rhetoricalClass="Sentence">tion of x—yields the cloth’s internal energy, and F (a function of x and x) describes other forces (air-drag, contact and constraint forces, internal damping, etc.) acting on the cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">In this paper, we describe a cloth simulation system that is much faster than previously reported simulation systems.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our system’s faster performance begins with the choice of an implicit numerical integration method to solve equation <CitSpan>(1)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The reader should note that the use of implicit integration methods in cloth simulation is far from novel: initial work by Terzopoulos et al. <CitSpan>[ 15 , 16 , 17 ]</CitSpan> applied such methods to the problem.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">1 Since this time though, research on cloth simulation has generally relied on explicit numerical integration (such as Euler’s method or Runge-Kutta methods) to advance the simulation, or, in the case of of energy minimization, analogous methods such as steepest-descent <CitSpan>[ 3 , 10 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">This is unfortunate.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">Cloth strongly resists stretching motions while being comparatively permissive in allowing bending or shearing motions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">This results in a “stiff” underlying differential equation of motion <CitSpan>[ 12 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">Explicit methods are ill-suited to solving stiff equations because they require many small steps to stably advance the simulation forward in time.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">2 In practice, the computational cost of an explicit method greatly limits the realizable resolution of the cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">For some applications, the required spatial resolution—that is, the dimension n of the state vector x—can be quite low: a resolution of only a few hundred particles (or nodal points, depending on your formulation/terminology) can be sufficient when it comes to modeling flags or tablecloths.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">To animate clothing, which is our main concern, requires much higher spatial resolution to adequately represent realistic (or even semi-realistic) wrinkling and folding configurations.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">In this paper, we demonstrate that implicit methods for cloth overcome the performance limits inherent in explicit simulation methods.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">We describe a simulation system that uses a triangular mesh for cloth surfaces, eliminating topological restrictions of rectangular meshes, and a simple but versatile formulation of the internal cloth energy forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(Unlike previous metric-tensor-based formulations <CitSpan>[ 15 , 16 , 17 , 4 ]</CitSpan> which model some deformation energies as quartic functions of positions, we model deformation energies only as quadratic functions with suitably large scaling.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Quadratic energy models mesh well with implicit integration’s numerical properties.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">) We also introduce a simple, unified treatment of damping forces, a subject which has been largely ignored thus far.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A key step in our simulation process is the solution of an O(n) × O(n) sparse linear system, which arises from the implicit integration method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">In this respect, our implementation differs greatly from the implementation by Terzopoulos et al. <CitSpan>[ 15 , 17 ]</CitSpan>, which for large simulations
      1 Additional use of implicit methods in animation and dynamics work includes Kass and Miller <CitSpan>[ 8 ]</CitSpan>, Terzopoulos and Qin <CitSpan>[ 18 ]</CitSpan>, and Tu <CitSpan>[ 19 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">2 Even worse, the number of time steps per frame tends to increase along with the problem size, for an explicit method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Cloth simulations of size n— meaning x ∈ IR O(n) —generally require O(n) explicit steps per unit simulated time.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Because the cost of an explicit step is also O(n) (setting aside complications such as collision detection for now) explicit methods for cloth require time O(n 2 )—or worse.</Sentence>
      43
     <Sentence inAbstract="false" rhetoricalClass="Sentence"> </Sentence>SIGGRAPH 98, Orlando, July 19–24
      C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      used an “alternating-direction” implicit (ADI) method <CitSpan>[ 12 ]</CitSpan>. <Sentence inAbstract="false" rhetoricalClass="DRI_Background">An ADI method generates a series of tightly banded (and thus quickly solved) linear systems rather than one large sparse system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">(The price, however, is that some of the forces in the system—notably between diagonally-adjacent and non-adjacent nodes involved in self-collisions—are treated explicitly, not implicitly.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">) The speed (and ease) with which our sparse linear systems can be robustly solved—even for systems involving 25,000 variables or more—has convinced us that there is no benefit to be gained from using an ADI method instead (even if ADI methods could be applied to irregular triangular meshes).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Thus, regardless of simulation size, we treat all forces as part of the implicit formulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Even for extremely stiff systems, numerical stability has not been an issue for our simulator.</Sentence>
      
        <H2>1.1 Specific Contributions</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Much of the performance of our system stems from the development of an implicit integration formulation that handles contact and geometric constraints in a direct fashion.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Specifically, our simulator enforces constraints without introducing additional penalty terms in the energy function E or adding Lagrange-multiplier forces into the force F. (This sort of direct constraint treatment is trivial if equation <CitSpan>(1)</CitSpan> is integrated using explicit techniques, but is problematic for implicit methods.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Our formulation for directly imposing and maintaining constraints is harmonious with the use of an extremely fast iterative solution algorithm—a modified version of the conjugate gradient (CG) method—to solve the O(n) × O(n) linear system generated by the implicit integrator.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Iterative methods do not in general solve linear systems exactly—they are run until the solution error drops below some tolerance threshold.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A property of our approach, however, is that the constraints are maintained exactly, regardless of the number of iterations taken by the linear solver.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, we introduce a simple method, tailored to cloth simulation, for dynamically adapting the size of time steps over the course of a simulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The combination of implicit integration and direct constraint satisfaction is very powerful, because this approach almost always allows us to take large steps forward.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">In general, most of our simulations require on average from two to three time steps per frame of 30 Hz animation, even for (relatively) fast moving cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The large step sizes complement the fact that the CG solver requires relatively few iterations to converge.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">For example, in simulating a 6, 000 node system, the solver takes only 50–100 iterations to solve the 18, 000 × 18, 000 linear system formed at each step.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, the running time of our simulator is remarkably insensitive to the cloth’s material properties (quite the opposite behavior of explicit methods).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">All of the above advantages translate directly into a fast running time.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">For example, we demonstrate results similar to those in Breen et al. <CitSpan>[ 3 ]</CitSpan> and Eberhardt et al. <CitSpan>[ 5 ]</CitSpan> (draping of a 2,600 node cloth) with a running time just over 2 seconds per frame on an SGI Octane R10000 195 Mhz processor.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Similarly, we show garments (shirts, pants, skirts) exhibiting complex wrinkling and folding behavior on both key-framed and motion-captured characters.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Representative running times include a long skirt with 4,530 nodes (8,844 triangles) on a dancing character at a cost of 10 seconds per frame, and a shirt with 6,450 nodes (12,654 triangles) with a cost varying between 8 to 14 seconds per frame, depending on the underlying character’s motion.</Sentence>
      
      
        <H2>1.2 Previous Work</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Terzopoulos et al. <CitSpan>[ 15 , 17 ]</CitSpan> discretized cloth as a rectangular mesh.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Energy functions were derived using a continuum formulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">This work recognized the need for damping forces; however, only a simple viscous drag force −k x was used.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The linear systems result- ing from the use of implicit integration techniques were solved, for small systems, by direct methods such as Choleski factorization, or using iterative techniques such as Gauss-Seidel relaxation or conjugate gradients.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">(For a square √ system of n nodes, the resulting linear system has bandwidth n.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In this case, banded Choleski factorization <CitSpan>[ 6 ]</CitSpan> requires time O(n 2 ).</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Background">) As previously discussed, Terzopoulos et al. made use of an ADI method for larger cloth simulations.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Following Terzopoulos et al.’s treatment of deformable surfaces, work by Carignan et al. <CitSpan>[ 4 ]</CitSpan> described a cloth simulation system using rectangular discretization and the same formulation as Terzopoulos et al. Explicit integration was used.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Carignan et al. recognized the need for damping functions which do not penalize rigidbody motions of the cloth (as simple viscous damping does) and they added a force which damps cloth stretch and shear (but not bend).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Later work by the same group includes Volino et al. <CitSpan>[ 20 ]</CitSpan>, which focuses mainly on collision detection/response and uses a triangular mesh; no mention is made of damping forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The system uses the midpoint method (an explicit method) to advance the simulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Thus far, the accumulated work by this group (see Volino et al. <CitSpan>[ 21 ]</CitSpan> for an overview) gives the only published results we know of for simulated garments on moving characters.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Reported resolutions of the garments are approximately two thousand triangles per garment (roughly 1,000 nodal points) <CitSpan>[ 21 ]</CitSpan> with running times of several minutes per frame for each garment on an SGI R4400 150 Mhz processor.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Breen et al. <CitSpan>[ 3 ]</CitSpan> depart completely from continuum formulations of the energy function, and describe what they call a “particlebased” approach to the problem.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">By making use of real-world cloth material properties (the Kawabata measuring system) they produced highly realistic static images of draped rectangular cloth meshes with reported resolutions of up to 51 × 51 nodes.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The focus of this work is on static poses for cloth, as opposed to animation: thus, their simulation process is best described as energy minimization, although methods analogous to explicit methods are used.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Speed was of secondary concern in this work.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Refinements by Eberhardt et al. <CitSpan>[ 5 ]</CitSpan>—notably, the use of higher-order explicit integration methods and Maple-optimized code, as well as a dynamic, not static treatment of the problem—obtain similarly realistic results, while dropping the computational cost to approximately 20–30 minutes per frame on an SGI R8000 processor.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">No mention is made of damping terms.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Provot <CitSpan>[ 13 ]</CitSpan> focuses on improving the performance of explicit methods by a post-step modification of nodal positions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">He iteratively adjusts nodal positions to eliminate unwanted stretch; the convergence properties of this method are unclear.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">A more comprehensive discussion on cloth research can be found in the survey paper by Ng and Grimsdale <CitSpan>[ 9 ]</CitSpan>.</Sentence>
      
      
        <H1>2 Simulation Overview</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In this section, we give a brief overview of our simulator’s architecture and introduce some notation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The next section derives the linear system used to step the simulator forward implicitly while section 4 describes the specifics of the internal forces and their derivatives that form the linear system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Section 5 describes how constraints are maintained (once established), with a discussion in section 6 on collision detection and constraint initialization.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Section 7 describes our adaptive step-size control, and we conclude in section 8 with some simulation results.</Sentence>
      
      
        <H2>2.1 Notation and Geometry</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our simulator models cloth as a triangular mesh of particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given a mesh of n particles, the position in world-space of the ith particle is x i ∈ IR 3 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The geometric state of all the particles is simply x ∈ IR 3n .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The same component notation applies to forces: a force f ∈ IR 3n acting on the cloth exerts a force f i on the ith particle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Real-world cloth is cut from flat sheets of material and tends to resist deformations away from this initial flat state (creases and pleats not withstanding).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We capture the rest state of cloth by assigning each particle an unchanging coordinate (u i , v i ) in the plane.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">3 Section 4 makes use of these planar coordinates.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Collisions between cloth and solid objects are handled by preventing cloth particles from interpenetrating solid objects.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our current implementation models solid objects as triangularly faced polyhedra.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Each face has an associated thickness and an orientation; particles found to be sufficiently near a face, and on the wrong side, are deemed to have collided with that face, and become subject to a contact constraint.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(If relative velocities are extremely high, this simple test may miss some collisions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In this case, analytically checking for intersection between previous and current positions can guarantee that no collisions are missed.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) For cloth/cloth collisions, we detect both face-vertex collisions between cloth particles and triangles, as well as edge/edge collisions between portions of the cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">As in the case of solids, close proximity or actual intersection of cloth with itself initiates contact handling.</Sentence>
        44
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
      
        <H2>2.2 Energy and Forces</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The most critical forces in the system are the internal cloth forces which impart much of the cloth’s characteristic behavior.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Breen et al. <CitSpan>[ 3 ]</CitSpan> describes the use of the Kawabata system of measurement for realistic determination of the in-plane shearing and out-of-plane bending forces in cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We call these two forces the shear and bend forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We formulate the shear force on a per triangle basis, while the bend force is formulated on a per edge basis—between pairs of adjacent triangles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The strongest internal force—which we call the stretch force— resists in-plane stretching or compression, and is also formulated per triangle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Under normal conditions, cloth does not stretch appreciably under its own weight.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This requires the stretch force to have a high coefficient of stiffness, and in fact, it is the stretch force that is most responsible for the stiffness of equation <CitSpan>(1)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">A common practice in explicitly integrated cloth systems is to improve running time by decreasing the strength of the stretch force; however, this leads to “rubbery” or “bouncy” cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our system uses a very stiff stretch force to combat this problem, without any detrimental effects on the run-time performance.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">While the shear and bend force stiffness coefficients depend on the material being simulated, the stretch coefficient is essentially the same (large) value for all simulations.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(Of course, if stretchy cloth is specifically called for, the stretch coefficient can be made smaller.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Complementing the above three internal forces are three damping forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In section 5, we formulate damping forces that subdue any oscillations having to do with, respectively, stretching, shearing, and bending motions of the cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The damping forces do not dissipate energy due to other modes of motion.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additional forces include air-drag, gravity, and user-generated generated mouse-forces (for interactive simulations).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Cloth/cloth contacts generate strong repulsive linear-spring forces between cloth particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Combining all forces into a net force vector f, the acceleration ẍ i of the ith particle is simply ẍ i = f i /m i , where m i is the ith particle’s mass.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The mass m i is determined by summing one third the mass
        3 In general, each particle has a unique (u, v) coordinate; however, to accommodate pieces of cloth that have been topologically seamed together (such as a sleeve), particles lying on the seam must have multiple (u, v) coordinates.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">For these particles, we let the (u, v) coordinate depend on which triangle we are currently examining.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The (u, v) coordinates are useful for texturing.</Sentence>
        <Sentence inAbstract="false" rhetoricalClass="Sentence">of all triangles containing the ith particle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(A triangle’s mass is the product of the cloth’s density and the triangle’s fixed area in the uv coordinate system.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="Sentence">) Defining the diagonal mass matrix M ∈ IR 3n×3n by diag(M) = (m 1 , m 1 , m 1 , m 2 , m 2 , m 2 , . . . , m n , m n , m n ), we can write simply that</Sentence>
        
          2
          ẍ = M −1 f(x, x).
        
      
      
        <H2>2.3 Sparse Matrices</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The use of an implicit integration method, described in the next section, generates large unbanded sparse linear systems.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We solve these systems through a modified conjugate gradient (CG) iterative method, described in section 5.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">CG methods exploit sparsity quite easily, since they are based solely on matrix-vector multiplies, and require only rudimentary sparse storage techniques.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The sparsity of the matrix generated by the implicit integrator is best represented in block-fashion: for a system with n particles, we deal with an n × n matrix, whose non-zero entries are represented as dense 3 × 3 matrices of scalars.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The matrix is represented as an array of n rows; each row is a linked list of the non-zero elements of that row, to accommodate possible run-time changes in the sparsity pattern, due to cloth/cloth contact.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The (dense) vectors that are multiplied against this matrix are stored simply as n element arrays of threecomponent vectors.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The overall implementation of sparsity is completely straightforward.</Sentence>
      
      
        <H2>2.4 Constraints</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">An individual particle’s position and velocity can be completely controlled in either one, two, or three dimensions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Particles can thus be attached to a fixed or moving point in space, or constrained to a fixed or moving surface or curve.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Constraints are either user-defined (the time period that a constraint is active is user-controlled) or automatically generated, in the case of contact constraints between cloth and solids.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">During cloth/solid contacts, the particle may be attached to the surface, depending on the magnitudes of the frictional forces required; otherwise, the particle is constrained to remain on the surface, with sliding allowed.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The mechanism for releasing a contact constraint, or switching between sliding or not sliding, is described in section 5.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The constraint techniques we use on individual particles work just as well for collections of particles; thus, we could handle cloth/cloth intersections using the technique described in section 5, but the cost is potentially large.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For that reason, we have chosen to deal with cloth/cloth contacts using penalty forces: whenever a particle is near a cloth triangle or is detected to have passed through a cloth triangle, we add a stiff spring with damping to pull the particle back to the correct side of the triangle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The implicit solver easily tolerates these stiff forces.</Sentence>
      
      
        <H1>3 Implicit Integration</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given the known position x(t 0 ) and velocity x(t 0 ) of the system at time t 0 , our goal is to determine a new position x(t 0 + h) and velocity x(t 0 + h) at time t 0 + h.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To compute the new state and velocity using an implicit technique, we must first transform equation <CitSpan>(2)</CitSpan> into a first-order differential equation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">This is accomplished simply by defining the system’s velocity v as v = x and then writing</Sentence>
        
          3
          dt d x x = dt d v x = M −1 f(x, v v) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To simplify notation, we will define x 0 = x(t 0 ) and v 0 = v(t 0 ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We also define x = x(t 0 + h) − x(t 0 ) and v = v(t 0 + h) − v(t 0 ).</Sentence>
        45
       <Sentence inAbstract="false" rhetoricalClass="Sentence"> </Sentence>SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        The explicit forward Euler method applied to equation <CitSpan>(3)</CitSpan> approximates x and v as x v = h M v −1 0 f 0
        where the force f 0 is defined by f 0 = f(x 0 , v 0 ). <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">As previously discussed, the step size h must be quite small to ensure stability when using this method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The implicit backward Euler method appears similar at first: x and v are approximated by</Sentence>
        
          4
          v x = h M −1 f(x 0 v + 0 + x, v v 0 + v) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The difference in the two methods is that the forward method’s step is based solely on conditions at time t 0 while the backward method’s step is written in terms of conditions at the terminus of the step itself.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">4 The forward method requires only an evaluation of the function f but the backward method requires that we solve for values of x and v that satisfy equation <CitSpan>(4)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Equation <CitSpan>(4)</CitSpan> is a nonlinear equation: rather than solve this equation exactly (which would require iteration) we apply a Taylor series expansion to f and make the firstorder approximation ∂f ∂f f(x 0 + x, v 0 + v) = f 0 + ∂x x + ∂v v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In this equation, the derivative ∂f/∂x is evaluated for the state (x 0 , v 0 ) and similarly for ∂f/∂v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Substituting this approximation into equation <CitSpan>(4)</CitSpan> yields the linear system</Sentence>
        
          5
          v x = h M −1 (f 0 + v 0 ∂x ∂f + x v + ∂v ∂f v) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Taking the bottom row of equation <CitSpan>(5)</CitSpan> and substituting x = h(v 0 + v) yields v = hM −1 f 0 + ∂x ∂f h(v 0 + v) + ∂v ∂f v .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Letting I denote the identity matrix, and regrouping, we obtain</Sentence>
        
          6
          I − hM −1 ∂v ∂f − h 2 M −1 ∂x ∂f v = hM −1 f 0 + h ∂x ∂f v 0
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">which we then solve for v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given v, we trivially compute x = h(v 0 + v).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Thus, the backward Euler step consists of evaluating f 0 , ∂f/∂x and ∂f/∂v; forming the system in equation <CitSpan>(6)</CitSpan>; solving the system for v; and then updating x and v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We use the sparse data structures described in section 2.3 to store the linear system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The sparsity pattern of equation <CitSpan>(6)</CitSpan> is described in the next section, while solution techniques are deferred to section 5.</Sentence>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">4 The method is called “backward” Euler because starting from the output state (x 0 + x, v 0 + v) and using a forward Euler step to run the system backward in time (i.e. taking the step −h(v(t 0 + h), f(x(t 0 + h), v(t 0 + h))) brings you back to (x 0 , v 0 ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">What is the value in this?</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Forward Euler takes no notice of wildly changing derivatives, and proceeds forward quite blindly.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Backward Euler, however, forces one to find an output state whose derivative at least points back to where you came from, imparting, essentially, an additional layer of consistency (or sanity-checking, if you will).</Sentence>
      
      
        <H1>4 Forces</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Cloth’s material behavior is customarily described in terms of a scalar potential energy function E(x); the force f arising from this energy is f = −∂E/∂x.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Equation <CitSpan>(6)</CitSpan> requires both the vector f and the matrix ∂f/∂x.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Expressing the energy E as a single monolithic function—encompassing all aspects of the cloth’s internal behavior—and then taking derivatives is impractical, from a bookkeeping point of view.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A better approach is decompose E into a sum of sparse energy functions; that is, to write E(x) = α E α (x) where each E α depends on as few elements of x—as few particles—as possible.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">However, even decomposing E into sparse energy functions is not enough.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Energy functions are an undesirable starting point because sensible damping functions cannot be derived from energy functions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Instead, we define internal behavior by formulating a vector condition C(x) which we want to be zero, and then defining the associated energy as k C(x) T C(x) where k is a stiffness constant.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">2 In section 4.5, we show how sensible damping functions can be constructed based on this formulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">An added bonus is that starting from this vector-based energy description tends to result in a simpler, more compact, and more easily coded formulation for ∂f/∂x than proceeding from an energy function in which the structure of C has been lost.</Sentence>
      
      
        <H2>4.1 Forces and Force Derivatives</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given a condition C(x) which we want to be zero, we associate an energy function E C with C by writing E C (x) = k 2 C(x) T C(x) where k is a stiffness constant of our choice.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Assuming that C depends on only a few particle, C gives rise to a sparse force vector f.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Recall from section 2.1 that we view the vector f in block form; each element f i is a vector in IR 3 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">For each particle i that C depends on,</Sentence>
        
          7
          f i = − ∂E ∂x C i = −k ∂C(x) ∂x i C(x);
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">all the other elements of f are zero.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Similarly, the derivative of f is also sparse.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Defining the derivative matrix K = ∂f/∂x, the nonzero entries of K are K ij for all pairs of particles i and j that C depends on.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Again, we treat K in block fashion: K ∈ IR 3n×3n , so an element K ij is a 3 × 3 matrix.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">From equation <CitSpan>(7)</CitSpan>, we have</Sentence>
        
          8
          K ij = ∂x ∂f i j = −k ∂C(x) ∂x i ∂C(x) ∂x j T + ∂ ∂x 2 C(x) i ∂x j C(x) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, since K ij is a second derivative—that is, K ij = ∂f i /∂x j = ∂ 2 E/∂x i ∂x j —we have K ij = K T ji so K is symmetric.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Note that since C does not depend on v, the matrix ∂f/∂v is zero.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We can now easily describe the internal forces acting on the cloth, by just writing condition functions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Forces and their derivatives are easily derived using equations <CitSpan>(7) and (8)</CitSpan>.</Sentence>
      
      
        <H2>4.2 Stretch Forces</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Recall that every cloth particle has a changing position x i in world space, and a fixed plane coordinate (u i , v i ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Even though our cloth is modeled as a discrete set of points, grouped into triangles, it will be convenient to pretend momentarily that we have a single continuous function w(u, v) that maps from plane coordinates to world space.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Stretch can be measured at any point in the cloth surface by examining the derivatives w u = ∂w/∂u and w v = ∂w/∂v at that point.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The magnitude of w u describes the stretch or compression in the u direction; the material is unstretched wherever w u = 1.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Stretch in the v direction is measured by w v .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">(Some previous continuum formulations have modeled stretch energy along an axis as essentially (w u T w u − 1) 2 , which is a quartic function of position <CitSpan>[ 15 , 16 , 17 , 4 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We find this to be needlessly stiff; worse, near the rest state, the force gradient—a quadratic function of position—is quite small, which partially negates the advantage implicit integration has in exploiting knowledge of the force gradient.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A quadratic model for energy is, numerically, a better choice.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) We apply this stretch/compression measure to a triangle as follows.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Let us consider a triangle whose vertices are particles i, j and k.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Define x 1 = x j − x i and x 2 = x k − x i .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Also, let u 1 = u j − u i , while u 2 = u k − u i and similarly for v 1 and v 2 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We approximate w(u, v) as a linear function over each triangle; this is equivalent to saying that w u and w v are constant over each triangle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This lets us write x 1 = w u u 1 + w v v 1 and x 2 = w u u 2 + w v v 2 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Solving for w u and w v yields</Sentence>
        46
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          9
          −1 (w u w v ) = ( x 1 x 2 ) v u 1 1 v u 2 2 .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Note that x 1 and x 2 vary during the simulation but the matrix in the above equation does not.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We can treat w u and w v as functions of x, realizing that they depend only on x i , x j and x k and using equation <CitSpan>(9)</CitSpan> to obtain derivatives.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The condition we use for the stretch energy is</Sentence>
        
          10
          C(x) = a w w u v (x) (x) − − b b v u
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">where a is the triangle’s area in uv coordinates.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Usually, we set b u = b v = 1, though we need not always do so.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In particular, if we want to slightly lengthen a garment (for example, a sleeve) in the u direction, we can increase b u , which causes w u to seek a larger value, and tends to induce wrinkles across the u direction.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Likewise, we might decrease b v near the end of a sleeve, inducing a tight cuff, as on a sweatshirt.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We have found the ability to control shrink/stretch anisotropically to be an indispensable modeling tool.</Sentence>
      
      
        <H2>4.3 Shear and Bend Forces</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Cloth likewise resists shearing in the plane.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We can measure the extent to which cloth has sheared in a triangle by considering the inner product w u T w v .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In its rest state, this product is zero.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since the stretch term prevents the magnitudes of w u and w v from changing overly much, we need not normalize.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">By the small angle approximation, the product w u T w v is a reasonable approximation to the shear angle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The condition for shearing is simply C(x) = aw u (x) T w v (x) with a the triangle’s area in the uv plane.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We measure bend between pairs of adjacent triangles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The condition we write for the bend energy depends upon the four particles defining the two adjoining triangles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If we let n 1 and n 2 denote the unit normals of the two triangles and let e be a unit vector parallel to the common edge, the angle θ between the two faces is defined by the relations sin θ = (n 1 × n 2 ) · e and cos θ = n 1 · n 2 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We define a condition for bending by writing simply C(x) = θ which results in a force that counters bending.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">5 The assumption that the stretch energy will keep the cloth from stretching much allows us to treat n 1 , 5 For reasonably equilateral triangles, as edge lengths decrease, the curvature represented by a particular angle θ between triangles increases.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Since the square of the curvature—a a good measure of the bend energy in cloth— increases at the same rate that the triangle’s area decreases, the condition C should not be scaled by the triangles’ areas.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">See Breen et al. <CitSpan>[ 3 ]</CitSpan> for a further discussion of relating curvature to bend angle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">n 2 and e as having a constant length at each step of the simulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This makes differentiating θ with respect to x a manageable task.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Rectangular meshes make it simple to treat bending anisotropically.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The uv coordinates associated with particles make this possible for triangular meshes as well.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given material for which bending in the u and v directions are weighted by stiffnesses k u and k v , we can emulate this anisotropy as follows.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Let the edge between the triangles be between particles i and j, and define u = u i − u j and v = v i − v j .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The stiffness weighting for this edge should simply be k u ( u) 2 + k v ( v) 2 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">( u) 2 + ( v) 2</Sentence>
      
      
        <H2>4.4 Additional Forces</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To the above forces we also add easily implemented forces such as gravity and air-drag (which is formulated on a per-triangle basis, and opposes velocities along the triangle’s normal direction).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When the simulation is fast enough to interact with, we add user-controlled “mouse” forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">These forces and their gradients are easily derived.</Sentence>
      
      
        <H2>4.5 Damping</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The energies we have just described are functions of position only.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Robust dynamic cloth simulation, however, is critically dependent on well-chosen damping forces that are a function of both position and velocity.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For example, the strong stretch force must be accompanied by a suitably strong damping force if we are to prevent anomalous in-plane oscillations from arising between connected particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">However, this strong damping force must confine itself solely to damping in-plane stretching/compressing motions: stretch damping should not arise due to motions that are not causing stretch or compression.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Terzopoulos et al.’s <CitSpan>[ 16 , 17 ]</CitSpan> treatment of cloth used a simple viscous damping function which dissipated kinetic energy, independent of the type of motion.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Carignan et al. <CitSpan>[ 4 ]</CitSpan> improved upon this somewhat, borrowing a formulation due to Platt and Barr <CitSpan>[ 11 ]</CitSpan>; however, their damping function—a linear function of velocity—does not match the quartic energy functions of their continuum formulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In this section we describe a general treatment for damping that is independent of the specific energy function being damped.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">It is tempting to formulate a damping function for an energy function E(x) by measuring the velocity of the energy, E  ̇ = d E(x).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">dt This is an easy trap to fall into, but it gives nonsensical results.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">At an equilibrium point of E, the gradient ∂E/∂x vanishes.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since E  ̇ = (∂E/∂x) T x, we find that E  ̇ is zero when E is at its minimum, regardless of the system’s velocity x = v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In general, E  ̇ is always too small near the system’s rest state.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Clearly, basing the damping force on E  ̇ is not what we want to do.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We believe that the damping function should be defined not in terms of the energy E, but in terms of the condition C(x) we have been using to define energies.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The force f arising from the energy acts only in the direction ∂C(x)/∂x, and so should the damping force.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, the damping force should depend on the component of the system’s velocity in the ∂C(x)/∂x direction; in other words, the damping strength should depend on (∂C(x)/∂x) T x = C(x).</Sentence>  <Sentence inAbstract="false" rhetoricalClass="Sentence">̇ Putting this together, we propose that the damping force d associated with a condition C have the form</Sentence>
        
          11
          d = −k d ∂C(x) ∂x C(x).  ̇
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">∂C(x) This neatly parallels the fact that f = −k s ∂x C(x).</Sentence>
        47
       <Sentence inAbstract="false" rhetoricalClass="Sentence"> </Sentence>SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        Given the condition functions C we have defined in this section for stretch, bend and shear forces, we can now add accompanying damping forces by applying equation <CitSpan>(11)</CitSpan>. <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">As before, d i is nonzero only for those particles that C depends on, and ∂d/∂x has the same sparsity pattern as ∂f/∂x.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Differentiating equation <CitSpan>(11)</CitSpan>, we obtain</Sentence>
        
          12
          ∂x ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂x  ̇ j T + ∂ ∂x C(x) i ∂x j C(x)  ̇ .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Note that ∂d/∂x is not a second derivative of some function as was the case in equation <CitSpan>(8)</CitSpan> so we cannot expect ∂d/∂x to be symmetrical.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In equation <CitSpan>(12)</CitSpan>, it is the term (∂C(x)/∂x i )(∂ C(x)/∂x  ̇ j ) T which breaks the symmetry.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Anticipating section 5.2, we find it expedient simply to leave this term out, thereby restoring symmetry.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This simplification is clearly not physically justifiable, but we have not observed any ill effects from this omission.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(Omitting all of equation <CitSpan>(12)</CitSpan>, however, causes serious problems.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Finally, equation <CitSpan>(6)</CitSpan> requires the derivative ∂d/∂v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Since C(x)  ̇ = (∂C(x)/∂x) T v, we have ∂ C(x)  ̇ ∂ ∂C(x) T ∂C(x) = v = .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">∂v ∂v ∂x ∂x Using this fact, we can write ∂v ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂v  ̇ j T = −k d ∂C(x) ∂x i ∂C(x) ∂x j T .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In this case, the result is symmetrical without dropping any terms.</Sentence>
      
      
        <H1>5 Constraints</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In this section, we describe how constraints are imposed on individual cloth particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The constraints we discuss in this section are either automatically determined by the user (such as geometric attachment constraints on a particle) or are contact constraints (generated by the system) between a solid object and a particle.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The techniques we describe in this section could be used for multi-particle constraints; however, constraints that share particle would need to be merged.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Thus, a set of four-particle constraints (such as vertex/triangle or edge/edge contacts in the cloth) might merge to form a single constraint on arbitrarily many particles, which would be expensive to maintain.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Because of this, we handle cloth/cloth contacts with strong springs (easily dealt with, given the simulator’s underlying implicit integration base) and “position alteration,” a technique described in section 6.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">At any given step of the simulation, a cloth particle is either completely unconstrained (though subject to forces), or the particle may be constrained in either one, two or three dimensions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given the differential nature of our formulation, it is the particle’s acceleration, or equivalently, the change in the particle’s velocity, that is constrained.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If the particle is constrained in all three dimensions, then we are explicitly setting the particle’s velocity (at the next step).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If the constraint is in two or one dimensions, we are constraining the particle’s velocity along either two or one mutually orthogonal axes.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Before describing our constraint method, we discuss several other possible enforcement mechanisms and explain why we chose not to use them.</Sentence>
      
      
        Reduced Coordinates
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">An obvious and quite exact method for constraining a particle is to reduce the number of coordinates describing the particle’s position and velocity.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A completely constrained particle would have no coordinates, while a particle with one dimension of constraint would have two coordinates.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This is possible—but it complicates the system immensely.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If we change the number of coordinates per particle, we alter the size of the derivative matrices in equation <CitSpan>(6)</CitSpan>, as well as the sparsity pattern (this happens when a particle changes from having no coordinates to some coordinates, or vice versa).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given the transient nature of contact constraints between cloth and solids, this is most unappealing.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The computation of the derivative matrices’ entries is also greatly complicated, because we must now introduce extra Jacobian matrices that relate a particle’s reduced coordinates to its motion in world-space.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Finally, correct constraint-release behavior between cloth and solid objects is difficult to achieve using a reduced coordinate formulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Considering all of this, we immediately rejected this method of constraints.</Sentence>
      
      
        Penalty Methods
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We could constrain particles through the use of strong energy functions—essentially, stiff springs that attempt to prevent illegal particle motions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since our entire formulation is geared to handle stiffness, the usual objections to enforcing constraints with springs—very stiff equations—do not carry as much weight.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We tried this for a time, and found it to be a not unreasonable constraint enforcement mechanism.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">However, penalty methods do not enforce constraints exactly, and they do add some additional stiffness to the system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since the mechanism we describe enforces constraints exactly, and adds no extra stiffness, we turned away from penalty methods except in the case of cloth/cloth interactions.</Sentence>
      
      
        Lagrange Multipliers
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We could introduce additional constraint forces—that is, Lagrange multipliers—into our system to satisfy the constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This involves augmenting the linear system of equation <CitSpan>(6)</CitSpan> with extra variables (the multipliers) and extra equations (the constraint conditions).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Unfortunately, this turns a positive definite system into an indefinite system, which means that iterative methods such as CG will need to square the system first, thereby doubling the running time and degrading the numerical conditionining of the linear system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, an iterative method will generally not enforce the constraints exactly without a large number of iterations.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(A direct method for solving the augmented system would, however, avoid this problem.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Again, the constraint method we describe steps past these difficulties, so we turned away from using Lagrange multipliers.</Sentence>
      
      
        <H2>5.1 Mass Modification</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The idea behind our constraint enforcement mechanism is described quite simply, although the actual implementation is somewhat more complicated, to maximize performance.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A dynamic simulation usually requires knowledge of the inverse mass of objects; for example, note the appearance of M −1 , and not M in equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In the case of a single particle, we write x  ̈ i = m 1 i f i to describe a particle’s acceleration.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When inverse mass is used, it becomes trivial to enforce constraints by altering the mass.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Suppose for example that we want to keep particle i’s velocity from changing.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If we take 1/m i to be zero, we give the particle an infinite mass, making it ignore all forces exerted on it.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Complete control over a particle’s acceleration is thus taken care of by storing a value of zero for the particle’s inverse mass.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">What if we wish to constrain the particle’s acceleration in only one or two dimensions?</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Although we normally think of a particle’s mass as a scalar, we need not always do so.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Suppose we write ẍ i = 1/m 0 i 1/m 0 i 0 0 f i .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Now ẍ i 0 0 0 must lie in the xy plane; no acceleration in the z direction is possible.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Note than an unconstrained particle can be considered to have the 3 × 3 inverse mass matrix 1 I, with I the identity matrix.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">m i Of course, we are not restricted to coordinate-aligned constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">More generally, given a unit vector p ∈ IR 3 , a particle is prevented from accelerating along p by using an inverse mass matrix 1 (I − m i pp T ); this follows from the fact that (I − pp T )p = 0.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Similarly, given two mutually orthogonal unit vectors p and q, we prevent a particle from accelerating in either the p or q direction by using the inverse mass matrix 1 (I − pp T − qq T ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">m i By allowing constrained particles to have these sorts of inverse masses, we can build constraints directly into equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We will create a modified version W of M −1 ; W will be a block-diagonal matrix, with off-diagonal blocks being zero, and diagonal blocks defined as follows: let ndof(i) indicate the number of degrees of freedom particle i has, and let particle i’s prohibited directions be p i (if ndof(i) = 2) or p i and q i (if ndof(i) = 1) with p i and q i mutually orthogonal unit vectors.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">W’s diagonal blocks are W ii = m 1 i S i where</Sentence>
        48
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          13
           S i =         I 0 (I (I − − p p i i p p i i T T ) − q i q i T ) if if if ndof(i) ndof(i) ndof(i) ndof(i) = = = = 1 2 3 0.
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We are not limited to constraining particles to have zero accelerations in certain directions; rather, we control exactly what the change in velocity is along the constrained directions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For every particle i, let z i be the change in velocity we wish to enforce in the particle’s constrained direction(s).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(This implies we can choose any value of z i for a completely constrained particle, since all directions are constrained; an unconstrained particle must have z i = 0 since it has no constrained directions.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Using W and z, we rewrite equation <CitSpan>(6)</CitSpan> to directly enforce constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">If we solve</Sentence>
        
          14
          I − hW ∂v ∂f − h 2 W ∂x ∂f v = hW f 0 + h ∂x ∂f v 0 + z
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">for v, we will obtain a v which is consistent with our constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Completely constrained particles will have v i = z i , while partially constrained particles will have a v i whose component in the constrained direction(s) is equal to z i .</Sentence>
      
      
        <H2>5.2 Implementation</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We initially implemented constraints using equation <CitSpan>(14)</CitSpan> and found that it worked exactly as advertised.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For very small test systems, we solved equation <CitSpan>(14)</CitSpan> using a direct method (Gaussian elimination) without any problems.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For larger systems, we planned to use the iterative, sparsity-exploiting CG method, which immediately presents us with a problem: equation <CitSpan>(14)</CitSpan> is not a symmetric linear system.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(For that matter, neither is equation <CitSpan>(6)</CitSpan> unless all particles have the same mass.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Background">) CG methods, however, require symmetric matrices.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">6 We could apply a CG method to the unsymmetric matrix of equation <CitSpan>(14)</CitSpan> by use of the “normal equations”; but this involves multiplying the matrix of equation <CitSpan>(14)</CitSpan> with its transpose which doubles the cost of each iteration while squaring the condition number of the system <CitSpan>[ 14 ]</CitSpan>—a less than desirable plan.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We decided that using a CG method to solve the unsymmetric problem was not acceptable.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Note that without constraints, applying a CG method to equation <CitSpan>(6)</CitSpan> is not difficult, because we can transform this equation to 6 In fact, they work best on positive definite symmetric matrices.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The matrices we ultimately hand to our CG method are positive definite.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">a symmetric (and positive definite) system by left-multiplying the entire equation by M: the system</Sentence>
        
          15
          M − h ∂v ∂f − h 2 ∂x ∂f v = h f 0 + h ∂x ∂f v 0
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">is symmetric and has the same solution v as equation <CitSpan>(6)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Unfortunately, we cannot apply the same transformation to equation <CitSpan>(14)</CitSpan>, because W is singular—the filtering blocks in equation <CitSpan>(13)</CitSpan> are rank deficient—so we cannot multiply through by W −1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The solution to the problem of asymmetry is to modify the CG method so that it can operate on equation <CitSpan>(15)</CitSpan>, while procedurally applying the constraints inherent in the matrix W at each iteration.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The modified method will need to know about the particles’ constraints and the vector z.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Let us define the symmetric positive definite matrix A by</Sentence>
        
          16
          A = M − h ∂f − h 2 ∂f ∂v ∂x
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">and the vector b and residual vector r as ∂f b = h f 0 + h ∂x v 0 and r = A v − b.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Given A, b, constraints on the particles, and z, our modified CG method will try to find v that satisfies two conditions: • For each particle i, the component of r i in the particle’s unconstrained direction(s) will be made equal to zero (assuming the method is run for sufficiently many iterations).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">• For each particle i, the component of v i in the particle’s constrained direction(s) will be exactly z i (no matter how many iterations are taken).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Note that these two conditions imply that unconstrained particles have r i close to zero, while completely constrained particles have v i = z i .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Thus in the case when no particles are constrained, our modified CG method should produce the same result as the regular CG method.</Sentence>
      
      
        <H2>5.3 The Modified Conjugate Gradient Method</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The CG method (technically, the preconditioned CG method) takes a symmetric positive semi-definite matrix A, a symmetric positive definite preconditioning matrix P of the same dimension as A, a vector b and iteratively solves A v = b.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The iteration stops when b − A v is less than b where is a user-defined tolerance value.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The preconditioning matrix P, which must be easily invertible, speeds convergence to the extent that P −1 approximates A. We wholeheartedly refer the reader to Shewchuk <CitSpan>[ 14 ]</CitSpan> for information on the CG method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We derive our modified conjugate gradient method by observing that the effect of the matrix W in equation <CitSpan>(14)</CitSpan> is to filter out velocity changes in the constrained directions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our idea then is to define an invariant— for all i, the component of v i in the constrained direction(s) of particle i is equal to z i —and then establish and maintain the invariant at each iteration, by defining a filtering procedure filter.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The role of filter is to take a vector a and perform the same filtering operation (see equation <CitSpan>(13)</CitSpan>) as multiplying by W, but leaving out the scaling by 1/m i : procedure filter(a) for i = 1 to n a i = S i a i return a</Sentence>
        49
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        Using filter, we define the modified CG method modified-pcg as follows:
        1 procedure modified-pcg 2 v = z 3 δ 0 = filter(b) T P filter(b) 4 r = filter(b − A v) 5 c = filter(P −1 r) 6 δ new = r T c 7 while δ new &gt; 2 δ 0 8 q = filter(Ac) 9 α = δ new /(c T q) 10 v = v + αc 11 r = r − αq 12 s = P −1 r 13 δ old = δ new 14 δ new = r T s 15 c = filter(s + δ new c) δ old Line 2 of the procedure establishes our invariant. <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Lines 5 and 15 maintain the invariant by filtering c before adding it to v.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The unmodified conjugate gradient method establishes a stopping criterion based on b T Pb.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since our constrained formulation ignores certain components of b, our stopping criterion should as well, so we add filtering to line 3.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The vector r measures the solution error b − A v, and should not include error due to the constraints; hence we add filtering at lines 4 and 8.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(Note that removing the calls to filter and changing line 2 to v = 0 yields the standard preconditioned conjugate gradient method.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) We use a simple preconditioner P by making P be a diagonal matrix with P ii = 1/A ii so products involving P −1 are trivially computed.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">More elaborate preconditioners could be used, though we doubt there is a large speedup to be gained.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Matrix-vector products with A are of course implemented in sparse matrix-vector fashion, using the data structures defined in section 2.3.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Given modified-pcg, obvious questions are “does it work?</Sentence>
<Sentence inAbstract="false" rhetoricalClass="Sentence">” followed by “how does it compare with the unmodified CG method?</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">” Proofs about CG methods are difficult in general; in practice, our method always converges, which answers the first question.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Prior to implementing modified-pcg, we used a penalty method and applied the standard CG method to equation <CitSpan>(15)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When we began using procedure modified-pcg, we did not notice any substantial change in the number of iterations required by the method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Empirically, we conclude that the two methods have similar convergence behavior.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Result in section 8 indicate that the running time is close to O(n 1.5 ), which is what unmodified CG would be expected to deliver on this sort of problem <CitSpan>[ 14 ]</CitSpan>.</Sentence>
      
      
        <H2>5.4 Determining the Constraint Forces</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For contact constraints (between cloth and solid objects) we need to know what the actual force of constraint is, in order to determine when to terminate a constraint.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Additionally, we need to know the constraint force actually exerted in order to model frictional forces properly.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Fortunately, it is easy to add one more step to modified-pcg to determine the constraint force.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When modified-pcg terminates, the residual error e = A v − b has the property that e i need not be close to zero if particle i is constrained.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In fact, e i is exactly the extra constraint force that must have been supplied to enforce the constraint.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Thus, we can compute constraint forces at the end of modified-pcg by performing one last matrixvector product to compute A v − b.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(The vector r in modified-pcg is equal to filter(A v − b), so the extra matrix-vector product to compute e really is necessary.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) The particles’ accelerations are inherently dependent on one another through the matrix A of equation <CitSpan>(16)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This means that the correct approach to determing constraint release is combinatoric, as in Baraff <CitSpan>[ 2 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">We reject this approach as impractical given the dimension of A. Instead, we allow contacts to release when the constraint force between a particle and a solid switches from a repulsive force to an attractive one.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">In practice, this has proven to work well.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Friction presents a similar problem.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When cloth contacts a solid, we lock the particle onto the surface, if the relative tangential velocity is low.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We monitor the constraint force, and if the tangential force exceeds some fraction of the normal force, we allow the particle to slide on the surface.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For high sliding velocities, we apply a dissipative tangential force, opposite the relative sliding direction, proportional to the normal force.</Sentence>
      
      
        <H1>6 Collisions</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Much has been written about collision detection for cloth; we have nothing substantial to add to the subject of collision detection per se.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Cloth/cloth collisions are detected by checking pairs ( p, t) and (e 1 , e 2 ) for intersections, where p and t are a cloth particle and a cloth triangle respectively, and e 1 and e 2 are edges of cloth triangles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given a previous known legal state of the cloth, we postulate a linear motion for the cloth particles to the current (possibly illegal) state and check for either particle/triangle or edge/edge crossings.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To avoid O(n 2 ) comparisons, we use a coherency-based boundingbox approach <CitSpan>[ 1 ]</CitSpan> to cull out the majority of pairs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">When collisions between a cloth vertex and triangle, or two cloth edges are detected, we insert a strong damped spring force to push the cloth apart.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A dissipative force tangent to the contact is also applied, countering any sliding motion.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The force is not, strictly speaking, a frictional force: rather it is proportional to the slip velocity, so it is in actuality a damping force, although it reasonably emulates dynamic friction.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Applying static friction forces to cloth contacts is far more difficult, and is a problem we have not solved yet.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The forces, and their derivatives with respect to position and velocity, are of course included in equation <CitSpan>(15)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our system detects collisions between cloth particles and solid objects by testing each individual cloth particle against the faces of each solid object.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A solid object’s faces are grouped in a hierarchical bounding box tree, with the leaves of the tree being individual faces of the solid.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The tree is created by a simple recursive splitting along coordinate axes.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The maintenance of contacts and the application of friction forces was described in the previous section.</Sentence>
      
      
        <H2>6.1 Constraint Initiation</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Both cloth/cloth and cloth/solid collisions give rise to the same problem whenever two contacts form.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For both types of collisions, our detection algorithm reports an intersection, and then takes action to remedy the situation: either by enforcing a constraint (cloth/solid collisions) or by adding a penalty force (cloth/cloth) collisions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">However, since our simulator proceeds in discrete steps, collisions resulting in a reasonably substantial interpenetration depth can occur between one step and the next.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Clearly, this situation needs to be remedied.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For cloth/cloth collisions, this would not appear to be a problem: the spring forces that are added work to counter the colliding velocities and then push the cloth apart.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For cloth/solid collisions, however, the situation is more complicated.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If we simply enforce a constraint which causes the colliding cloth particle to have a velocity consistent with the solid object’s velocity, and continue to enforce that constraint, the cloth particle will continue to remain embedded somewhere below the solid object’s surface.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This is unacceptable.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">One solution is to use Baumgarte stabilization <CitSpan>[ 18 ]</CitSpan>, which schedules the particle’s acceleration so that the position and velocity error of the particle with respect to the surface decay asymptotically to zero.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We experimented with this technique, but found it lacking.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In particular, a fast rise to the surface was prone to noise and “jumpiness”; this could be eliminated, but at the cost of decreasing the step size.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">A slower rise to the surface caused visual artifacts.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We tried a simpler solution: when intersections occurred, rather than wait for a scheduled constraint or a penalty force to eliminate the intersection, we simply altered the positions of the cloth particles, effecting an instantaneous (and discontinuous) change in position.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">While this would be problematic when using a multi-step differential equation solver which expects continuity (such as a RungeKutta method), it should not interfere with a one-step solver such as the backward Euler method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Unfortunately, simply changing particle positions produced disastrous results.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The stretch energy term in a cloth system is extremely strong, and altering particle positions arbitrarily introduced excessively large deformation energies in an altered particle’s neighborhood.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This resulted in visibly “jumpy” behavior of the cloth in localized regions.</Sentence>
        50
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
      
      
        <H2>6.2 Position Alteration</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Despite its initial failure, the ability to make arbitrary small changes in a particle’s position continued to attract our attention.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The entire process of implicit integration can be considered to be a filtering process <CitSpan>[ 7 ]</CitSpan>, and we postulated that a mechanism for filtering energy changes caused by displacing particles might make position alteration a viable technique.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We considered that perhaps some sort of extra implicit step could be used as a filter, but forming and solving an additional linear system at each step seemed too expensive.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Happily, we can make use of the filtering effect of implicit integration without any extra work.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Consider a particle that has collided with a solid object.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The particle’s change in velocity at each step is under our control, using the constraint techniques described in section 5.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Meanwhile, the particle’s position at the next step follows from equation <CitSpan>(4)</CitSpan>: x i = h(v 0i + v i ) (recall that v 0i is the particle’s current velocity).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The reason that changing positions after a step has been taken doesn’t work is because the particle’s neighbors receive no advance notification of the change in position: they are confronted with the alteration at the beginning of the next step.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">This presents an obvious solution: we simply modify the top row of equation <CitSpan>(4)</CitSpan> to</Sentence>
        
          17
          x i = h(v 0i + v i ) + y i
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">where y i is an arbitrary correction term of our choice, introduced solely to move a particle to a desired location during the backward Euler step.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Having modified the top row of equation <CitSpan>(4)</CitSpan>, we must follow this change through: using equation <CitSpan>(17)</CitSpan> and repeating the derivation of section 3 and the symmetric transform from section 5 yields the modified symmetric system</Sentence>
        
          18
          M − h ∂v ∂f − h 2 ∂x ∂f v = h f 0 + h ∂x ∂f v 0 + ∂x ∂f y .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This modification gives us complete control over both the position and velocity of a constrained particle in just one step, without any extra computational cost.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We use this technique to bring particles quickly and stably to the surface of solid objects without creating visual artifacts or limiting the allowable step size.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We can also add correction terms to particles involved in cloth/cloth collisions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Without a constraint on those particles’ velocities there is no guarantee that they will go exactly where we want in one step, but the ability to induce sizeable jumps in position without excessively stiff spring forces adds greatly to the stability of the simulation.</Sentence>
      
      
        <H1>7 Adaptive Time Stepping</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">The methods introduced in all of the previous sections usually allow us to take sizeable steps forward, without loss of stability.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Even so, there are still times when the step size must be reduced to avoid divergence.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">There are a large number of methods for altering the size of a time step, for both explicit and implicit integrators, but these methods tend to concentrate on the accuracy of the simulation, and not the stability.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge_Goal">Our goal is animation, not engineering; thus visually pleasing results, meaning a numerically stable solution, rather than overall accuracy, is the deciding voice.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The trick is to recognize instability before you see it on your screen—by then it’s too late.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Stiffness, and thus any potential instability, arises almost completely from the strong stretch forces in the cloth.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">After each implicit step, we treat the resulting x as a proposed change in the cloth’s state, and examine the stretch terms (section 4.2) for each triangle in the newly proposed state.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If any triangle undergoes a drastic change in its stretch (in either the u or v direction) we discard the proposed state, reduce the step size, and try again.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Subtlety is not required: we find that an unstable step invariably results in stretch changes that are quite large, and are thus easily detected.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our simulation is run with a parameter that indicates the maximum allowable step size: this parameter is set by the user, and is always less than or equal to one frame.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">(Most of our simulations involving human motions use a step size of 0.02 seconds.</Sentence>
<Sentence inAbstract="false" rhetoricalClass="DRI_Approach">) Whenever the simulator reduces the step size, after two successes with the reduced step size the simulator tries to increase the step size.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If the simulator fails at the larger step size, it reduces the size again, and waits for a longer period of time before retrying to increase the step size.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">At its limit, the simulator will try increasing the step size every 40 steps; thus, if the user chooses too large a step, the simulator settles down to wasting only one out of every 40 steps in attempting too large a step.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">This method, though simple, has served us well.</Sentence>
      
      
        <H1>8 Results</H1>
         <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Table 1 gives a performance summary of assorted animations, shown in figures 1–6.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Unaccounted overhead of the simulation (typically about 5%) includes tasks such as geometry transformations, memory allocation, etc.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The clothes in figures 3–6 were modeled as discrete planar panels, and then topologically seamed.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The simulator was used to relax the clothing from an initial deformed state, that got the clothes around the characters, to a well-fitting state on the characters.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The b u and b v parameters (see equation <CitSpan>(10)</CitSpan>) were then made smaller in certain regions to produce cuffs and waistbands, or strategically increased to induce wrinkling behavior in other regions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We also ran the simulation in figure 1 with a range of stiffnesses for the bend term.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Using the stiffness parameters in figure 1 as a reference, we ran the simulation with those bend stiffnesses multiplied by 0.1, 1.0, 10, 100 and 1,000 (for a total range of 10,000 in the stiffness).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The variance in the running times was under 5%.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">We doubt that simulators based on explicit integration methods could make a similar claim.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Finally, we tried to estimate our simulator’s performance as a function of n, the number of cloth particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We ran the simulation in figure 1 with cloth resolutions of 500, 899, 2,602 (shown in figure 1 ) and 7,359 particles.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The running times were, respectively, 0.23 seconds/frame, 0.46 seconds/frame, 2.23 seconds/frame, and 10.3 seconds/frame.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">This is slightly better than O(n 1.5 ) performance, which is in line with the convergence rates of the conjugate gradient method <CitSpan>[ 14 ]</CitSpan> for systems such as equation <CitSpan>(18)</CitSpan>.</Sentence>
        51
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
            
              
                
                  
                   figure
                   no. vertices/no. triangles
                   time/frame
                
              
              
                
                  
                  
                   cloth solid
                   (CPU sec.)
                
                
                   1
                  
                   2,602/4,9442 322/640
                   2.23
                
                
                   2
                  
                   2,602/4,9442 322/640
                   3.06
                
                
                   3
                  
                   6,450/12,654 9,941/18,110
                   7.32
                
                
                   4
                   (shirt)
                   6,450/12,654 9,941/18,110
                   14.5
                
                
                  
                   (pants)
                   8,757/17,352 9,941/18,110
                   38.5
                
                
                   5
                   (skirt)
                   2,153/4,020 7,630/14,008
                   3.68
                
                
                  
                   (blouse)
                   5,108/10,016 7,630/14,008
                   16.7
                
                
                   6
                   (skirt)
                   4,530/8,844 7,630/14,008
                   10.2
                
                
                  
                   (blouse)
                   5,188/10,194 7,630/14,008
                   16.6
                
              
            
          
          figure no. vertices/no. triangles time/frame cloth solid (CPU sec.) 1 2,602/4,9442 322/640 2.23 2 2,602/4,9442 322/640 3.06 3 6,450/12,654 9,941/18,110 7.32 4 (shirt) 6,450/12,654 9,941/18,110 14.5 (pants) 8,757/17,352 9,941/18,110 38.5 5 (skirt) 2,153/4,020 7,630/14,008 3.68 (blouse) 5,108/10,016 7,630/14,008 16.7 6 (skirt) 4,530/8,844 7,630/14,008 10.2 (blouse) 5,188/10,194 7,630/14,008 16.6
          Table 1: System performance for simulations in figures 1–6. Minimum and maximum time steps are in milliseconds of simulation time. Time/frame indicates actual CPU time for each frame, averaged over the simulation. Percentages of total running time are given for four tasks: EVAL— forming the linear system of equation <CitSpan>(18)</CitSpan>; CG—solving equation <CitSpan>(18)</CitSpan>; C/C—cloth/cloth collision detection; and C/S—cloth/solid collision detection.
        
      
      
        <H1>9 Acknowledgments</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">This research was supported in part by an ONR Young Investigator award, an NSF CAREER award, and grants from the Intel Corporation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">We thank Alias|Wavefront for supplying the models and motion capture data used in figures 5 and 6.</Sentence>
      
      
        <H1>References</H1>
        
          [1] D. Baraff. Dynamic Simulation of Non-penetrating Rigid Bodies. PhD thesis, Cornell University, May 1992.
          [2] D. Baraff. Fast contact force computation for nonpenetrating rigid bodies. Computer Graphics (Proc. SIGGRAPH), 28:23– 34, 1994.
          [3] D.E. Breen, D.H. House, and M.J. Wozny. Predicting the drape of woven cloth using interacting particles. Computer Graphics (Proc. SIGGRAPH), pages 365–372, 1994.
          [4] M. Carignan, Y. Yang, N. Magenenat-Thalmann, and D. Thalmann. Dressing animated synthetic actors with complex deformable clothes. Computer Graphics (Proc. SIGGRAPH), pages 99–104, 1992.
          [5] B. Eberhardt, A. Weber, and W. Strasser. A fast, flexible, particle-system model for cloth draping. IEEE Computer Graphics and Applications, 16:52–59, 1996.
          [6] G. Golub and C. Van Loan. Matrix Computations. John Hopkins University Press, 1983.
          [7] M. Kass. An Introduction To Physically Based Modeling, chapter Introduction to Continuum Dynamics for Computer Graphics. SIGGRAPH Course Notes, ACM SIGGRAPH, 1995.
          [8] M. Kass and G. Miller. Rapid, stable fluid dynamics for computer graphics. Computer Graphics (Proc. SIGGRAPH), pages 49–58, 1990.
          [9] H.N. Ng and R.L. Grimsdale. Computer graphics techniques for modeling cloth. IEEE Computer Graphics and Applications, 16:28–41, 1996.
          [10] H. Okabe, H. Imaoka, T. Tomiha, and H. Niwaya. Three dimensional apparel cad system. Computer Graphics (Proc. SIGGRAPH), pages 105–110, 1992.  step size total frames/ task breakdown percentage min/max (ms) total steps EVAL CG C/C C/S 16.5/33 75/80 25.7 50.4 18.3 1.4 16.5/33 75/80 17.9 63.6 15.3 0.2 16.5/33 50/52 18.9 37.9 30.9 2.6 2.5/20 430/748 16.7 29.9 46.1 2.2 0.625/20 430/1214 16.4 35.7 42.5 1.7 5/20 393/715 18.1 30.0 44.5 1.5 5/20 393/701 11.2 26.0 57.7 1.3 10/20 393/670 20.1 36.8 29.7 2.6 1.25/20 393/753 13.2 30.9 50.2 1.4
          [11] J.C. Platt and A.H. Barr. Constraint methods for flexible models. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 279–288. ACM, July 1988.
          [12] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling. Numerical Recipes. Cambridge University Press, 1986.
          [13] X. Provot. Deformation constraints in a mass-spring model to describe rigid cloth behavior. In Graphics Interface, pages 147–155, 1995.
          [14] J. Shewchuk. An introduction to the conjugate gradient method without the agonizing pain. Technical Report CMUCS-TR-94-125, Carnegie Mellon University, 1994. (See also http://www.cs.cmu.edu/ ~quake-papers/ painless-conjugate-gradient.ps.).
          [15] D. Terzopoulos and K. Fleischer. Deformable models. Visual Computer, 4:306–331, 1988.
          [16] D. Terzopoulos and K. Fleischer. Modeling inelastic deformation: Viscoelasticity, plasticity, fracture. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 269–278. ACM, August 1988.
          [17] D. Terzopoulos, J.C. Platt, and A.H. Barr. Elastically deformable models. Computer Graphics (Proc. SIGGRAPH), 21:205–214, 1987.
          [18] D. Terzopoulos and H. Qin. Dynamics nurbs with geometric constraints for interactive sculpting. ACM Transactions on Graphics, 13:103–136, 1994.
          [19] X. Tu. Artificial Animals for Computer Animation: Biomechanics, Locomotion, Perception and Behavior. PhD thesis, University of Toronto, May 1996.
          [20] P. Volino, M. Courchesne, and N. Magnenat Thalmann. Versatile and efficient techniques for simulating cloth and other deformable objects. Computer Graphics (Proc. SIGGRAPH), pages 137–144, 1995.
          [21] P. Volino, N. Magnenat Thalmann, S. Jianhua, and D. Thalmann. An evolving system for simulating clothes on virtual actors. IEEE Computer Graphics and Applications, 16:42–51, 1996.
        
        52
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
        
         <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 1 (top row): Cloth draping on cylinder; frames 8, 13 and 35.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 2 (second row): Sheet with two fixed particles; frames 10, 29 and 67.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 3 (third row): Shirt on twisting figure; frames 1, 24 and 46.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 4 (bottom row): Walking man; frames 30, 45 and 58.</Sentence>
        53
        SIGGRAPH 98, Orlando, July 19–24
        C OMPUTER G RAPHICS Proceedings, Annual Conference Series, 1998
        
          
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 5 (top row): Dancer with short skirt; frames 110, 136 and 155.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 6 (middle row): frames 185, 215 and 236.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 7 (bottom row): Closeups from figures 4 and 6.</Sentence>
        <Sentence inAbstract="false" rhetoricalClass="Sentence">Dancer with long skirt;</Sentence>
        54
      
    
  

</Document>
