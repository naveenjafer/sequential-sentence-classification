<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A17_M09_Motion_Graphs_SUMMARY_v1.xml">


  
    314cdb4ffe999411ffe446ddb3cfdf25d59e148dce001ad40723a3406bd5b5cb
    3y2s
    http://dx.doi.org/10.2172/7134495
  
  
    
      
        <Title>Motion Graphs</Title>
      
      To appear in Proceedings of SIGGRAPH ’02
      
        
          Lucas Kovar Michael Gleicher ∗ Frédéric Pighin † University of Wisconsin-Madison University of Wisconsin-Madison University of Southern California Institute for Creative Technologies
          ∗
        
      
      ∗ e-mail: {kovar,gleicher}@cs.wisc.edu † e-mail: pighin@ict.usc.edu
      
        
      
      <Abstract>
<Sentence inAbstract="true">In this paper we present a novel method for creating realistic, controllable motion.</Sentence> <Sentence inAbstract="true">Given a corpus of motion capture data, we automatically construct a directed graph called a motion graph that encapsulates connections among the database.</Sentence> <Sentence inAbstract="true">The motion graph consists both of pieces of original motion and automatically generated transitions.</Sentence> <Sentence inAbstract="true">Motion can be generated simply by building walks on the graph.</Sentence> <Sentence inAbstract="true">We present a general framework for extracting particular graph walks that meet a user’s specifications.</Sentence> <Sentence inAbstract="true">We then show how this framework can be applied to the specific problem of generating different styles of locomotion along arbitrary paths.</Sentence>
</Abstract>
	CR Categories:  I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism Keywords: motion synthesis, motion capture, animation with constraints
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence inAbstract="false" summaryRelevanceScore="3.00">Realistic human motion is an important part of media like video games and movies.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">More lifelike characters make for more immersive environments and more believable special effects.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">At the same time, realistic animation of human motion is a challenging task, as people have proven to be adept at discerning the subtleties of human movement and identifying inaccuracies.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">One common solution to this problem is motion capture.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">However, while motion capture is a reliable way of acquiring realistic human motion, by itself it is a technique for reproducing motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Motion capture data has proven to be difficult to modify, and editing techniques are reliable only for small changes to a motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">This limits the utility of motion capture  if the data on hand isn’t sufficiently similar to what is desired, then often there is little that can be done other than acquire more data, a time-consuming and expensive process.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">This in particular is a problem for applications that require motion to be synthesized dynamically, such as interactive environments.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">Our goal is to retain the realism of motion capture while also giving a user the ability to control and direct a character.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, we would like to be able to ask a character to walk around a room without worrying about having a piece of motion data that contains the correct number of steps and travels in the right directions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">We also need to be able to direct characters who can perform multiple actions, rather than those who are only capable of walking around.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">This paper presents a method for synthesizing streams of motions based on a corpus of captured movement while preserving the quality of the original data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">Given a set of motion capture data, we compile a structure called a motion graph that encodes how the captured clips may be re-assembled in different ways.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">The motion graph is a directed graph wherein edges contain either pieces of original motion data or automatically generated transitions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">The nodes then serve as choice points where these small bits of motion join seamlessly.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">Because our methods automatically detect and create transitions between motions, users needn’t capture motions specifically designed to connect to one another.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">If desired, the user can tune the high-level structure of the motion graph to produce desired degrees of connectivity among different parts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">Motion graphs transform the motion synthesis problem into one of selecting sequences of nodes, or graph walks.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">By drawing upon algorithms from graph theory and AI planning, we can extract graph walks that satisfy certain properties, thereby giving us control over the synthesized motions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">To demonstrate the potential of our approach, we introduce a simple example.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We were donated 78.5 seconds of motion capture, or about 2400 frames of animation, of a performer randomly walking around with both sharp and smooth turns.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Since the motion was donated, we did not carefully plan out each movement, as the literature suggests is critical to successful application of motion capture data <CitSpan>[Washburn 2001]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">From this data we constructed a motion graph and used an algorithm described later in this paper to extract motions that travelled along paths sketched on the ground.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Characteristic movements of the original data like sharp turns were automatically used when appropriate, as seen in Figure 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">It is possible to place additional constraints on the desired motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, we noticed that part of the motion had the character sneaking around.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">By labelling these frames as special, we were able to specify that at certain points along the path the character must only use sneaking movements, and at other parts of the motion it must use normal walking motions, as is also shown in Figure 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The remainder of this paper is organized as follows.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In Section 2 we describe related work.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In Section 3 we describe how a motion graph is constructed from a database of motion capture.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In Section 4 we set forth a general framework for extracting motion from the motion graph that meets user specifications.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Section 5 discusses the specific problem of generating movements along a path and how it is handled in our framework.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We conclude in Section 6 with a discussion of the scalability of our approach to large data sets and potential future work.</Sentence>
      1
      To appear in Proceedings of SIGGRAPH ’02
      
        
        Figure 1: The top images show original motion capture data; two are walking motions and one is a sneaking motion. The black curves show the paths travelled by the character. The bottom images show new motion generated by a motion graph built out of these examples plus their mirror images. Images 1 and 2 show the result of having the motion graph fit walking motion to the smooth yellow paths. The black curve is the actual position of the center of mass on each frame. Image 3 shows motion formed by having the character switch from walking to sneaking halfway down the path.
      
      
        <H1>2 Related Work</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="3.00">Much previous work with motion capture has revolved around editing individual clips of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Motion warping <CitSpan>[Witkin and Popović 1995]</CitSpan> can be used to smoothly add small changes to a motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Retargeting <CitSpan>[Gleicher 1998; Lee and Shin 1999]</CitSpan> maps the motion of a performer to a character of different proportions while retaining important constraints like footplants.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Various signal processing operations <CitSpan>[Bruderlin and Williams 1995]</CitSpan> can be applied to motion data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">Our work is different from these efforts in that it involves creating continuous streams of motion, rather than modifying specific clips.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">One strategy for motion synthesis is to perform multi-target blends among a set of examples, yielding a continuous space of parameterized motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Wiley and Hahn [1997]</CitSpan> used linear interpolation to create parameterizations of walking at various inclinations and reaching to various locations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">
<CitSpan>Rose et al. [1998]</CitSpan> used radial basis functions to blend among clips representing the same motion performed in different styles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">These works have a focus complementary to ours: while they are mainly concerned with generating parameterizations of individual clips, we are concerned with constructing controllable sequences of clips.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Another popular approach to motion synthesis is to construct statistical models.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Pullen and Bregler [2000]</CitSpan> used kernel-based probability distributions to synthesize new motion based on the statistical properties of example motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Coherency was added to the model by explicitly accounting for correlations between parameters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Bowden [2000], Galata et al. [2001]</CitSpan>, and <CitSpan>Brand and Hertzmann [2000]</CitSpan> all processed motion capture data by constructing abstract “states” which each represent entire sets of poses.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Transition probabilities between states were used to drive motion synthesis.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Since these statistical models synthesize motion based on abstractions of data rather than actual data, they risk losing important detail.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">In our work we have tighter guarantees on the quality of generated motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Moreover, these systems did not focus on the satisfaction of high-level constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">We generate motion by piecing together example motions from a database.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Numerous other researchers have pursued similar strategies.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Perlin [1995] and Perlin and Goldberg [1996]</CitSpan> used a rulebased system and simple blends to attach procedurally generated motion into coherent streams.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Faloutsos et al. [2001]</CitSpan> used support vector machines to create motion sequences as compositions of actions generated from a set of physically based controllers.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Since our system involves motion capture data, rather than procedural or physically based motion, we require different approaches to identifying and generating transitions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">Also, these systems were mainly concerned with appropriately generating individual transitions, whereas we address the problem of generating entire motions (with many transitions) that meet user-specified criteria.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Lamouret and van de Panne [1996]</CitSpan> developed a system that used a database to extract motion meeting high-level constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">However, their system was applied to a simple agent with five degrees of freedom, whereas we generate motion for a far more sophisticated character.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Molina-Tanco and Hilton [2000]</CitSpan> used a state-based statistical model similar to those mentioned in the previous paragraph to rearrange segments of original motion data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">These segments were attached using linear interpolation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The user could create motion by selecting keyframe poses, which were connected with a highprobability sequence of states.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Our work considers more general and sophisticated sets of constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Work similar to ours has been done in the gaming industry to meet the requirements of online motion generation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Many companies use move trees <CitSpan>[Mizuguchi et al. 2001]</CitSpan>, which (like motion graphs) are graph structures representing connections in a database of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">However, move trees are created manually — short motion clips are collected in carefully scripted capture sessions and blends are created by hand using interactive tools.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Motion graphs are constructed automatically.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Also, move trees are typically geared for rudimentary motion planning (“I want to turn left, so I should follow this transition”), as opposed to more complicated objectives.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">The generation of transitions is an important part of our approach.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Early work in this area was done by <CitSpan>Perlin [1995]</CitSpan>, who presented a simple method for smoothly interpolating between two clips to create a blend.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Lee [2000]</CitSpan> defined orientation filters that allowed these blending operations to be performed on rotational data in a more principled fashion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Rose et al. [1996]</CitSpan> presented a more complex method for creating transitions that preserved kinematic constraints and basic dynamic properties.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">Our main application of motion graphs is to control a character’s locomotion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This problem is important enough to have received a great deal of prior attention.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Because a character’s path isn’t generally known in advance, synthesis is required.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Procedural and physically based synthesis methods have been developed for a few activities such as walking <CitSpan>[Multon et al. 1999; Sun and Metaxas 2001]</CitSpan> and running <CitSpan>[Hodgins et al. 1995; Bruderlin and Calvert 1996]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">While techniques such as these can generate flexible motion paths, the current range of movement styles is limited.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Also, these methods do not produce the quality of motion attainable by hand animation or motion capture.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">
<CitSpan>While Gleicher [2001]</CitSpan> presented a method for editing the path traversed in a clip of motion capture, it did not address the need for continuous streams of motion, nor could it choose which clip is correct to fit a path (e.g. that a turning motion is better when we have a curved path).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Our basic approach — detecting transitions, constructing a graph, and using graph search techniques to find sequences satisfying user demands — has been applied previously to other problems.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">
<CitSpan>Schödl et al. [2000]</CitSpan> developed a similar method for synthesizing seamless streams of video from example footage and driving these streams according to high-level user input.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Since writing this paper, we have learned of similar work done concurrently by a number of research groups.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">
<CitSpan>Arikan and Forsythe [2002]</CitSpan> constructed from a motion database a hierarchical graph similar to ours and used a randomized search algorithm to extract motion that meets user constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">
<CitSpan>Lee et al. [2002]</CitSpan> also constructed a graph and generated motion via three user interfaces: a list of choices, a sketch-based interface similar to what we use for path fitting (Section 5), and a live video feed.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">
<CitSpan>Pullen and Bregler [2002]</CitSpan> keyframed a subset of a character’s degrees of freedom and matched small segments of this keyframed animation with the lower frequency bands of motion data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This resulted in sequences of short clips forming complete motions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Li et al [2002] generated a two-level statistical model of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">At the lower level were linear dynamic systems representing characteristic movements called “textons”, and the higher level contained transition probabilities among textons.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This model was used both to generate new motion based on user keyframes and to edit existing motion.</Sentence>
        2
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H1>3 Motion Graph Construction</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">In this section, we define the motion graph structure and the procedure for constructing it from a database of clips.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">A clip of motion is defined as a regular sampling of the character’s parameters, which consist of the position of the root joint and quaternions representing the orientations of each joint.</Sentence> We
        
          Figure 2: Consider a motion graph built from two initial clips. (top) We can trivially
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">insert a node to divide an initial clip into two smaller clips.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">(bottom) We can also insert a transition joining either two different initial clips or different parts of the same initial clip.</Sentence>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">also allow clips (or, more generally, sets of frames) to be annotated with other information, such as descriptive labels (“walking,” “karate”) and constraint information (left heel must be planted on these frames).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">A motion graph is a directed graph where all edges correspond to clips of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Nodes serve as choice points connecting these clips, i.e., each outgoing edge is potentially the successor to any incoming edge.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">A trivial motion graph can be created by placing all the initial clips from the database as arcs in the graph.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This creates a disconnected graph with 2n nodes, one at the beginning and end of each clip.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Similarly, an initial clip can be broken into two clips by inserting a node, since the later part of the motion is a valid successor to the earlier part (see Figure 2 ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">A more interesting graph requires greater connectivity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For a node to have multiple outgoing edges, there must be multiple clips that can follow the clip(s) leading into the node.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Since it is unlikely that two pieces of original data are sufficiently similar, we need to create clips expressly for this purpose.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Transitions are clips designed such that they can seamlessly connect two segments of original data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">By introducing nodes within the initial clips and inserting transition clips between otherwise disconnected nodes, we can create a wellconnected structure with a wide range of possible graph walks (see Figure 2 ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Unfortunately, creating transitions is a hard animation problem.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Imagine, for example, creating a transition between a run and a backflip.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In real life this would require several seconds for an athlete to perform, and the transition motion looks little like the motions it connects.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Hence the problem of automatically creating such a transition is arguably as difficult as that of creating realistic motion in the first place.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">On the other hand, if two motions are “close” to each other then simple blending techniques can reliably generate a transition.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">In light of this, our strategy is to identify portions of the initial clips that are sufficiently similar that straightforward blending is almost certain to produce valid transitions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The remainder of this section is divided into three parts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">First we describe our algorithm for detecting a set of candidate transition points.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In the following two sections we discuss how we select among these candidate transitions and how blends are created at the chosen transition points.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Finally, we explain how to prune the graph to eliminate problematic edges.</Sentence>
        3
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>3.1 Detecting Candidate Transitions</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.33">As in our system, motion capture data is typically represented as vectors of parameters specifying the root position and joint rotations of a skeleton on each frame.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">One might attempt to locate transition points by computing some vector norm to measure the difference between poses at each pair of frames.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">However, such a simple approach is ill-advised, as it fails to address a number of important issues:
        1.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Simple vector norms fail to account for the meanings of the parameters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Specifically, in the joint angle representation some parameters have a much greater overall effect on the character than others (e.g., hip orientation vs. wrist orientation).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Moreover, there is no meaningful way to assign fixed weights to these parameters, as the effect of a joint rotation on the shape of the body depends on the current configuration of the body.</Sentence> 2. <Sentence inAbstract="false" summaryRelevanceScore="3.00">A motion is defined only up to a rigid 2D coordinate transformation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">That is, the motion is fundamentally unchanged if we translate it along the floor plane or rotate it about the vertical axis.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Hence comparing two motions requires identifying compatible coordinate systems.</Sentence> 3. <Sentence inAbstract="false" summaryRelevanceScore="3.33">Smooth blends require more information than can be obtained at individual frames.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">A seamless transition must account not only for differences in body posture, but also in joint velocities, accelerations, and possibly higher-order derivatives.</Sentence>
        <Sentence inAbstract="false" summaryRelevanceScore="4.00">Our similarity metric incorporates each of these considerations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">To motivate it, we note that the skeleton is only a means to an end.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In a typical animation, a polygonal mesh is deformed according to the skeleton’s pose.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This mesh is all that is seen, and hence it is a natural focus when considering how close two frames of animation are to each other.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">For this reason we measure the distance between two frames of animation in terms of a point cloud driven by the skeleton.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Ideally this point cloud is a downsampling of the mesh defining the character.</Sentence>     <Sentence inAbstract="false" summaryRelevanceScore="2.00">To calculate the distance D( i , ¡ j ) between two frames i and ¡ j , we consider the point clouds formed over two windows of frames of user-defined length k, one bordered at the beginning by   i and the other bordered at the end by ¡ j .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">That is, each point cloud is the composition of smaller point clouds representing the pose at each frame in the window.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">The use of windows of frames effectively incorporates derivative information into the metric, and is similar to the approach in <CitSpan>[Schödl et al. 2000]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The size of the   windows are the same as the length of the transitions, so D( i , ¡ j ) is affected by every pair of frames that form the transition.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We use a value of k corresponding to a window of about a third of a second in length, as in <CitSpan>[Mizuguchi et al. 2001]</CitSpan>   The distance between i and ¡ j may be calculated by computing a weighted sum of squared distances between corresponding points p i and p i in the two point clouds.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">To address the problem of finding coordinate systems for these point clouds (item 2 in the above list), we calculate the minimal weighted sum of squared distances given that an arbitrary rigid 2D transformation may be applied to the second point cloud:</Sentence>
        
          1
          θ min ,x ,z ∑ i w i p i − T θ ,x 0 ,z 0 p i 2
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where the linear transformation T θ ,x 0 ,z 0 rotates a point p about the y (vertical) axis by θ degrees and then translates it by (x 0 , z 0 ).</Sentence> The
        
          
          Figure 3: An example error function for two motions. The entry at (i, j) contains the error for making a transition from the i th frame of the first motion to the j th frame of
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">the second.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">White values correspond to lower errors and black values to higher errors.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The colored dots represent local minima.</Sentence>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">index is over the number of points in each point cloud.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The weights w i may be chosen both to assign more importance to certain joints (e.g., those with constraints) and to taper off towards the end of the window.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This optimization has a closed-form solution:</Sentence>
        
          2
          θ = arctan ∑ ∑ i i w w i i (x (x i i z x i i − + x z i i z z i i ) ) − − ∑ ∑ i i 1 1 w w i i (xz (xx − + x zz z) )
        
        
          3
          1 x 0 = ∑ w (x − x cos( θ ) − z sin θ )
        
        
          4
          1 z 0 = ∑ w (z + x sin( θ ) − z cos θ )
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where x = ∑ i w i x i and the other barred terms are defined similarly.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We compute the distance as defined above for every pair of frames in the database, forming a sampled 2D error function.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Figure 3 shows a typical result.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">To make our transition model more compact, we find all the local minima of this error function, thereby extracting the “sweet spots” at which transitions are locally the most opportune.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This tactic was also used in <CitSpan>[Schödl et al. 2000]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">These local minima are our candidate transition points.</Sentence>
      
      
        <H2>3.2 Selecting Transition Points</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.67">A local minimum in the distance function does not necessarily imply a high-quality transition; it only implies a transition better than its neighbors.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">We are specifically interested in local minima with small error values.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The simplest approach is to only accept local minima below an empirically determined threshold.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This can be done without user intervention.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">However, often users will want to set the threshold themselves to pick an acceptable tradeoff between having good transitions (low threshold) and having high connectivity (high threshold).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Different kinds of motions have different fidelity requirements.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, walking motions have very exacting requirements on the transitions — people have seen others walk nearly every day since birth and consequently have a keen sense of what a walk should look like.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">On the other hand, most people are less familiar with ballet motions and would be less likely to detect inaccuracies in such motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">As a result, we allow a user to apply different thresholds to different pairs of motions; transitions among ballet motions may have a higher acceptance threshold than transitions among walking motions.</Sentence>
        4
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>3.3 Creating Transitions</H2>
          <Sentence inAbstract="false" summaryRelevanceScore="3.00">If D( i , ¡ j ) meets the threshold requirements, we create a tran    sition by blending frames i to i+k−1 with frames ¡ j−k+1 to ¡ j , inclusive.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The first step is to apply the appropriate aligning 2D transformation to motion .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Then on frame p of the transition ¡ (0 ≤ p &lt; k) we linearly interpolate the root positions and perform spherical linear interpolation on joint rotations:</Sentence>
        
          5
          R p = α (p)R + [1 − α (p)]R i+p j−k+1+p
        
        
          6
          q ip = sler p(q i ¢ , q i £ , α (p)) i+p j−k+1+p
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where R p is the root position on the p th transition frame and q ip is the rotation of the i th joint on the p th transition frame.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">To maintain continuity we choose the blend weights α (p) according to the conditions that α (p) = 1 for p ≤ −1, α (p) = 0 for p ≥ k, and that α (p) has C 1 continuity everywhere.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This requires</Sentence>
        
          7
          α (p) = 2( p + 1 ) 3 − 3( p + 1 ) 2 + 1, −1 &lt; p &lt; k k k
        
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">Other transition schemes, such as <CitSpan>[Rose et al. 1996]</CitSpan>, may be used in place of this one.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">The use of linear blends means that constraints in the original motion may be violated.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, one of the character’s feet may slide when it ought to be planted.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">This can be corrected by using constraint annotations in the original motions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We treat constraints as binary signals: on a given frame a particular constraint either exists or it does not.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Blending these signals in analogy to equations 5   and 6 amounts to using the constraints from in the first half of the transition and the constraints from in the second half.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In this ¡ manner each transition is automatically annotated with constraint information, and these constraints may later be enforced as a postprocessing step when motion is extracted form the graph.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We will discuss constraint enforcement in more detail in the next section.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Descriptive labels attached to the motions are carried along into transitions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Specifically, if a transition frame is a blend between a frame with a set of labels L 1 and another frame with a set of labels L 2 , then it has the union of these labels L 1 ∪ L 2 .</Sentence>
        1 2 3 4 5 6 7 8
        
          Figure 4: A simple motion graph. The largest strongly connected component is <CitSpan>[1, 2, 3, 6, 7, 8]</CitSpan>. Node 4 is a sink and 5 is a dead end.
        
      
      
        <H2>3.4 Pruning The Graph</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.67">In its current state there are no guarantees that the graph can synthesize motion indefinitely, since there may be nodes (called dead ends) that are not part of any cycle (see Figure 4 ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Once such a node is entered there is a bound on how much additional motion can be generated.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Other nodes (called sinks) may be part of one or more cycles but nonetheless only be able to reach a small fraction of the total number of nodes in the graph.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">While arbitrarily long motion may still be generated once a sink is entered, this motion is confined to a small part of the database.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Finally, some nodes may have incoming edges such that no outgoing edges contain the same set of descriptive labels.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">This is dangerous since logical discontinuities may be forced into a motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, a character currently in a “boxing” motion may have no choice but to transition to a “ballet” motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">To address these problems, we prune the graph such that, starting from any edge, it is possible to generate arbitrarily long streams of motion of the same type such that as much of the database as possible is used.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This is done as follows.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Every frame of original data is associated with a (possibly empty) set of labels.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Say there are n unique sets.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">For each set, form the subgraph consisting of all edges whose frames have exactly this set of labels.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Compute the strongly connected components (SCCs) of this subgraph, where an SCC is a maximal set of nodes such that there is a connecting graph walk for any ordered pair of nodes (u, v).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The SCCs can be computed in O(V + E) time using an algorithm due to Tarjan.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We eliminate from this subgraph (and hence the original motion graph) any edge that does not attach two nodes in the largest SCC.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Once this process is completed for all n label sets, any nodes with no edges are discarded.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">A warning is given to the user if the largest SCC for a given set of labels contains below a threshold number of frames.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Also, a warning is given if for any ordered pair of SCCs there is no way to transition from the first to the second.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In either case, the user may wish to adjust the transition thresholds (Section 3.2) to give the graph greater connectivity.</Sentence>
      
      
        <H1>4 Extracting Motion</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">By this stage we have finished constructing the motion graph.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">After describing exactly how a graph walk can be converted into displayable motion, we will consider the general problem of extracting motion that satisfies user constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Our algorithm involves solving an optimization problem, and so we conclude this section with some general recommendations on how to pose the optimization.</Sentence>
        5
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>4.1 Converting Graph Walks To Motion</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.33">Since every edge on the motion graph is a piece of motion, a graph walk corresponds to a motion generated by placing these pieces one after another.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">The only issue is to place each piece in the correct location and orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In other words, each frame must be transformed by an appropriate 2D rigid transformation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">At the start of a graph walk this transformation is the identity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Whenever we exit a transition edge, the current transformation is multiplied by the transformation that aligned the pieces of motion connected by the transition (Section 3.1).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">As noted in Section 3.3, the use of linear blends to create transitions can cause artifacts, the most common of which is feet that slide when they ought to be planted.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">However, every graph walk is automatically annotated with constraint information (such as that the foot must be planted).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">These constraints are either specified directly in the original motions or generated as in Section 3.3, depending on whether the frame is original data or a transition.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">These constraints may be satisfied using a variety of methods, such as <CitSpan>[Gleicher 1998]</CitSpan> or <CitSpan>[Lee and Shin 1999]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">In our work we used the method described in <CitSpan>[Kovar et al. 2002]</CitSpan>.</Sentence>
      
      
        <H2>4.2 Searching For Motion</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">We are now in a position to consider the problem of finding motion that satisfies user-specified requirements.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">It is worth first noting that only very special graph walks are likely to be useful.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, while a random graph walk will generate a continuous stream of motion, such an algorithm has little use other than an elaborate screen saver.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">As a more detailed example, consider computing an all-pairs shortest graph walk table for the graph.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">That is, given a suitable metric — say, time elapsed or distance travelled — we can use standard graph algorithms like Floyd-Warshall to find for each pair of nodes u and v the connecting graph walk that minimizes the metric.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">With this in hand we could, for example, generate the motion that connects one clip to another as quickly as possible.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">This is less useful than it might appear at first.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">First, there are no guarantees that the shortest graph walk is short in an absolute sense.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In our larger test graphs (between a few and several thousand nodes) the average shortest path between any two nodes was on the order of two seconds.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This is not because the graphs were poorly connected.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Since the transitions were about one-third of a second apiece, this means there were on average only five or six transitions separating any two of the thousands of nodes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Second, there is no control over what happens during the graph walk — we can’t specify what direction the character travels in or where she ends up.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">More generally, the sorts of motions that a user is likely to be interested in probably don’t involve minimizing metrics as simple as total elapsed time.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">However, for complicated metrics there is typically no simple way of finding the globally optimal graph walk.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">Hence we focus instead on local search methods that try to find a satisfactory graph walk within a reasonable amount of time.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We now present our framework for extracting graph walks that conform to a user’s specifications.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">We cast motion extraction as a search problem and use branch and bound to increase the efficiency of this search.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">The user supplies a scalar function g(w, e) that evaluates the additional error accrued by appending an edge e to the existing path w, which may be the empty path 0.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">/ The total error f (w) of the path is defined as follows:</Sentence>
        
          8
          n f (w) = f ([e 1 , . . . , e n ]) = ∑ g([e 1 , . . . , e i−1 ], e i ) i=1
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where w is comprised of the edges e 1 , . . . , e n .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We require g(w, e) to be nonnegative, which means that we can never decrease the total error by adding more edges to a graph walk.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In addition to f and g, the user must also supply a halting condition indicating when no additional edges should be added to a graph walk.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">A graph walk satisfying the halting condition is called complete.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The start of the graph walk may either be specified by the user or chosen at random.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Our goal is find a complete graph walk w that minimizes f .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">To give the user control over what sorts of motions should be considered in the search, we allow restrictions on what edges may be appended to a given walk w.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, the user may decide that within a particular window of time a graph walk may only contain “sneaking” edges.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">A naıve solution is to use depth-first search to evaluate f for all complete graph walks and then select the best one.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">However, the number of possible graph walks grows exponentially with the average size of a complete graph walk.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">To address this we use a branch and bound strategy to cull branches of the search that are incapable of yielding a minimum.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Since g(w, e) by assumption never decreases, f (w) is a lower bound on f (w + v) for any v, where w + v is the graph walk composed of v appended to w.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Thus we can keep track of the current best complete graph walk w opt and immediately halt any branch of the search for which the graph walk’s error exceeds f (w opt ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Also, the user may define a threshold error ε such that if f (w) &lt; ε , then w is considered to be “good enough” and the search is halted.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Branch and bound is most successful when we can attain a tight lower bound early in the search process.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">For this reason it is worthwhile to have a heuristic for ordering the edges we explore out of a particular node.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">One simple heuristic is to order the children greedily — that is, given a set of unexplored children c 1 , . . . , c n , we search the one that minimizes g(w, c i ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">While branch and bound reduces the number of graph walks we have to test against f , it does not change the fact that the search process is inherently exponential — it merely lowers the effective branching factor.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">For this reason we generate a graph walk incrementally.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">At each step we use branch and bound to find an optimal graph walk of n frames.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We retain the first m frames of this graph walk and use the final retained node as a starting point for another search.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This process continues until a complete graph walk is generated.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In our implementation we used values of n from 80 to 120 frames (2 3 2 to 4 seconds) and m from 25 to 30 frames (about one second).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Sometimes it is useful to have a degree of randomness in the search process, such as when one is animating a crowd.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">There are a couple of easy ways to add randomness to the search process without sacrificing a good result.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The first is to select a start for the search at random.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The second is retain the r best graph walks at the end of each iteration of the search and randomly pick among the ones whose error is within some tolerance of the best solution.</Sentence>
      
      
        <H2>4.3 Deciding What To Ask For</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="3.00">Since the motion extracted from the graph is determined by the function g, it is worth considering what sorts of functions are likely to produce desirable results.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">To understand the issues involved, we consider a simple example.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Imagine we want to lay down two clips on the floor and create a motion that starts at the first clip and ends at the second.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Both clips must end up in the specified position and orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We can formally state this problem as follows: given a starting node N in the graph and a target edge e, find a graph walk this section.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The halting condition was to play a specific clip of two kicking motions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The error of a complete graph walk (which necessarily ended with the kicking clip) was determined by how far away this kicking clip was from being in a particular position and orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The character spends approximately seven seconds making minute adjustments to its orientation in an attempt to better align itself with the final clip.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The highlighted line shows the the path of the target clip in its desired position and orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">that ends with e such that the transformation T applied to e is as close as possible to a given transformation T .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">What one will receive is a motion like in Figure 5 , where the initial clip is a walking motion and the final clip is a kick.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The character turns around in place several times in an attempt to better line up with the target clip.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">While it’s conceivable that given a larger database we would have found a better motion, the problem here is with the function we passed into the search algorithm.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">First, it gives no guidance as to what should be done in the middle of the motion; all that matters is that the final clip be in the right position and orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This means the character is allowed to do whatever is possible in order to make the final fit, even if the motion is nothing that a real person would do.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Second, the goal is probably more specific than necessary.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">If it doesn’t matter what kick the character does, then it should be allowed to choose a kick that doesn’t require such effort to aim.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">More generally, there are two lessons we can draw from this example.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">First, g should give some sort of guidance throughout the entire motion, as arbitrary motion is almost never desirable.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Second, g should be no more restrictive than necessary, in order to give the search algorithm more goals to seek.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Note the tradeoff here — guiding the search toward a particular result must be balanced against unduly preventing it from considering all available options.</Sentence>
        6
        To appear in Proceedings of SIGGRAPH ’02
        
          
          Figure 5: The above motion was generated using the search algorithm discussed in
        
      
      
        <H1>5 Path Synthesis</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">We have cast motion extraction as an optimization problem, and we have given some reasons why the formulation of this optimization can be difficult.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">To demonstrate that it is nonetheless possible to come up with optimization criteria that allow us to solve a real problem, we apply the preceding framework to path synthesis.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This problem is simple to state: given a path P specified by the user, generate motion such that the character travels along P. In this section we present our algorithm for path synthesis, present results, and discuss applications of the technique.</Sentence>
      
      
        <H2>5.1 Implementing Path Synthesis</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.67">Given the framework in the previous section, our only tasks are to define an error function g(w, e) and appropriate halting criteria.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The basic idea is to estimate the actual path P travelled by the character during a graph walk and measure how different it is from P. The graph walk is complete when P is sufficiently long.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">A simple way to determine P is to project the root onto the floor at each frame, forming a piecewise linear curve 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Let P(s) be the point on P whose arc-length distance from the start of P is s.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The i th frame of the graph walk, w i , is at some arc length s(w i ) from the start of P .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We define the corresponding point on P as the point at the same arc length, P(s(w i )).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For the j th frame of e, we calculate the squared distance between P (s(e j )) and P(s(e j )).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">g(w, e) is the sum of these errors:</Sentence>
        
          9
          n g(w, e) = ∑ P (s(e i )) − P(s(e i )) 2 i=1
        
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">Note that s(e i ) depends on the total arc length of w, which is why this equation is a function of w as well as e.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The halting condition for path synthesis is when the current total length of P meets or exceeds that of P. Any frames on the graph walk at an arc length longer than the total length of P are mapped to the last point on P. The error function g(w, e) was chosen for a number of reasons.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">First, it is efficient to compute, which is important in making the search algorithm practical.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Second, the character is given incentive to make definite progress along the path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">If we were to have required the character to merely be near the path, then it would have no reason not to alternate between travelling forwards and backwards.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Finally, this metric allows the character to travel at whatever speed is appropriate for what needs to be done.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, a sharp turn will not cover distance at the same rate as walking straight forward.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Since both actions are equally important for accurate path synthesis, it is important that one not be given undue preference over the other.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">One potential problem with this metric is that a character who stands still will never have an incentive to move forward, as it can accrue zero error by remaining in place.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">While we have not encountered this particular problem in practice, it can be countered by requiring at least a small amount of forward progress γ on each frame.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">More exactly, we can replace in Equation 9 the function s(e i ) with t(e i ) = max(t(e i−1 ) + s(e i ) − s(e i−1 ),t(e i−1 ) + γ ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Typically the user will want all generated motion to be of a single type, such as walking.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This corresponds to confining the search to the subgraph containing the appropriate set of descriptive labels.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">More interestingly, one can require different types of motion on different parts of the path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, one might want the character to walk along the first half of the path and sneak down the rest.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The necessary modifications to accomplish this are simple.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We will consider the case of two different motion types; the generalization to higher numbers is trivial.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We divide the original path into two smaller adjoining paths, P 1 and P 2 , based on where the transition from type T 1 to type T 2 is to occur.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">If the character is currently fitting P 2 , then the algorithm is identical to the single-type case.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">If the character is fitting P 1 , then we check to see if we are a threshold distance from the end of P 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">If not, we continue to only consider edges of type T 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Otherwise we allow the search to try both edges of type T 1 and T 2 ; in the latter case we switch to fitting P 2 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Note that we only allow this switch to occur once on any given graph walk, which prevents the resulting motion from randomly switching between the two actions.</Sentence>
      
      
        <H2>5.2 Results</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.33">While the examples shown in Figure 1 suggest that our technique is viable, it perhaps isn’t surprising that we were able to find accurate fits to the given paths.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">As shown in the upper portion of the 1 In our implementation we defined the path as a spline approximating this piecewise linear path, although this has little impact on the results.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">figure, the input motion had a fair amount of variation, including straight-ahead marches, sharp turns, and smooth changes of curvature.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">However, our algorithm is still useful when the input database is not as rich.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Refer to Figure 6 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We started with a single 12.8second clip of an actor sneaking along the indicated path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">To stretch this data further, we created a mirror-image motion and then built a motion graph out of the two.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">From these we were able to construct the new motions shown at the bottom of the figure, both of which are themselves approximately 13 seconds in length.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Figure 7 shows fits to a more complicated path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The first example uses walking motions and the second uses martial arts motions; the latter demonstrates that our approach works even on motions that are not obviously locomotion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">For the walking motion, the total computation time was nearly the same as the length of the generated animation (58.1 seconds of calculation for 54.9 seconds animation).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The martial arts motion is 87.7 seconds long and required just 15.0 seconds of computation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In general, in our test cases the duration of a generated motion was either greater than or approximately equal to the amount of time needed to produce it.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Both motion graphs had approximately 3000 frames (100 seconds) of animation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Finally, Figure 8 shows paths containing constraints on the allowable motion type.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In the first section of each path the character is required to walk, in the second it must sneak, and in the third it is to perform martial arts moves.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Not only does the character follow the path well, but transitions between action types occur quite close to their specified locations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This example used a database of approximately 6000 frames (200 seconds).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">All examples were computed on a 1.3GHz Athlon.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">For our largest graph (about 6000 frames), approximately twenty-five minutes were needed to compute the locations of all candidate transitions points.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Approximately five minutes of user time were required to select transition thresholds, and it took less than a minute to calculate blends at these transitions and prune the resulting graph.</Sentence>
        7
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>5.3 Applications Of Path Synthesis</H2>
        <Sentence inAbstract="false" summaryRelevanceScore="2.67">Directable locomotion is a general enough need that the preceding algorithm has many applications.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Interactive Control.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">We can use path synthesis techniques to give a user interactive control over a character.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">For example, when the user hits the left arrow key the character might start travelling east.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">To accomplish this, we can use the path fitting algorithm to find the sequence of edges starting from our current location on the graph that best allow the character to travel east.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The first edge on the resulting graph walk is the next clip that will be played.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This process may then be repeated.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">To make this practical, we can precompute for every node in the graph a sequence of graph walks that fit straight-line paths in a sampling of directions (0 degrees, 30 degrees, .</Sentence> . . ). <Sentence inAbstract="false" summaryRelevanceScore="2.00">The first edges on these paths are then stored for later use; they are the best edges to follow given the direction the character is supposed to travel in.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">High-Level Keyframing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">If we want a character to perform certain actions in a specific sequence and in specific locations, we can draw a path with subsections requiring the appropriate action types.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">This allows us to generate complex animations without the tedium of manual keyframing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">For this reason we term this process “highlevel” keyframing — the user generates an animation based on what should be happening and where.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Motion Dumping.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">If an AI algorithm is used to determine that a character must travel along a certain path or start performing certain actions, the motion graph may be used to “dump” motion on top of the algorithm’s result.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Hence motion graphs may be used as a back-end for animating non-player characters in video games and interactive environments — the paths and action types can be specified by a high-level process and the motion graph would fill in the details.</Sentence> Crowds. <Sentence inAbstract="false" summaryRelevanceScore="2.67">While our discussion so far has focused on a single character, there’s no reason why it couldn’t be applied to several characters in parallel.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Motion graphs may be used as a practical tool for crowd generation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For example, a standard collision-avoidance algorithm could be used to generate a path for each individual, and the motion graph could then generate motion that conforms to this path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Moreover, we can use the techniques described at the end of Section 4.2 to add randomness to the generated motion.</Sentence>
      
      
        <H1>6 Discussion</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="5.00">In this paper we have presented a framework for generating realistic, controllable motion through a database of motion capture.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">Our approach involves automatically constructing a graph that encapsulates connections among different pieces of motion in the database and then searching this graph for motions that satisfy user constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">We have applied our framework to the problem of path synthesis.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">As we had limited access to data, our largest examples used a database of several thousand frames of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">While we believe this was sufficient to show the potential of our method, a character with a truly diverse set of actions might require hundreds or thousands of times more data.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Hence the scalability of our framework bears discussion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">The principle computational bottleneck in graph construction is locating candidate transitions (Section 3.1).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">This requires comparing every pair of the F frames in the database and therefore involves O<CitSpan>(F 2 )</CitSpan> operations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">However, this calculation is trivial to parallelize, and distances between old frames needn’t be recomputed if additions are made to the database.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">It is the exception rather than the rule that two pieces of motion are sufficiently similar that a transition is possible, and hence motion graphs tend to be sparse.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">In our experience the necessary amount of storage is approximately proportional to the size of the database.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">The number of edges leaving a node in general grows with the size of the graph, meaning the branching factor in our search algorithm may grow as well.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">However, we expect that future motion graphs will be larger mainly because the character will be able to perform more actions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">That is, for example, having increasing amounts of walking motion isn’t particularly useful once one can direct a character along nearly any path.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">Hence the branching factor in a particular subgraph will remain stationary once that subgraph is sufficiently large.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">We anticipate that typical graph searches will be restricted to one or two subgraphs, and so we expect that the search will remain practical even for larger graphs.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We conclude with a brief discussion of future work.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">One limitation of our approach is that the transition thresholds must be specified by hand, since (as discussed in Section 3.2) different kinds of motions have different fidelity requirements.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">Setting thresholds in databases involving many different kinds of motions may be overly laborious, and so we are investigating methods for automating this process.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">A second area of future work is to incorporate parameterizable motions <CitSpan>[Wiley and Hahn 1997; Rose et al. 1998]</CitSpan> into our system, rather than having every node correspond to a static piece of motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">This would add flexibility to the search process and potentially allow generated motion to better satisfy user constraints.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Finally, we are interested in applying motion graphs to problems other than path synthesis.</Sentence>
        8
        To appear in Proceedings of SIGGRAPH ’02
        
          
          Figure 6: The leftmost image shows the original motion and its reflection and the following images show motion generated by our path synthesis algorithm. The thick yellow lines were the paths to be fit and the black line is an approximation of the actual path of the character. Note how we are able to accurately fit nontrivial paths despite the limited variation in the path of the original motion.
        
        
          
          Figure 7: The left image shows a walking motion generated to fit to a path that spells “Hello” in cursive. The right image shows a karate motion fit to the same path. The total calculation time for the walking motion was 58.1 seconds and the animation itself is 54.9 seconds. The 87.7-second karate motion was computed in just 15.0 seconds. All computation was done on a 1.3gHz Athlon.
        
        
          
          Figure 8: These images are both fits to paths wherein the character is required to walk, then sneak, and finally perform martial arts moves. The desired transition points are indicated by where the curve changes color. Note that the character both fits the path accurately and switches to the appropriate motion type close to the desired location.
        
        9
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H1>Acknowledgements</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">We would like to acknowledge Andrew Gardner, Alex Mohr, and John Schreiner for assisting in video production, proofreading, and other technical matters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We also thank the University of Southern California’s School of Film and Television for their support and the reviewers for their many useful suggestions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Our work was made possible through generous motion data donations from Spectrum Studios (particularly Demian Gordon), House of Moves, and The Ohio State University.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This work was supported in part by NSF grants CCR-9984506 and IIS-0097456, the U.S. Army 2 , the Wisconsin Alumni Research Fund’s University Industrial Relations program, equipment donations from IBM, NVidia, and Intel, and software donations from Discreet, Alias/Wavefront, and Pixar.</Sentence>
      
      
        <H1>References</H1>
        
          A RIKAN , O., AND F ORSYTHE , D. 2002. Interactive motion generation from examples. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          B OWDEN , R. 2000. Learning statistical models of human motion. In IEEE Workshop on Human Modelling, Analysis, and Synthesis, CVPR 2000, IEEE Computer Society.
          B RAND , M., AND H ERTZMANN , A. 2000. Style machines. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, ACM SIGGRAPH, 183–192.
          B RUDERLIN , A., AND C ALVERT , T. 1996. Knowledge-driven, interactive animation of human running. In Graphics Interface, Canadian Human-Computer Communications Society, 213–221.
          B RUDERLIN , A., AND W ILLIAMS , L. 1995. Motion signal processing. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 97–104.
          F ALOUTSOS , P., VAN DE P ANNE , M., AND T ERZOPOULOS , D. 2001. Composable controllers for physics-based character animation. In Proceedings of ACM SIGGRAPH 2001, Annual Conference Series, ACM SIGGRAPH, 251–260.
          G ALATA , A., J OGNSON , N., AND H OGG , D. 2001. Learning variable-length markov models of behavior. Computer Vision and Image Understanding Journal 81, 3, 398–413.
          G LEICHER , M. 1998. Retargeting motion to new characters. In Proceedings 0f ACM SIGGRAPH 98, Annual Conference Series, ACM SIGGRAPH, 33–42.
          G LEICHER , M. 2001. Motion path editing. In Proceedings 2001 ACM Symposium on Interactive 3D Graphics, ACM.
          H ODGINS , J. K., W OOTEN , W. L., B ROGAN , D. C., AND O’B RIEN , J. F. 1995. Animating human athletics. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 71–78.
          K OVAR , L., G LEICHER , M., AND S CHREINER , J. 2002. Footskate cleanup for motion capture editing. Tech. rep., University of Wisconsin, Madison.
          L AMOURET , A., AND P ANNE , M. 1996. Motion synthesis by example. Computer animation and Simulation, 199–212.
          L EE , J., AND S HIN , S. Y. 1999. A hierarchical approach to interactive motion editing for human-like figures. In Proceedings of ACM SIGGRAPH 99, Annual Conference Series, ACM SIGGRAPH, 39–48.
          L EE , J., C HAI , J., R EITSMA , P. S. A., H ODGINS , J. K., AND P OLLARD , N. S. 2002. Interactive control of avatars animated with human motion data. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          L EE , J. 2000. A hierarchical approach to motion analysis and synthesis for articulated figures. PhD thesis, Department of Computer Science, Korea Advanced Institute of Science and Technology.
          L I , Y., W ANG , T., AND S HUM , H.-Y. 2002. Motion texture: A two-level statistical model for character motion synthesis. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH. 2 This paper does not necessarily reflect the position or the policy of the
          Government, and no official endorsement should be inferred
          M IZUGUCHI , M., B UCHANAN , J., AND C ALVERT , T. 2001. Data driven motion transitions for interactive games. In Eurographics 2001 Short Presentations.
          M OLINA -T ANCO , L., AND H ILTON , A. 2000. Realistic synthesis of novel human movements from a database of motion capture examples. In Proceedings of the Workshop on Human Motion, IEEE Computer Society, 137–142.
          M ULTON , F., F RANCE , L., C ANI , M.-P., AND D EBUNNE , G. 1999. Computer animation of human walking: a survey. The Journal of Visualization and Computer Animation 10, 39–54. Published under the name Marie-Paule Cani-Gascuel.
          P ERLIN , K., AND G OLDBERG , A. 1996. Improv: A system for scripting interactive actors in virtual worlds. In Proceedings of ACM SIGGRAPH 96, ACM SIGGRAPH, 205–216.
          P ERLIN , K. 1995. Real time responsive animation with personality. IEEE Transactions on Visualization and Computer Graphics 1, 1 (Mar.), 5–15.
          P ULLEN , K., AND B REGLER , C. 2000. Animating by multi-level sampling. In IEEE Computer Animation Conference, CGS and IEEE, 36–42.
          P ULLEN , K., AND B REGLER , C. 2002. Motion capture assisted animation: Texturing and synthesis. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          R OSE , C., G UENTER , B., B ODENHEIMER , B., AND C OHEN , M. F. 1996. Efficient generation of motion transitions using spacetime constraints. In Proceedings of ACM SIGGRAPH 1996, Annual Conference Series, ACM SIGGRAPH, 147–154.
          R OSE , C., C OHEN , M., AND B ODENHEIMER , B. 1998. Verbs and adverbs: Multidimensional motion interpolation. IEEE Computer Graphics and Application 18, 5, 32–40.
          S CH ODL  ̈ , A., S ZELISKI , R., S ALESIN , D., AND E SSA , I. 2000. Video textures. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, ACM SIGGRAPH, 489–498.
          S UN , H. C., AND M ETAXAS , D. N. 2001. Automating gait animation. In Proceedings of ACM SIGGRAPH 2001, Annual Conference Series, ACM SIGGRAPH, 261– 270.
          W ASHBURN , D. 2001. The quest for pure motion capture. Game Developer (December).
          W ILEY , D., AND H AHN , J. 1997. Interpolation synthesis of articulated figure motion. IEEE Computer Graphics and Application 17, 6, 39–45.
          W ITKIN , A., AND P OPOVI C  ́ , Z. 1995. Motion warping. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 105–108.
        
        10
      
    
  

</Document>
