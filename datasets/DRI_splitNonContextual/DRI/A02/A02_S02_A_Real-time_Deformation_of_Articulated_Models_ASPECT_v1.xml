<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A02_S02_A_Real-time_Deformation_of_Articulated_Models_ASPECT_v1.xml">


  
    9a62959e0e528de8c2462c1ec3ec886cc7c78f4db602ee297f4f7897c473786c
    3ww9
    http://dx.doi.org/10.1145/1053427.1053429
    Page 7 was found to have more than 100 embedded images.Image rendering was limited to the first 20, in reverse order of size.
  
  
    
      
        <Title>Spherical Blend Skinning: A Real-time Deformation of Articulated Models</Title>
      
      
        
          Ladislav Kavan ∗ Ji rı Zára ˇ Czech Technical University in Prague
          ∗
        
      
      <Sentence aspectClass="NONE" inAbstract="false">∗ e-mail: kavanl1@fel.cvut.cz
      Skin deformation based on an underlying skeleton is a common method to animate believable organic models.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The most widely used skeletal animation algorithm, linear blend skinning, is also known as skeleton subspace deformation, vertex blending, or enveloping.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">It runs in real-time even on a low-end hardware but it is also notorious for its failures, such as the collapsing-joints artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">We present a new algorithm which removes these shortcomings while maintaining almost the same time and memory complexity as the linear blend skinning.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Unlike other approaches, our method works with exactly the same input data as the popular linear version.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">This minimizes the cost of upgrade from linear to spherical blend skinning in many existing applications: the data structures and models need no change at all.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The paper discusses also theoretical properties of rotation interpolation, essential to spherical blend skinning.</Sentence>
	<H2>CR Categories: </H2>CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation <H2>Keywords: </H2>skinning, deformation, skeletal animation		  
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence aspectClass="NONE" inAbstract="false">Real-time animation of deformable objects is always a compromise between visual fidelity and computation complexity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Other aspects are quite important as well, for example the amount of artists work necessary to design the model.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Therefore, there exist many algorithms for modeling deformable objects in the literature.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">They differ by the intended area of application and generality of allowed models.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">We focus on the real-time animation systems in this paper.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Its most popular representative, known generally as the skeletal animation, is based on simple but versatile structure.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It consists of joints, given by their position and orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The segments connecting the joints are conveniently interpreted as bones.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The skeleton is, formally speaking, a tree whose nodes are identified with the joints and edges with the bones.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The only displayed element is a skin, a 3D polygonal mesh, usually equipped with normal and texture data.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Although the terminology is adopted from the virtual humanoid modeling, the skeletal animation is not limited to character animation – it can be applied to a wide range of soft objects, including imaginary (cartoon) creatures, plants, furniture, etc.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">This is an apparent advantage over complex systems which rely on explicit anatomy.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The skeleton simplifies the animation task considerably: instead of animating each vertex individually, it is sufficient to manipulate the skeleton, and the skin deforms automatically.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The skeletal animation in general does not specify how exactly the skeleton posture should be propagated to the skin.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">However, there is an established standard used in majority of real-time 3D applications.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">It comes by many names, all relating to the same algorithm: linear blend skinning (LBS), skeleton subspace deformation, vertex blending, enveloping, or simply skinning.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Basically, this algorithm blends between rigidly transformed vertices using vertex weights, which denote the amount of influence of individual joints.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">Although LBS is very fast and advantageous to graphics hardware, it suffers from inherent artifacts, known as ”collapsing joints”, ”twisting elbow problem” or a ”candy-wrapper artifact”.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">In general, the mesh deformed by LBS loses volume as the joint rotation increases.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The cause of this phenomena is explained in section 3, together with the LBS algorithm itself.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The structure of the paper is as follows: in the next section, we summarize the previous work concerning real-time skin deformation and sketch our solution.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In section 3, we analyze the problems of the LBS algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our approach to resolve these problems is presented in section 4.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In section 5, we compare the results and discuss possible enhancements.</Sentence>
      
        <H1>2 Related Work</H1>
      
      <Sentence aspectClass="NONE" inAbstract="false">An early contribution concerning the animation of deformable objects is <CitSpan>[Magnenat-Thalmann et al. 1988]</CitSpan>, which considers the movement of a human hand.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First 3D characters used in numerous computer games were animated by simple, often unpublished algorithms.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Later on, the basic principles of LBS were described by the game development community <CitSpan>[Lander 1998; Lander 1999]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The artifacts of LBS were discovered soon <CitSpan>[Weber 2000]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">An improvement based on addition of auxiliary joints has been also proposed in <CitSpan>[Weber 2000]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">Although this reduces the artifacts, the skin to joints relationship must be re-designed after joint addition.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The number and location of the additional joints remains questionable.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Another problem is how the movement of the original skeleton should be propagated into the augmented one.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More formal articles consider skin deformation as an interpolation problem, such as <CitSpan>[Lewis et al. 2000]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">They use radial basis functions to interpolate between example skins with different shapes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similar method is presented in <CitSpan>[Sloan et al. 2001] and [Kry et al. 2002]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The latter de-correlates the deformation displacements using principal component analysis, which reduces the memory requirements considerably.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The advantage of example based methods is that they capture the designed shape, including effects like muscle bulging.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The drawback is the necessity of acquiring the example skins.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">An interesting generalization of LBS is called multi-weight enveloping <CitSpan>[Wang and Phillips 2002]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">It introduces more parameters and therefore greater flexibility to the deformation algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Instead of one weight per influence (joint) as in LBS, the multiweight enveloping uses twelve.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These numerous parameters are derived from examples using the least squares optimization.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The disadvantage is obvious: while the LBS models can be weighted manually by artists <CitSpan>[Steed 2002]</CitSpan>, this is questionable with multiweight enveloping.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Tools that help animators to design the vertex weights are described in <CitSpan>[Mohr et al. 2003]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This article is interesting also from the theoretical point of view, because it describes how to explore the space of all possible LBS deformations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Another deformation algorithm <CitSpan>[Bloomenthal 2002]</CitSpan> uses a complex auxiliary structure – a medial.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">An idea similar to spherical blend skinning (SBS) is bones blending proposed by <CitSpan>[Kavan and Zára ˇ 2003]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, bones blending is limited to vertices attached to only two joints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In addition, it requires hand-tuning of special parameters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Another algorithm removes the LBS artifacts by adding additional joints, and computes the vertex weights automatically using examples <CitSpan>[Mohr and Gleicher 2003]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A recent skin deformation algorithm presented in <CitSpan>[Magnenat-Thalmann et al. 2004]</CitSpan> seems to give results competitive to SBS, although it is based on a different mathematical fundament <CitSpan>[Alexa 2002]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, this method is considerably slower than LBS and therefore <CitSpan>[Magnenat-Thalmann et al. 2004]</CitSpan> recommends to use rather the standard LBS if the joint rotations are small.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">To conclude, there are many methods correcting the problems of LBS, but none of them is superior to LBS in all aspects.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As a result, the linear blend skinning is still widely used in many applications, in spite of the artifacts.</Sentence>
      
        <H2>2.1 Our Contribution</H2>
        <Sentence aspectClass="NOVELTY" inAbstract="false">We observed that the artifacts of LBS are caused by the straightforward, linear interpolation of vertex positions.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Intuitively, a linear blending is not suitable to capture deformations induced by skeleton, because their nature is rather spherical.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Our basic idea is to change the interpolation domain: we interpolate transformations itself instead of transformed vertex positions.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Because we consider transformations consisting of a translation and rotation, we suggest to use a quaternion representation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The transition to non-linear interpolation domain is not elementary.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to achieve our goal, we cope with two main problems: determination of the center of rotation, and interpolation of multiple quaternions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The first problem follows from the fact that the choice of the center of rotation influences the result of interpolation considerably.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We show how to compute a convenient center of rotation in real-time.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The second problem is simple in the case of two quaternions <CitSpan>[Shoemake 1985]</CitSpan>, but gets considerably harder for more than two rotations <CitSpan>[Buss and Fillmore 2001; Park et al. 2002; Alexa 2002]</CitSpan>.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Because the previous methods are not efficient enough for our purpose, we use a simple linear quaternion averaging.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">We justify both theoretically and experimentally that this solution is appropriate for our task (and probably for many others).</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Resolving those problems, we obtain a skin animation algorithm that deforms the mesh in much more plausible way then LBS.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Because we change only the interpolation domain and not the input data, our program works with exactly the same models as LBS.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The proposed algorithm improves a deformed shape even of models that have been designed and carefully tuned for LBS.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Considering the high speed and low memory demands of SBS, it provides an attractive alternative to classic LBS.</Sentence>
      
      
        <H2>2.2 Conventions</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Let us denote matrices by capital letters, while vectors and quaternions by bold.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Vectors are considered column vectors, therefore a multiplication of vector v by matrix M is written as Mv.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We do not introduce a different notation for the R 3 vectors and their homogeneous R 4 counterparts with last coordinate equal to 1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The same convention is used for matrices.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We denote the dot product of two vectors v 1 , v 2 as (v 1 , v 2 ) and the norm v 1 as a shortcut for (v 1 , v 1 ).</Sentence>
      
      
        <H1>3 Linear Blend Skinning</H1>
        <Sentence aspectClass="NONE" inAbstract="false">The input to LBS consists of a polygonal mesh representing the digital skin, a skeleton, and vertex weights for every vertex of the skin.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The polygonal mesh and the skeleton are designed in a reference position, e.g. virtual characters are often posed in the da Vinci posture <CitSpan>[Steed 2002]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let us label the joints by integer numbers, assigning zero to the root.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Each joint in the reference posture is associated with a homogeneous matrix, describing its position and orientation in the world coordinate system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For j-th joint, we denote this matrix by A j , like ”absolute” (or reference) position.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This matrix is computed by multiplying all the transformations of individual joints in the chain from root to joint j.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To compute the shape of the deformed skin, we need yet another set of matrices, describing the position and orientation of joints in the actual, animated posture.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We call them F j , standing for the ”final” placement of joint j.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Matrices F j are computed in a similar way as the absolute matrices, but including the actual rotation of each joint in the chain (we do not consider translating and scaling joints).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The most simple skin deformation algorithm computes v = F j A −1 j v where v is a vertex in the reference skin associated with joint j and v is its position in the deformed mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The interpretation is following: the first matrix A −1 j transforms v to the position with joint j’s coordinate system aligned to the world coordinate system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The following transformation F j returns the vertex to its current position induced by the animated skeleton.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Because these transformations usually occur together, we define the ”complete” matrix C j = F j A −1 j .</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Some older computer games animated characters in this way, even though it does not produce nice, smooth deformations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The linear blend skinning allows assignment of one vertex to multiple bones.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Assume that vertex v is attached to joints j 1 , . . . , j n with weights w 1 , . . . , w n .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The weights are coefficients of a convex combination, i.e. non-negative and ∑ n i=1 w i = 1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The weight w i represents the amount of influence of joint j i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The vertex position in the mesh deformed by LBS is then computed as</Sentence>
        
          1
          n v = ∑ w i C j i v i=1
        
        <Sentence aspectClass="NONE" inAbstract="false">that is to say, making a convex combination of individual vertex transformations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example if n = 2 then vertex v lies on the line segment connecting C j 1 v and C j 2 v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The actual position on the segment is given by weight w 1 (or w 2 , because w 1 +w 2 = 1).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As explained in the next section, the SBS works on a circular arc instead of segment, see Figure 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the joint rotations are large, the LBS produces non-natural deformations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the extremal case of rotation by 180 degrees, the skin can collapse to a single point.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It is the notorious ”candy-wrapper” artifact, which is demonstrated in Figure 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The right shoulder of the model is twisted by 180 degrees, while the left shoulder is left in the reference pose.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To understand why this undesirable effect occurs, it is sufficient to re-arrange the equation <CitSpan>(1)</CitSpan>
</Sentence>
        mesh bone joint j 1 j 2 vertex v C j 2 v C j 1 v LBS workspace SBS workspace
        
          Figure 1: The set of possible results of LBS is a line segment, while SBS gives a circular arc.
        
        
          2
          n v = ∑ w i C j i v i=1
        
        <Sentence aspectClass="NONE" inAbstract="false">This formula is less efficient, because it blends matrices instead of vectors, but gives us a valuable insight.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">It is well known that the component-wise interpolation of matrices produces odd results: it does not preserve the orthogonality of the rotational part of the matrix.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">In some situations, it does not preserve even the rank of the interpolated matrices.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This is exactly what happens in the ”candywrapper” problem: the single point the skin collapses to is a result of transformation by a singular matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A similar defect is visible also in the proximity of the singular configuration.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Although the matrix is regular, it involves a non-uniform scaling and skewing, which is responsible for the loss of volume of the deformed skin even for small rotations.</Sentence>
      
      
        <H1>4 Spherical Blend Skinning</H1>
        <Sentence aspectClass="NOVELTY" inAbstract="false">Instead of trying to correct the bad results of LBS, we propose to change the interpolation method in <CitSpan>(2)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We focus on the interpolation of rotations – the linear interpolation of the translation part of C j i matrices is all right.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">An established interpolation of two rotations is spherical linear interpolation (SLERP) <CitSpan>[Shoemake 1985]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Its key of success is the use of quaternions to represent rotations.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Unfortunately, it is not possible to simply replace matrices C j i in <CitSpan>(2)</CitSpan> with corresponding pairs quaternion-translation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One of the problems is that the linear interpolation of quaternions is not equivalent to SLERP.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, this is not the most serious difficulty, and we address it in section 4.1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The more important problem is to compute a convenient center of the interpolated rotations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We show that this is really an important problem on an example of human arm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Consider that the arm geometry is influenced by two joints j 1 and j 2 , such that j 1 is a parent of j 2 , as in Figure 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The transformation of the whole mesh by C j 1 is illustrated in the top row of Figure 3 and the transformation of the same geometry by C j 2 in the bottom row (note that the results are identical in both columns of these rows).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The rows in the middle show the progress of interpolation between C j 1 to C j 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The only difference between the two columns in Figure 3 is in the choice of the center of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the left column, the rotation center r c is set to the translation part of matrix A j 2 (the position of joint j 2 in the reference posture).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that C j 1 r c = C j 2 r c , therefore also the transformed rotation center is constant during the interpolation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the right column of the figure, the rotation center r c is set to the translation part of A j 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Because C j 1 r c = C j 2 r c , the transformed rotation center is linearly interpolated from C j 1 r c to C j 2 r c .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">By comparison with the starting mesh (drawn gray in each frame), it is obvious that the center of rotation choice in the left column is much more advantageous.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this case, the interpolation of every single point is a circular arc (as in Figure 1), whereas a disturbing drift is inherent to any other choice of rotation center (such as r c ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Unfortunately, the condition of zero translation cannot be always satisfied, typically for more than two influencing joints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">But even if the vertex is attached to only two joints k and l that are not neighbours of each other, some translation may be inevitable.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example consider that there is no relative rotation between C k and C l , but there is a relative translation induced by the joints in the chain between k and l.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Clearly no choice of the center of rotation can avoid this translation, because the rotation is identity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Anyway, it is possible to define the rotation center as the point whose transformations by associated matrices are as close as possible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This minimizes the drift and works even if the vertex is assigned to n joints j 1 , . . . , j n .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We find the center of rotation r c as the</Sentence>
        
          Figure 2: Up – an extreme shoulder twist deformed by LBS, down – the same posture deformed by SBS
        
        C j 1 C j 1 C j 1 r c C j 1 r c
        C j 2 C j 2 C j 2 r c C j 2 r c
        
          Figure 3: The correct center of rotation is chosen in the left column, while the sub-optimal in the right column. In the middle rows, notice the difference of the elbow position with respect to the original skin.
        
        <Sentence aspectClass="NONE" inAbstract="false">least-squares solution of the system of n 2 linear vector equations C a r c = C b r c , a &lt; b, a, b ∈ { j 1 , . . . , j n } Each homogeneous matrix C i has structure C i = C 0 i rot T C 1 tr i
        where C i rot is a 3 × 3 orthogonal matrix and C tr i is a translation vector.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This enables us to re-write the linear system to C a rot r c + C tr a = C b rot r c + C tr b (C a rot −C b rot )r c = C tr b − C tr a If we stack all these equations to one matrix D and the right-hand sides to vector e, we can write the whole system as Dr c = e where D is a 3 n 2 × 3 matrix, r c is a 3-dimensional unknown vector and e is 3 2 n -dimensional vector.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In general, we cannot make any assumptions about the rank of matrix D, which can vary from 0 to 3 (consider for example n = 2 and C j 1 = C j 2 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We search the optimal solution r c in the least-squares sense.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If there are multiple solutions giving the minimal Dr c − e , the r c with the minimal norm is chosen.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This can be done in a robust way using the singular value decomposition (SVD), followed by computation of pseudo-inverse matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To perform these computations, we use the LAPACK software <CitSpan>[Anderson et al. 1999]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Even though LAPACK routines are efficient, computation of the center of rotation per each vertex would not result in a real-time algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Fortunately, the center of rotation depends only on the transformations of the joints j 1 , . . . , j n and not the vertex itself.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Therefore, if we encounter another vertex assigned to the same set of joints j 1 , . . . , j n , we can re-use the center of rotation computed formerly (cached).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Moreover, if there is only one, or two neighboring joints that influence the vertex, we can determine the center of rotation precisely (as indicated in the beginning of this section) and omit the SVD computation at all.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It turns out that the number of different non-trivial joint sets, and therefore the number of running the SVD, is surprisingly small for common models – about several tens.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This enables the real-time performance.</Sentence>
      
      
        <H2>4.1 Interpolation of Multiple Rotations</H2>
        <Sentence aspectClass="NONE" inAbstract="false">As mentioned in the introduction, the interpolation of multiple rotations has already received some attention <CitSpan>[Buss and Fillmore 2001; Park et al. 2002]</CitSpan> as well as interpolation of multiple general transformations <CitSpan>[Alexa 2002]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Unfortunately, all these methods are substantially slower then the simple linear interpolation used in LBS.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since our goal is an algorithm with comparable time complexity as LBS, we propose an approximate but fast linear quaternion blending.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the case of two rotations, we compare our method with the established SLERP.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Recall that a rotation around axis a (unit length vector) with angle 2 α corresponds to quaternion q = cos α + a sin α .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, this correspondence is not unique, because both quaternions q and −q represent the same rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The SLERP of two unit quaternions p, q assumes that their dot product (p, q) ≥ 0.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the dot product (p, q) &lt; 0, we use −p instead of p, which is possible because both p and −p represent the same rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The SLERP of p, q with interpolation parameter t ∈ 0, 1 is given by the following formula, see for example <CitSpan>[Eberly 2001]</CitSpan>.</Sentence>
        
          3
          sin((1 − t) θ )p + sin(t θ )q s(t; p, q) = sin θ
        
        <Sentence aspectClass="NONE" inAbstract="false">where θ is the angle inclined by quaternions p, q, i.e. cos θ = (p, q).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The linear interpolation of quaternions (QLERP) is computed as</Sentence>
        
          4
          (1 − t)p + tq l(t; p, q) = (1 − t)p + tq
        
        <Sentence aspectClass="NONE" inAbstract="false">The difference to SLERP is obvious: QLERP interpolates along the shortest segment, and then projects to arc, which does not result in the uniform interpolation of the arc.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In spite of this, we claim that QLERP is sufficient for our task.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to justify this statement, we face an interesting question by itself: how big can be the difference between QLERP and SLERP for the same input rotations?</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For t = 0, both QLERP and SLERP return of course p. For t &gt; 0, we can imagine that both QLERP and SLERP work by concatenating p with some rotation (multiplying p with some quaternion).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For SLERP, we denote this quaternion as r s (t).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It can be expressed as p ∗ s(t; p, q), because pr s (t) = pp ∗ s(t; p, q) = s(t; p, q) The rotation r s (t) can be written out as</Sentence>
        
          5
          r s (t) = p ∗ s(t; p, q) = sin((1 − t) θ sin )1 + θ sin(t θ )p q
        
        <Sentence aspectClass="NONE" inAbstract="false">The quaternion 1 represents the identity (zero angle rotation).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">From the definition of quaternion multiplication it can be seen that the real part of p ∗ q equals (p, q) = cos θ .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since p ∗ q is a unit quaternion, we can express it as p ∗ q = cos θ + u sin θ for some axis of rotation u.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we substitute this into equation <CitSpan>(5)</CitSpan>, we obtain sin((1 − t) θ ) + sin(t θ ) cos θ r s (t) = sin θ + u sin(t θ ) which means that the direction of the axis u is independent on t.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let us examine the rotation r l (t) following p in QLERP: r l (t) = p ∗ l(t; p, q) = (1 (1 − − t)1 t)p + + tp tq ∗ q = (1 − t + t cos θ ) t sin θ = + u (1 − t)p + tq (1 − t)p + tq which shows that the axis of rotation has the same direction.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can conclude with an important property: the SLERP can be written as pr s (t) and QLERP as pr l (t), where the rotations r s (t) and r l (t) have the same axis.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Moreover, this axis is constant, i.e. independent on the interpolation parameter t.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It follows that the only difference between QLERP and SLERP is in the angle of rotations r s (t) and r l (t).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that both r s (t) and r l (t) have a form of linear combination of quaternions 1 and p ∗ q.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It means that the results of both r s (t) and r l (t) always end up in certain 2D subspace of R 4 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can restrict our attention to this subspace (the linear hull of 1 and p ∗ q).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since SLERP assumes cos θ = (p, q) ≥ 0, the angle θ cannot exceed π /2.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To obtain an upper bound of the maximal difference in the angle, we consider the extremal case with θ = π /2, depicted in Figure 4 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The angle α (t) on the picture can be computed by atan, and β (t) by simple linear interpolation of the right angle, which yields the difference function t π d(t) = α (t) − β (t) = atan − t 1 − t 2 It remains to find the extremes of d(t) on the interval 0, 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The elementary mathematical analysis discovers the global extremes in points 1/2 ± (1/ π − 1/4).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The absolute value of d(t) in these points is approximately 0.071 radians (4.07 degrees).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As mentioned in the introduction of this section the angle of rotation is twice the angle inclined by quaternions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To conclude: both SLERP and QLERP interpolate by multiplying the first quaternion with a rotation with the same, fixed axis.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The difference between SLERP and QLERP is only in the angle of this rotation, and is strictly less then 0.143 radians (8.15 degrees) for any interpolation parameter t ∈ 0, 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is an upper bound; practical results are much smaller and could hardly cause an observable defect in the deformed skin.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The big advantage of QLERP is that it can be easily generalized to interpolate multiple rotations – it suffices to make a convex combination and re-normalization of multiple quaternions.</Sentence>
        1 SLERP QLERP t a (t) b (t) 1-t 1
        
          Figure 4: The difference between QLERP angle α (t) and SLERP β (t)
        
      
      
        <H2>4.2 Algorithm Overview</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Now we have prepared all the ingredients to describe how the SBS algorithm works.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The task is to transform a vertex v influenced by joints j 1 , . . . , j n with convex weights W = (w 1 , . . . , w n ) to its position v in the animated skin.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to obtain an appealing deformation, it is necessary to respect the computed center of rotation r c .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To achieve this, we extend the QLERP scheme to homogeneous matrices C j i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We denote the interpolation of matrices C j i with weights W as</Sentence>
        
          6
          Q m q(W ;C j 1 , . . . ,C j n ) = 0 T 1
        
        <Sentence aspectClass="NONE" inAbstract="false">and compute Q and m as follows.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, the rotation submatrices C rot j i are converted to quaternions q j i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One of them, for example q j 1 , is chosen as pivot.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If (q j 1 , q j i ) &lt; 0 for any i = 2, . . . , n, we replace q j i with −q j i (by analogy to SLERP).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then the QLERP computes s = w 1 q j 1 + .</Sentence> . . <Sentence aspectClass="NONE" inAbstract="false">+ w n q j n , which is subsequently normalized to s n = s/ s .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, s n is converted to the rotation matrix Q. The translation part is just linearly interpolated, m = ∑ n i=1 w i C tr j i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to change the center of rotation from the origin to r c , we define a homogeneous matrix
        T = 0 I T r 1 c <CitSpan>(7)</CitSpan>
        where I is a 3 × 3 identity matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then the interpolation of homogeneous matrices with respect to the center of rotation r c can be written as</Sentence>
        
          8
          T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1
        
        <Sentence aspectClass="NONE" inAbstract="false">Note that the shift of the center of rotation does not influence the interpolated rotation – it manifests only in the translation part.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The desired transformation of vertex v is v = T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 v</Sentence>
        
          9
          n = Q(v − r c ) + ∑ w i C j i r c i=1
        
        <Sentence aspectClass="NONE" inAbstract="false">A detailed derivation of this formula can be found in appendix A. The latter addend represents the translation induced by the new center of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The equation <CitSpan>(9)</CitSpan> has to be evaluated once per each vertex, and therefore should be as efficient as possible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The basic optimization is to pre-compute the quaternions q j i , because they do not depend on the actual vertex – only on the joint’s transformation, similarly as the rotation centers r c .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Nonetheless, QLERP has to be executed for each vertex, since weights w 1 , . . . , w n can vary.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to challenge the speed of LBS, we apply a following trick.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The vertex v can be represented by a quaternion with zero real part.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this representation, its rotation by quaternion q can be expressed as q vq ∗ , which is a quaternion with zero real part as well <CitSpan>[Eberly 2001]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Although this expression is not efficient for computation (because of slow quaternion multiplication), it enables us to write out the rotation of v by quaternion s n as s n vs n ∗ = s 1 2 svs ∗ = (s, 1 s) svs ∗ This suggests to convert already the quaternion s to matrix Q and normalize subsequently by dividing (s, s).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Therefore, we can compute the Q matrix from <CitSpan>(9)</CitSpan> as Q = (s,s) Q and save the sqrt operation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Some attention must be paid because standard routines for quaternion to matrix conversion assume a unit-length quaternion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The conversion of an arbitrary length q = w + xi + y j + zk leads to the following matrix: ⎛ ⎞ x 2 + w 2 − y 2 − z 2 2xy − 2wz 2xz + 2wy ⎝ 2xy + 2wz y 2 + w 2 − x 2 − z 2 2yz − 2wx ⎠ 2xz − 2wy 2yz + 2wx z 2 + w 2 − x 2 − y 2 Vertex normal v n is transformed in a similar way as vertex position, but ignoring the translation v n = Qv n Using the formula <CitSpan>(9)</CitSpan> we can verify our previous intuitive thinking.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, if we substitute r c in place of v, no rotation occurs, which means that r c is indeed a center of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Second, if n = 2 and C j 1 r c = C j 2 r c (as in the beginning of section 4), the translation part becomes w 1 C j 1 r c + w 2 C j 2 r c = (w 1 + w 2 )C j 1 r c = C j 1 r c which is independent of interpolation parameters (weights), i.e. the translation during interpolation is constant indeed.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Third, the equation <CitSpan>(9)</CitSpan> is nothing but a generalization of LBS to an arbitrary method of rotation interpolation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The choice of QLERP is not important for <CitSpan>(9)</CitSpan>, the matrix Q can be replaced by matrix resulting from any other interpolation scheme, such as <CitSpan>[Buss and Fillmore 2001]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we substitute Q = ∑ w i C rot j i , i.e. a simple linear combination of rotation matrices, we obtain v = Q(v − r c ) + ∑ w i C j i r c = ∑ w i C rot j i v − ∑ w i C rot j i r c + ∑ w i C rot j i r c + ∑ w i C tr j i = ∑ w i C rot j i v + ∑ w i C tr j i = ∑ w i C j i v which is exactly the LBS equation <CitSpan>(1)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This also shows that LBS is a special case, which is independent of the center of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The whole algorithm can be summarized in the following steps:</Sentence>
        
          Figure 5: 3D models used for testing
        
        
          
            
              
                
                  
                   Hand
                   Woman
                   Creature
                
              
              
                
                   vertices
                   2402
                   3356
                   6802
                
                
                   triangles
                   4800
                   5205
                   13590
                
                
                   joints
                   23
                   78
                   56
                
              
            
          
          Hand Woman Creature vertices 2402 3356 6802 triangles 4800 5205 13590 joints 23 78 56
          Table 1: Complexities of example models
        
        <Sentence aspectClass="NONE" inAbstract="false">• compute matrices C i for all joints and convert their rotation parts to quaternions q i • for each vertex v influenced by joints j 1 , . . . , j n – compute (or re-use a cached) center of rotation r c according to section 4 – blend quaternions q j 1 , . . . q j n using QLERP and convert the result to matrix Q – compute the position of vertex v in the deformed skin using the equation <CitSpan>(9)</CitSpan>
</Sentence>
      
      
        <H1>5 Results and Comparison</H1>
        <Sentence aspectClass="NONE" inAbstract="false">We tested the SBS algorithm on three models, see Figure 5 and Table 1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We compare the shape of the deformed skin on the model of woman, because human eye is most sensitive to the deformations of human body.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Figure 6 presents results of LBS and SBS executed on the same posture of the model.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Another example has been presented already in Figure 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For small deformations, both algorithms produce similar results, as in the second row of Figure 6 (although a small loss of volume is noticeable even there).</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">It is remarkable that the results of SBS are better even though the models have been optimised to work with the LBS algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The performance of both algorithms is compared in Table 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The measured value is an average time in milliseconds necessary to deform one model on a 2.5GHz Athlon PC (rendering time not included).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the last row of the table the number of different nontrivial joint sets is reported (trivial joint set consists of only one joint</Sentence>
        
          Figure 6:
        
        Comparison of deformations by LBS (left) and SBS
        (right)
        <Sentence aspectClass="NONE" inAbstract="false">or two neighboring joints).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Put in another way, it is exactly the number of singular-value decompositions performed by the SBS algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This number participates considerably on the difference between times for LBS and SBS.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Theoretically, the number of different non-trivial joint sets could be very high.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Fortunately, this number is surprisingly small in practice, because the joint influences tend to be local (e.g. it is unlikely to find vertices influenced by both left and right wrist).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The additional memory needed for SBS is dominated by caching the computed centers of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, this amount of memory is negligible, considering the number of different non-trivial joint sets.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to test the accuracy of QLERP, we experimented with spherical weighted averages presented in <CitSpan>[Buss and Fillmore 2001]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The algorithm proposed in <CitSpan>[Buss and Fillmore 2001]</CitSpan> behaves like SLERP for the case of two rotations (in contrast to QLERP, which only approximates SLERP results).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">On the one hand, the difference in the deformed skin was barely observable, according to the results from section 4.1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">On the other hand, the increase in the execution time was quite substantial.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the woman model, the time increased from original 4.54ms to 22.74ms.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This only confirmed our choice of QLERP.</Sentence>
        
          
            
              
                
                  
                   Hand
                   Woman
                   Creature
                
              
              
                
                   LBS time
                   3.28
                   3.59
                   9.0
                
                
                   SBS time
                   4.43
                   4.54
                   11.37
                
                
                   SVD executions
                   38
                   37
                   56
                
              
            
          
          Hand Woman Creature LBS time 3.28 3.59 9.0 SBS time 4.43 4.54 11.37 SVD executions 38 37 56
          Table 2: First two rows: run-time of LBS and SBS algorithms in milliseconds; last row: number of SVD executions
        
      
      
        <H2>5.1 Conclusion and Future Work</H2>
        <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The proposed skin deformation system is by no means perfect; it cannot compete with complex, layered models.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">However, the SBS algorithm offers reasonable price for elimination of the notorious LBS artifacts.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The time and memory complexity of both algorithms is comparable.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The overhead of replacing an existing LBS implementation by SBS is minimal, because the input data, as well as the internal data structures, are the same.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In contrast to other methods, the SBS does not need any additional information, such as the example skins.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The presented algorithm opens many questions and suggests several directions of future work.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First of all, we worked only with vertex weights optimised for LBS.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These weights are designed to suppress the LBS artifacts, even though they cannot remove them.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It would be interesting to find out how much can be the SBS results improved by a set of weights especially designed for SBS.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to accomplish this, a tool to explore the space of SBS deformations would help considerably.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This tool has been presented for LBS in <CitSpan>[Mohr et al. 2003]</CitSpan>, but the situation of SBS is somewhat more complex, because our interpolation method is non-linear.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, it would be possible to estimate the SBS vertex weights from examples, as was done for LBS in <CitSpan>[Mohr and Gleicher 2003]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This could also cover additional effects like muscle bulging.</Sentence>
      
      
        <H1>6 Acknowledgments</H1>
        <Sentence aspectClass="NONE" inAbstract="false">This work has been partly supported by the Ministry of Education, Youth and Sports of the Czech Republic under research program No.Y04/98:212300014 (Research in the area of information technologies and communications).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We thank to Samuel Buss for providing the algorithm for spherical weighted averages <CitSpan>[Buss and Fillmore 2001]</CitSpan> and to LAPACK developers for their software.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We would also like to thank to Jaroslav Seman cı k and the anonymous reviewers for valuable comments and to Adam J. Sporka for help with the accompanying video.</Sentence>
      
      
        <H1>A Interpolation of Rotations with an Arbitrary Center</H1>
        <Sentence aspectClass="NONE" inAbstract="false">In this appendix we derive the formula <CitSpan>(9)</CitSpan>, which describes the interpolation of rotations with respect to r c – a custom center of rotation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let us denote by K the coordinate system with origin in r c and identical basis vectors as the world coordinate system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then
        the matrix T <CitSpan>(7)</CitSpan> can be interpreted as a transformation from K to the world coordinate system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">By analogy, the inverse matrix T −1 = 0 I T −r 1 c
        represents the transformation from the world coordinate system to K. It follows that T −1 C j i T is the transformation C j i expressed with respect to K. By interpolating these matrices with QLERP q(W ; T −1 C j 1 T, . . . , T −1 C j n T ) we obtain a matrix working also on vectors in K coordinates.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can express this matrix with respect to the world coordinate system easily T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 which is exactly the formula <CitSpan>(8)</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Recall that the matrix C j i has structure C j i = C 0 rot j T i C 1 tr j i
        which enables us to write out T −1 C j i T = C 0 rot j T i C j i r c 1 − r c
        as can be simply verified.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Please note that the change of the coordinate system did not influence the rotation part C rot j i at all.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Therefore the result of QLERP will be, according to equation <CitSpan>(6)</CitSpan>
        q(W ; T −1 C j 1 T, . . . , T −1 C j n T ) = 0 Q T −r c + ∑ i=1 n 1 w i C j i r c
        where Q stands for the interpolation of pure rotations, computed as indicated in section 4.2.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Using T −1 v = v − r c and T x = x + r c , we see that v = T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 v = T 0 Q T −r c + ∑ i=1 n 1 w i C j i r c v − 1 r c n = Q(v − r c ) + ∑ w i C j i r c i=1
        is true for any vector v.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is exactly the equation <CitSpan>(9)</CitSpan>.</Sentence>
      
      
        <H1>References</H1>
        
          A LEXA , M. 2002. Linear combination of transformations. In SIGGRAPH ’02: Proceedings of the 29th annual conference on Computer graphics and interactive techniques, ACM Press, 380–387.
          A NDERSON , E., B AI , Z., B ISCHOF , C., B LACKFORD , S., D EM MEL , J., D ONGARRA , J., D U C ROZ , J., G REENBAUM , A., H AMMARLING , S., M C K ENNEY , A., AND S ORENSEN , D. 1999. LAPACK Users’ Guide, third ed. Society for Industrial and Applied Mathematics, Philadelphia, PA.
          B LOOMENTHAL , J. 2002. Medial-based vertex deformation. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 147–151.
          B USS , S. R., AND F ILLMORE , J. P. 2001. Spherical averages and applications to spherical splines and interpolation. ACM Trans. Graph. 20, 2, 95–126.
          E BERLY , D. 2001. 3D game engine design: a practical approach to real-time computer graphics. Morgan Kaufmann Publishers Inc.
          K AVAN , L., AND Z ˇ ARA  ́ , J. 2003. Real-time skin deformation with bones blending. In WSCG Short Papers Proceedings.
          K RY , P. G., J AMES , D. L., AND P AI , D. K. 2002. Eigenskin: real time large deformation character skinning in hardware. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 153–159.
          L ANDER , J. 1998. Skin them bones: Game programming for the web generation. Game Developer Magazine (May), 11–16.
          L ANDER , J. 1999. Over my dead, polygonal body. Game Developer Magazine (October), 17–22.
          L EWIS , J. P., C ORDNER , M., AND F ONG , N. 2000. Pose space deformation: a unified approach to shape interpolation and skeleton-driven deformation. In Proceedings of the 27th annual conference on Computer graphics and interactive techniques, ACM Press/Addison-Wesley Publishing Co., 165–172.
          M AGNENAT -T HALMANN , N., L APERRI È RE , R., AND T HAL MANN , D. 1988. Joint-dependent local deformations for hand animation and object grasping. In Proceedings on Graphics interface ’88, Canadian Information Processing Society, 26–33.
          M AGNENAT -T HALMANN , N., C ORDIER , F., S EO , H., AND P A PAGIANAKIS , G. 2004. Modeling of bodies and clothes for virtual environments. In CW ’04: Proceedings of the 2004 International Conference on Cyberworlds (CW’04), IEEE Computer Society, 201–208.
          M OHR , A., AND G LEICHER , M. 2003. Building efficient, accurate character skins from examples. ACM Trans. Graph. 22, 3, 562– 568.
          M OHR , A., T OKHEIM , L., AND G LEICHER , M. 2003. Direct manipulation of interactive character skins. In Proceedings of the 2003 symposium on Interactive 3D graphics, ACM Press, 27–30.
          P ARK , S. I., S HIN , H. J., AND S HIN , S. Y. 2002. On-line locomotion generation based on motion blending. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 105–111.
          S HOEMAKE , K. 1985. Animating rotation with quaternion curves. In Proceedings of the 12th annual conference on Computer graphics and interactive techniques, ACM Press, 245–254.
          S LOAN , P.-P. J., R OSE , III, C. F., AND C OHEN , M. F. 2001. Shape by example. In Proceedings of the 2001 symposium on Interactive 3D graphics, ACM Press, 135–143.
          S TEED , P. 2002. Animating Real-Time Game Characters with CDROM. Charles River Media, Inc.
          W ANG , X. C., AND P HILLIPS , C. 2002. Multi-weight enveloping: least-squares approximation techniques for skin animation. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 129–138.
          W EBER , J. 2000. Run-time skin deformation. In Proceedings of Game Developers Conference.
        
      
    
  

</Document>
