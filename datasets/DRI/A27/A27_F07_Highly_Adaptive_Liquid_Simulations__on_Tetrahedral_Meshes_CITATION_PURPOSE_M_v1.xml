<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A27_F07_Highly_Adaptive_Liquid_Simulations__on_Tetrahedral_Meshes_CITATION_PURPOSE_M_v1.xml">


  
    1bc32fd79f71ddaed6dc90f472a41b0eaae0eba6d03053a8819e16a4b2305917
    3x6m
    http://dx.doi.org/10.1145/2461912.2461982
  
  
    
      
        <Title>Highly Adaptive Liquid Simulations on Tetrahedral Meshes</Title>
      
      
        
          Ryoichi Ando ∗ Nils Thürey † Kyushu University ScanlineVFX
          ∗
        
      
      ∗ E-mail: and@verygood.aid.design.kyushu-u.ac.jp † E-mail: nils.thuerey@scanlinevfx.com ‡ E-mail: wojtan@ist.ac.at
      
        
        Figure 1: Our adaptive simulation framework allows us to efficiently simulate highly detailed splashes on large open surfaces. In this case, maximum BCC mesh resolutions from 8 to 1024 cells were used, leading to strong horizontal grading along the surface.
      
      <Abstract>We introduce a new method for efficiently simulating liquid with extreme amounts of spatial adaptivity. Our method combines several key components to drastically speed up the simulation of largescale fluid phenomena: We leverage an alternative Eulerian tetrahedral mesh discretization to significantly reduce the complexity of the pressure solve while increasing the robustness with respect to element quality and removing the possibility of locking. Next, we enable subtle free-surface phenomena by deriving novel second-order boundary conditions consistent with our discretization. We couple this discretization with a spatially adaptive Fluid-Implicit Particle (FLIP) method, enabling efficient, robust, minimally-dissipative simulations that can undergo sharp changes in spatial resolution while minimizing artifacts. Along the way, we provide a new method for generating a smooth and detailed surface from a set of particles with variable sizes. Finally, we explore several new sizing functions for determining spatially adaptive simulation resolutions, and we show how to couple them to our simulator. We combine each of these elements to produce a simulation algorithm that is capable of creating animations at high maximum resolutions while avoiding common pitfalls like inaccurate boundary conditions and inefficient computation.</Abstract>
	  I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Physically based modeling Keywords: motion editing, motion signal-processing, spacetime constraints, motion capture.	  
	  
      
        
          Chris Wojtan ‡ IST Austria
        
      
      Links:
      
        
      
      DL PDF
      
        
      
    
    
      
        <H1>1 Introduction</H1>
      
      This paper aims to produce fluid simulations with a high degree of spatial adaptivity. We desire to enable a simulator to focus its computational resources on the visually interesting regions of a fluid flow, while remaining computationally efficient and avoiding common artifacts due to a spatially adaptive pressure solve. Previous approaches have made great strides towards this goal, but they often exhibit visual artifacts, a lack of computational robustness, or an unacceptably hefty computational expense. <Cit_context CITid_1="NEUTRAL">The groundbreaking work of </Cit_context>
<InlineCitation CITid="1">Losasso et al. [2004]</InlineCitation>
<Cit_context CITid_1="CRITICISM"> introduced an octree for spatial adaptivity, but it suffers from spurious flows at T-junctions.</Cit_context> <Cit_context CITid_2="NEUTRAL">Finite volume methods </Cit_context>
<InlineCitation CITid="2">[Batty et al. 2010]</InlineCitation>
<Cit_context CITid_2="CRITICISM"> repair these spatial artifacts at the expense of solving a significantly larger system of equations and sacrificing computational stability near poorly-shaped elements.</Cit_context> Furthermore, many existing methods still are not truly spatially adaptive in the sense that their computational complexity is still tied to a uniform grid or spatial parameter. We introduce a combination of techniques that successfully makes adaptive fluid simulation practical at large scales. We first reduce memory and computational costs by switching from a finite volume method to a discretization with a significantly smaller linear system for the pressure solve, which has the side effect of increasing the simulator’s robustness to poor-quality elements and effectively preventing locking artifacts. We next derive second-order Dirichlet boundary conditions consistent with our discretization to benefit from the subtle surface dynamics associated with an accurate pressure solve. We combine this robust and efficient tetrahedral meshbased fluid simulator with a spatially adaptive method for sampling particles for FLIP-based velocity advection, giving us a method free from any single spatial resolution. In addition to our adaptive FLIP simulator, we also introduce a new method for computing a surface from a distribution of particles with variable radii. We found that this method out-performs previous methods in cases of extreme spatial adaptivity by exhibiting smoother surfaces without sacrificing detail. Our fluid simulator works well with spatially adaptive tetrahedral meshes, but it is another question to decide exactly how these adaptive meshes should be generated. We investigate various methods for generating these adaptive meshes by experimenting with several sizing functions, allowing us to precisely dictate where simulation detail should occur. Some examples are a surface curvature-based metric that adds detail only where needed on the fluid surface, a turbulence metric that adds detail only where interesting fluid motion occurs, and a visibility metric that adds detail only in front of a virtual camera. Concretely, the contributions of our work are: • a novel tetrahedral discretization of the pressure projection step that is efficient to solve and robust to poor-quality elements; • an accurate treatment of second-order boundary conditions within the tetrahedral mesh; • a new technique for extracting a smooth surface from particles with varying radii; • and the inclusion of a flexible sizing function to focus computational resources on important areas of the flow with minimal overhead. These contributions work together to produce a practical fluid simulator that exhibits low computational and memory complexity, fewer visual artifacts, and a high effective simulation resolution.
      
        <H1>2 Related Work</H1>
        Our work is based on the Fluid-Implicit Particle (FLIP) method introduced to the computer graphics community by <InlineCitation CITid="3">Zhu and Bridson [2005]</InlineCitation>
<Cit_context CITid_3="NEUTRAL">, which arguably represents the state-of the art for detailed and robust liquid simulations.</Cit_context> <Cit_context CITid_5="BASIS">
<Cit_context CITid_4="BASIS">The algorithm still follows the general ideas of the Stable Fluid solver </Cit_context>
<InlineCitation CITid="4">[Stam 1999]</InlineCitation>, and can be readily combined with second-order treatment of free surface boundary conditions </Cit_context>
<InlineCitation CITid="5">[Enright et al. 2003]</InlineCitation>. FLIP derives its success from the fact that it uses particles to compute an accurate, nondiffusive transport of flow quantities, in combination with a gridbased solve to accurately enforce constraints for mass conservation. <Cit_context CITid_8="NEUTRAL">
<Cit_context CITid_7="NEUTRAL">
<Cit_context CITid_6="NEUTRAL">The FLIP algorithm is heavily used in the special effects industry, and recent advances have introduced accurate coupling with obstacles </Cit_context>
<InlineCitation CITid="6">[Batty et al. 2007]</InlineCitation>, highly viscous materials </Cit_context>
<InlineCitation CITid="7">[Batty and Bridson 2008]</InlineCitation>, and two-phase flows </Cit_context>
<InlineCitation CITid="8">[Boyd and Bridson 2012]</InlineCitation>. Traditionally, Cartesian grids are very popular for fluid simulations. <Cit_context CITid_9="NEUTRAL">The Marker-And-Cell (MAC) approach </Cit_context>
<InlineCitation CITid="9">[Harlow and Welch 1965]</InlineCitation>
<Cit_context CITid_9="CRITICISM">, which stores velocity components at cell faces and pressure samples at cell centers, results in discretizations with good properties in terms of stability and accuracy.</Cit_context> <Cit_context CITid_9="CRITICISM">An inherent difficulty is that simulations on regular grids become prohibitively expensive for large resolutions.</Cit_context> Thus, many works have proposed methods to focus the computations on regions that are of particular interest. One example are octrees, which were used by Losasso et al. [2004; 2005] to refine the computational grid in a controllable way. This approach, however, suffers from numerical diffusion and an inconsistent discretization near the tree’s T-junctions. <Cit_context CITid_10-11="COMPARISON">Targeting a similar direction as our work, </Cit_context>
<InlineCitation CITid="10-11">Hong et al. [2009] and Ando et al. [2012]</InlineCitation>
<Cit_context CITid_10-11="NEUTRAL"> have demonstrated methods to adapt the resolution of FLIP particles in a simulation.</Cit_context> <Cit_context CITid_10-11="COMPARISON">Both methods, in contrast to ours, focus on static computational grids and are restricted to smaller differences in particle size.</Cit_context> Although Cartesian grids are widely used, they are limited in their flexibility to adapt to a simulation setup. Because of this, tetrahedral grids are popular for methods targeting adaptivity. In combination with a suitable method to discretize the problem at hand, they allow for very flexible computational grids. <Cit_context CITid_12="NEUTRAL">One example is the work of Klingner et al. </Cit_context>
<InlineCitation CITid="12">[Klingner et al. 2006]</InlineCitation>
<Cit_context CITid_12="NEUTRAL"> which demonstrated the use of a Stable Fluids based solver for tetrahedral grids conforming to object boundaries.</Cit_context> <Cit_context CITid_13="NEUTRAL">Another example is the non-linear fluid solver developed by </Cit_context>
<InlineCitation CITid="13">Mullen et al. [2009]</InlineCitation>
<Cit_context CITid_13="NEUTRAL">, which leads to an energy conserving solve.</Cit_context> <Cit_context CITid_13="COMPARISON">Unlike these methods, we make use of a non-conforming grid with Body-Centered Cubic (BCC) lattices.</Cit_context> These meshes were also used by Chentanez et al. [2007] and by <InlineCitation CITid="15">Batty et al. [2010]</InlineCitation>
<Cit_context CITid_15="NEUTRAL"> for liquid simulations.</Cit_context> We will denote this class of algorithms as Finite Volume Methods (FVM). These methods are primarily suitable for uniformly sampled particles, and we will demonstrate in Section 7 that their placement of pressure samples at tetrahedral circumcenters leads to numerical problems in combination with graded BCC meshes. Another direction of research performs fluid simulations based on arbitrary elements. <InlineCitation CITid="16-17">Clausen et al. [2013] and Misztal et al. [2010]</InlineCitation>
<Cit_context CITid_16-17="NEUTRAL"> have proposed a method to simulate liquids with a computational grid conforming to a triangulation of a liquid surface.</Cit_context> <Cit_context CITid_16-17="CRITICISM">Both methods lead to an increased computational cost in comparison to the more efficient tetrahedral BCC meshes.</Cit_context> <InlineCitation CITid="18">Sin et al. [2009]</InlineCitation>
<Cit_context CITid_18="NEUTRAL"> proposed an alternative method for hybrid Lagrangian-Eulerian solvers which combines a Voronoi-based pressure solver and particles.</Cit_context> <Cit_context CITid_18="COMPARISON">Using this Vornoi-based approach for tetrahedral meshes would yield a pressure matrix similar to ours.</Cit_context> <Cit_context CITid_19="COMPARISON">Like our method, </Cit_context>
<InlineCitation CITid="19">Brochu et al. [2010]</InlineCitation>
<Cit_context CITid_19="NEUTRAL"> used this discretization in combination with embedded second-order boundary conditions.</Cit_context> <Cit_context CITid_19="COMPARISON">Both of these approaches discretize velocities with per-face flux values, while we store velocity vectors at cell barycenters.</Cit_context> Adaptive simulations have also been explored in the context of SPH simulations without Eulerian grids. <Cit_context CITid_20="NEUTRAL">The work of </Cit_context>
<InlineCitation CITid="20">[Adams et al. 2007]</InlineCitation>
<Cit_context CITid_20="COMPARISON"> shares similarities with our approach, as it is able to simulate a wider range of particle radii, and it proposes a surface reconstruction method in the adaptive setting.</Cit_context> <Cit_context CITid_20="COMPARISON">We will show in Section 5 that our surface creation method results in surfaces with fewer visual artifacts.</Cit_context> <Cit_context CITid_21="NEUTRAL">Additionally, a robust and efficient method for adaptive SPH simulations was introduced by </Cit_context>
<InlineCitation CITid="21">Solenthaler et al. [2011]</InlineCitation>
<Cit_context CITid_21="NEUTRAL">, but this work primarily targets the coupling of two different particle resolutions.</Cit_context> Several other methods have been proposed to reconstruct smooth surfaces around collections of particles without orientation. <Cit_context CITid_22="NEUTRAL">One approach that is commonly used is to compute a signed distance function with averaged particle radii and centroids </Cit_context>
<InlineCitation CITid="22">[Zhu and Bridson 2005]</InlineCitation>. <Cit_context CITid_23="NEUTRAL">A variant of this approach, taking into account information about the spatial variance of the particle’s neighborhood was proposed by </Cit_context>
<InlineCitation CITid="23">Yu et al. [2010]</InlineCitation>. <Cit_context CITid_23="NEUTRAL">Both methods primarily target particles with constant radius.</Cit_context> <Cit_context CITid_24="NEUTRAL">More recently, a level-set based method was proposed that computes a constrained optimization with bihar- monic smoothing </Cit_context>
<InlineCitation CITid="24">[Bhattacharya et al. 2011]</InlineCitation>. <Cit_context CITid_24="CRITICISM">However, such an optimization would be complicated to apply in our unstructured setting.</Cit_context> In contrast to these methods, our approach for surface creation computes the union of convex hulls around triplets of particles, which leads to a smooth and closed surface around a collection of arbitrarily sized particles.
      
      
        <H1>3 Fluid Solver</H1>
        The aim of our method is to solve the Navier-Stokes equations, which for incompressible, Newtonian, inviscid flows can be written as ρDu/Dt = − p + f , with the additional constraint · u = 0 to enforce a divergence-free velocity field. Here, u, p and f denote velocity, pressure and external forces, respectively, while D/Dt denotes the material derivative. The density ρ is constant in our case. <Cit_context CITid_25="USE">We solve these equations using operator splitting </Cit_context>
<InlineCitation CITid="25">[Stam 1999]</InlineCitation>, and a level set φ(x) = 0 defines the position of the liquid-gas interface. Spatial Discretization An inherent strength of the FLIP algorithm is its hybrid nature. The motion of the fluid is computed in a Lagrangian manner using particles, while the pressure projection step is computed on an Eulerian grid. We will now describe how we compute the pressure projection using a tetrahedral discretization. This projection of the velocities into a divergence-free state can be formulated as the Poisson problem
        
          1
          ∆t 2 p = · u ∗ , ρ
        
        where u ∗ denotes an intermediate velocity after the advection. <Cit_context CITid_26="COMPARISON">In the following, however, we prefer an alternate view that looks at this problem from an energy minimization perspective: we want to compute the minimal change in kinetic energy necessary to reach a divergence-free state of the flow similar to </Cit_context>
<InlineCitation CITid="26">[Batty et al. 2007]</InlineCitation>. This can be formulated as:
        
          2
          p = arg min 1 ||u ∗ − ∆t p|| 2 ρdV p Ω 2 ρ
        
        Here, Ω represents the domain of the computational grid, and we choose to discretize this space using tetrahedral cells. This has the advantage of giving us a natural way to handle cells of different size, while yielding a consistent discretization of the differential operators involved. We store pressure samples at the nodes of the tetrahedral mesh, while velocities are stored at cell centers. This configuration is illustrated in Figure 2 . Note that by assuming a piece-wise constant velocity and a linear change of pressure within a cell, this setup results in a constant pressure gradient per tetrahedron, by construction. In the following, we denote the number of cells with m and the number of nodes with n, and we indicate discretized quantities with caret notation. Based on this representation we can discretize Eq. (2) with
        
          3
          m p = arg min 1 || u ˆ i ∗ − ∆t [ ] p|| 2 ρV i , p ˆ 2 ρ i
        
        where we denote the volume of a cell with V i and the discretized gradient operator with [ ]. It consists of a m×n matrix, computing a per-tetrahedron gradient from nodal values. Consequently, we define the divergence operator to be the transpose of the discretized gradient. Before we go ahead to define [ ], we want to outline the rest of the steps for our pressure solve. We solve equation Eq. (3) with the commonly used least squares technique, yielding
        
          4
          ∆t T T ∗ [ ] V [ ] p = [ ] V u ˆ , ρ
        
        
          
          
          
          Figure 2:
        
        Our discretization compared to previous approaches: the MAC grid stores velocity components normal to faces and pressure values at the center. The FVM discretizations follow along these lines and store velocities normal to faces and pressure values at the circumcenter of a cell. In our approach we store a 3component velocity vector at the barycenter of a cell and pressure values at each node.
        where V denotes a matrix containing the V i as diagonal entries. The [ ] T [ ] matrix-matrix multiplication results in a square n × n matrix, which is symmetric and positive definite. In the following, we will denote the matrix on the left hand side of Eq. <Cit_context CITid_27="USE">(4) as A. Given appropriate boundary conditions, we can use standard tools, such as a commonly used pre-conditioned conjugate gradient solver to compute a solution (we use the one suggested in </Cit_context>
<InlineCitation CITid="27">[Bridson 2008]</InlineCitation>). Now, all that is left to construct the left-hand side matrix and the right-hand side terms for Eq. (4) is to define [ ]. As we assume a linear change of the pressure for each cell, we can use simple barycentric interpolation to retrieve the pressure p at a position inside a cell. Given the nodal pressure values p 1..4 and barycentric weights σ 1..4 this means p = σ 1 p 1 + σ 2 p 2 + σ 3 p 3 + σ 4 p 4 . In line with finite element methods using linear elements, we define the gradient based on the partial derivatives of the barycentric interpolation. E.g., the first component of the gradient for a cell is computed with
        
          5
          ∂ ∂σ 1 ∂σ 2 ∂σ 3 ∂σ 4 p = p 1 + p 2 + p 3 + p 4 . ∂x ∂x ∂x ∂x ∂x
        
        To set up the final linear system of Eq. (4) for the pressure solve, we loop over all tetrahedra to compute the derivatives of the barycentric interpolation, adding their contributions to the global matrix. In contrast to previous work, our pressure solve is a linear system that has n degrees of freedom, n being the number of nodes in the tetrahedral mesh. For our BCC mesh, n is in practice smaller than the number of tetrahedra m (by a factor of 6 on average). A direct implication of this smaller linear system is that it is faster to solve. A second, less obvious implication of the smaller linear system is that it effectively prevents artifacts known as locking. These artifacts are commonly observed in finite element methods for problems in elasticity. <Cit_context CITid_28="NEUTRAL">Different methods have been proposed to circumvent these problems, e.g., using linear elements for pressure instead of piece-wise constant ones </Cit_context>
<InlineCitation CITid="28">[Irving et al. 2007]</InlineCitation>. <Cit_context CITid_29="NEUTRAL">Other works explicitly smooth the pressure field to reduce locking problems </Cit_context>
<InlineCitation CITid="29">[Misztal et al. 2010]</InlineCitation>. <Cit_context CITid_29="NEUTRAL">In general, locking can be observed if the pressure basis can represent more, and higher-frequency, functions than the basis for the velocity.</Cit_context> <Cit_context CITid_31="NEUTRAL">
<Cit_context CITid_30="NEUTRAL">Thus, choosing a more restrictive basis for pressure, as in </Cit_context>
<InlineCitation CITid="30">[Irving et al. 2007]</InlineCitation>, or explicitly removing high-frequency information from the pressure </Cit_context>
<InlineCitation CITid="31">[Misztal et al. 2010]</InlineCitation>
<Cit_context CITid_31="CRITICISM">, reduces the chance of locking.</Cit_context> Our method, by construction, has more degrees of freedom for representing velocity fields than pressure fields. Although we cannot prove that a local configuration over-constraining the velocities will never occur, the larger number of degrees of freedom for our velocities effectively prevents locking artifacts, and we have not encountered any in our tests. Boundary Conditions Second-order boundary conditions are a central component for accurate and visually appealing simulations with non-conforming grids. <Cit_context CITid_32="BASIS">Achieving second-order accuracy for obstacle boundary conditions is straightforward with our discretization: we can rely on the formulation of previous work </Cit_context>
<InlineCitation CITid="32">[Batty et al. 2007]</InlineCitation>, and set the volume of a cell V i in Eq. (4) to the volume that is filled with fluid. For the free surface, we have to ensure that the Dirichlet boundary condition p = 0 is satisfied at the interface position. <Cit_context CITid_33-34="NEUTRAL">Usually, this means computing a pressure value for nodes outside of the liquid so that a linear interpolation along an edge of a cell gives zero at the correct position </Cit_context>
<InlineCitation CITid="33-34">[Enright et al. 2005; Lew and Buscaglia 2008]</InlineCitation>. Considering two pressure samples along an edge, we’ll denote values inside the air with a G subscript, and values inside the liquid with an L subscript in the following. For a Cartesian MAC grid, the ghost pressure value p G is given by p G = p L φ G /φ L . In our case, however, this approach does not yield the desired result. The reason is that our velocity samples are not in line with the direct connections of the pressure samples – they are not locally orthogonal to each other. Instead, we have to ensure the boundary conditions result in the correct pressure value at the cell center. In the following we will show how to derive suitable free-surface boundary conditions to ensure second-order accuracy within our framework. In order to achieve accurate and smooth surface motions with our method, we compute the ghost pressure values p G with a linear combination of liquid pressure values as:
        
          6
          p G = w 1 p 1 + w 2 p 2 + w 3 p 3 ,
        
        where w n and p n denote unknown coefficients and adjacent liquid pressures in the same tetrahedron. Note that for p i that are not inside of the liquid, we set w i = 0. In line with the traditional ghost fluid method, we define p G uniquely for each tetrahedron. To handle the most general case, let’s suppose that p 1..3 are all liquid pressure values. Once we have a value for p G , we can compute a pressure gradient for the tetrahedron and update the velocity at its center with:
        
          7
          u ˆ new = u ˆ ∗ − ∆t [ ] p G p 1 p 2 p 3 T ρ
        
        In order to do this we need to compute the coefficients w n . p G can be rewritten in terms of a barycentric interpolation of the three values in the liquid as:
        
          8
          p G = p L φ G / φ  ̃ L
        
        with φ  ̃ L = θ 1 φ 1 + θ 2 φ 2 + θ 3 φ 3 , and p L = θ 1 p 1 + θ 2 p 2 + θ 3 p 3 . Here the θ n are a set of barycentric coordinate coefficients such that θ 1 +θ 2 +θ 3 = 1, and a tilde superscript denotes a value interpolated with the barycentric weights. Substituting Eq.8 into Eq.6 yields
        
          9
          w n = θ n φ G / φ  ̃ L .
        
        That means the values w n are determined by those of the θ n coefficients, which we will compute in the following. Note that, theoretically, θ n could take any values as long as they add up to one. Before embedding the boundary conditions, the matrix entries of the pressure solve for a single tetrahedron are, according to Eq. (4), given by ∆t [ ] T V [ ]p = b. The computation of the ghost fluid ρ values is independent of the right-hand side b, so we will restrict the discussion to the left hand side. We denote the components of the local symmetric 4 × 4 matrix on the left hand side with:  λ 1 α β γ 
        
          10
          α λ 2 a b    β a λ 3 c  γ b c λ 4
        
        Assuming, without loss of generality, that the first vertex is the one outside of the liquid volume, we embed the boundary condition into
        M based on the w n coefficients. Then the first row of the system is changed to:
        
          11
           1 −w 1 −w 2 −w 3   p G   0  α λ 2 a b p 1 b 1     =   .  β a λ 3 c   p 2   b 2  γ b c λ 4 p 3 b 3
        
        We can extract two constraints for each θ n from this form, which, together with the barycentric coefficient constraint, give us a 3 × 3 matrix M that can be inverted analytically. A full derivation of these steps can be found in Appendix A. With this analytic expression we can compute the ghost pressure coefficients as:
        
          12
          φ G / φ  ̃ L  α  w = α + β + γ  β γ 
        
        This boundary condition ensures second-order accuracy while maintaining symmetry when it is assembled into the matrix of Eq. (4). If the quality of a tetrahedron is good, 0 &lt; θ n &lt; 1 is guaranteed. In this case, the resulting matrix is symmetric positivedefinite and can be easily inverted by the commonly used preconditioned conjugate gradient methods. However, positive off-diagonal terms of the matrix can result in values of θ outside of the range [0, 1], leading to an indefinite linear system. In these cases we consider the tetrahedron to have a poor quality. When using ghost fluid boundary conditions with a regular MAC grid, it is common practice to clamp small values in the denominator of Eq. (9) to prevent ill-conditioned pressure matrices. Effectively, this means reverting to first-order accuracy when second-order accuracy is intractable. We implement a similar step in our algorithm to overcome numerical problems resulting from badly shaped cells. We check whether the ghost fluid boundary conditions would violate diagonal dominance of an equation in our linear system. If we detect such a case, we smoothly transition to first order accuracy. Specifically, when we have computed M , we check if a resulting diagonal term M i,i is smaller than φλ 2..4 . Here, φ denotes a tolerance factor that we set to φ = 0.25. Whenever we detect such a case, we compute a coefficient k with
        
          13
          φ − 1 φ − 1 φ − 1 k = min λ 2 , λ 3 , λ 4 , w 2 α w 3 β w 4 γ
        
        and multiply each w n with k when embedding. Note that this scaling does not break the symmetry of the resulting linear system. More specifically, for k = 1 this yields full second-order accuracy, while for badly shaped tetrahedra the resulting k = 0 means that we revert to the standard rounding strategy of a first order accurate method. With our BCC mesh, all regular BCC tetrahedra have very good quality and valid θ n values. The graded BCC tetrahedra, on the other hand, can be of lower quality and can require the use of Eq. (13). Luckily, in our tests these tetrahedra make up only a very small fraction of the mesh. Velocity Interpolation The FLIP advection step traces particles based on the velocities from the Eulerian grid. For this we need to construct a continuous velocity field based on the discrete values in our tetrahedral mesh. <Cit_context CITid_35="NEUTRAL">As we store velocities at the cell centers, the interpolation would ideally use the dual mesh consisting of the Voronoi cells of each node </Cit_context>
<InlineCitation CITid="35">[Brochu et al. 2010]</InlineCitation>. Unfortunately, performing interpolations within arbitrary Voronoi cells would be expensive and require a large amount of computation compared to the other steps of our simulator. <Cit_context CITid_36="COMPARISON">Instead, we have found the following approach to yield high speed and good accuracy: we first interpolate the centered velocities to the nodes, similar to </Cit_context>
<InlineCitation CITid="36">[Chentanez et al. 2007]</InlineCitation>. Instead of interpolating these averaged values directly (which would result in smeared out motion), we temporarily subdivide the cells of our mesh by inserting a vertex at the center where we have an accurate velocity sample. We then perform barycentric interpolation based on these subdivided cells, ensuring a C 0 continuous velocity that retains the original velocities at cell centers. Note that these four smaller tetrahedra do not have to be stored explicitly. We construct them on the fly when a sample is requested from one of the original cells. Manipulating FLIP particles The spacing between FLIP particles may drift over time, and high-frequency errors may contribute to a bumpy surface. We combat these problems by directly manipulating particle positions. <Cit_context CITid_37="USE">During each time step, we apply the position correction algorithm of </Cit_context>
<InlineCitation CITid="37">Ando et al. [2012]</InlineCitation>
<Cit_context CITid_37="NEUTRAL">; this algorithm essentially pushes each particle away from its neighbors to prevent clustering.</Cit_context> We also introduce two special behaviors when the particles are close to the liquid surface (less than a distance of six times the particle radius). First, we impose the constraint that the position correction step may only move particles near the surface tangentially to the fluid interface. Secondly, particles near the surface may leave gaps when they spread out quickly. Our method naturally fills in these gaps by slightly pulling each particle towards the fluid interface. For particles near the interface, this pulling force acts in addition to the position correction. FLIP particles that partake in splashes and sprays can pose a significant burden on computational resources, especially in an adaptive framework like ours. This inefficiency stems from the fact that water droplets undergo extremely simple ballistic motion. Theoretically, we know that such a small region with purely free-surface boundary conditions will yield zero internal forces, so we simply detect individual FLIP particles that have no neighbors within six times their radius, remove them from the pressure solve, and accelerate them with gravity instead. When these particles eventually enter the neighborhood of other particles at some point in the future, we resume treating them like fluid by returning them to the pressure solve. This decision allows us to avoid aggressively refining the tetrahedral mesh in locations where the physical motion is uninteresting. Only a small percentage of the particles are simulated in this way, e.g., 1.7% on average for Figure 6 .
        
          
          Figure 3: A simple geometric setup creating a big splash inside a container. This simulation, with a maximum resolution of 256 cells, took 1.3 minutes per frame on average.
        
      
      
        <H1>4 Adaptivity</H1>
        Our method achieves adaptivity by varying the mesh resolution over the computational domain. Our FLIP simulation performs computation on both a background volumetric mesh and on a set of particles. Given a sizing function that indicates the desired spatial level of detail, our method first creates a tetrahedral mesh with varying spatial resolution, and then it locally changes the particle density by splitting and merging operations. To compute the spatially-varying background grid, we start with the Delaunay tetrahedralization of a set of points distributed in a body-centered cubic lattice configuration. <Cit_context CITid_39-40-41="USE">
<Cit_context CITid_38="USE">In order to make the mesh resolution change over space, we use the octree-based grading method which was proposed by </Cit_context>
<InlineCitation CITid="38">Labelle and Shewchuk [2007]</InlineCitation> and later adopted in several adaptive simulation environments </Cit_context>
<InlineCitation CITid="39-40-41">[Chentanez et al. 2007; Wojtan and Turk 2008; Batty et al. 2010]</InlineCitation>. <Cit_context CITid_42="COMPARISON">Similar to </Cit_context>
<InlineCitation CITid="42">[Batty et al. 2010]</InlineCitation>
<Cit_context CITid_42="COMPARISON">, we generate a new tetrahedral mesh every ten time steps, instead of rebuilding the mesh on every consecutive step.</Cit_context> Also, the tetrahedral mesh is only temporarily used for the pressure solver, so no information is transferred from one time step to the next by storing it on the grid. Thus, we do not worry about re-sampling data when computing a new tetrahedral mesh. We change the size and number of particles in our simulation with splitting and merging operations. <Cit_context CITid_43="BASIS">For this, we modify the strategy of </Cit_context>
<InlineCitation CITid="43">Ando et al. [2012]</InlineCitation> to work within our framework: at each remeshing step, we loop through the particles and determine whether the resolution needs to be changed. If a particle is too small, then we merge it with its nearest neighboring particle, resulting in a particle whose radius is given by the combined volume of the two original particles. If a given particle is bigger than the desired size, then the particle is split in two. The two new particles are placed randomly within the original particle’s radius and redistributed with a heuristic that attempts to fill in nearby gaps: We first compute the 24 midpoints m i between this particle and its 24 nearest neighbors. Then we find the closest particle to each midpoint and store the squared distance as a weight ω i . The new particle’s position is equal to the weighted average of all nearby midpoints: x new = ω i m i / ω i . After a split or merge operation, the new particle’s velocity is computed using a volume-weighted average. Also, we must take care to ensure that particles close to the surface do not introduce interfacial bumps when they split or merge; whenever we create a new particle that is less than 1.25 times its radius away from the surface (through either a split or a merge event), we move it in the surface normal direction such that its sphere lies exactly tangent to the liquid interface. Numerical viscosity in fluid simulations is tightly coupled to the spatial resolution resolving the flow. <Cit_context CITid_44="NEUTRAL">We compensate for spatiallyvarying numerical viscosity caused by particles of various sizes in our simulation by adjusting the PIC/FLIP blending parameter in our FLIP simulation </Cit_context>
<InlineCitation CITid="44">[Bridson 2008]</InlineCitation>. Given quantities Q i,PIC and Q i,FLIP computed at particle i from PIC and FLIP simulations, respectively, the new quantity Q i is computed as a weighted blend between the two:
        
          
          Figure 4: For the perfectly planar particle placement shown in (a), the methods [Zhu and Bridson 2005] (b), [Yu and Turk 2010] (c), and [Adams et al. 2007] (d) do not result in a flat surface, while our method produces the desired result (e).
        
        
          14
          ν∆t ν∆t Q i = r i 2 Q i,PIC + (1 − r i 2 )Q i,FLIP
        
        where r i is the radius of particle i and ν is the viscosity of the flow. We found that this strategy adequately eliminates any artifacts due to spatially varying numerical viscosity. Sizing Functions We define the level of detail in our simulations with a spatially varying sizing function S(x). We have experimented with several different sizing functions depending on factors such as distance to a camera, distance to the liquid surface, curvature of the liquid surface, measures of fluid turbulence, and arbitrary analytical number fields. Our simulator is versatile enough to cope with any of these sizing functions, resulting in efficient simulations with highly variable levels of detail. E.g., Figure 1 showcases a simulation where smallest and largest cells differ by a factor of 128. In all of the examples in this paper, the sizing function is defined as a combination of five different metrics:
        
          15
          S(x) = max ( d(x), V (x, min(κ liquid (x), κ solid (x), e(x)) )
        
        where x is the position of a point in space, and d(x) encodes the depth of the liquid by returning the absolute level set value of the liquid surface. This has the effect that motion near the surface has higher priority than motions far inside the bulk volume of the liquid. V (x, y) is a view-dependent function that returns the value y if x is within the camera’s visible region and returns the maximum particle radius r max (representing the minimum surface resolution) otherwise. The next two metrics are designed to prioritize geometric detail of the liquid surface and of obstacles by computing a desired resolution based on cuvature. κ liquid (x) returns 0.8 divided by the extrapolated curvature of the liquid interface. Similarly, κ solid (x) returns 1.6 W smooth (d solid , r max ) divided by the extrapolated curvature of the solid interface, where W smooth (x, h) is a smooth kernel function (1 − ||x|| 2 /h 2 ) 3 and d solid is the closest distance to the solid boundary. As a last component of our sizing function we found it beneficial to invest computational resources into keeping interesting motion of the flow field alive. <Cit_context CITid_48="BASIS">Inspired by turbulence models (used e.g. in </Cit_context>
<InlineCitation CITid="48">[Pfaff et al. 2010]</InlineCitation>), we have found that the strain tensor of the flow field reliably indicates detailed motions, and we compute e(x) as 30 divided by the Frobenius norm of the fluid strain tensor computed from the velocity field.
      
      
        <H1>5 Surface Representation</H1>
        We also introduce a new method for computing an implicit surface from a set of particles. Given our set of FLIP particles with variable radii, we aim to implicitly represent the fluid surface by computing its signed distance function. <Cit_context CITid_49-50-51="NEUTRAL">Several useful methods for computing a surface from a collection of particles have been proposed in the past </Cit_context>
<InlineCitation CITid="49-50-51">[Zhu and Bridson 2005; Adams et al. 2007; Yu and Turk 2010]</InlineCitation>
<Cit_context CITid_49-50-51="CRITICISM">, but they tend to produce undesirably bumpy surfaces when considering particles of highly variable radii ( Figure 4 ).</Cit_context> In this section, we introduce a new strategy for computing an implicit surface from a set of particles of various sizes. The main idea is to approximate the fluid surface with the union of the convex hulls of each triplet of nearby particles close to the surface. For each set of three FLIP particles near the surface, the convex hull forms a thickened triangle shape with rounded edges ( Figure 5 ). We only consider particles that are less than a given distance apart, with the maximum distance equal to a constant scale factor l times the sum of the two particle radii. A small l shows more surface details, while a larger l tends to fill in small concavities. We used l = 2 for most of the simulations in this paper. We ultimately represent our surface as the union of all such local convex hull shapes, and the minimum signed distance from these shapes to a point in space defines the outer part of our level set function. In practice, we compute the local convex hull by finding the two outermost planes tangent to a set of three spheres. We efficiently compute the distance to these planes by analytically solving the polynomial system: ax 1 +by 1 +cz 1 +d = r 1 , ax 2 +by 2 +cz 2 +d = r 2 , ax 3 + by 3 + cz 3 + d = r 3 , a 2 + b 2 + c 2 = 1 . where r i and x i , y i , z i are the radius and x, y, z coordinates of particle i, respectively. a, b, c, d are the variables defining our plane with the signed distance function ax + by + cz + d = 0. Intuitively, the first three equations ensure that the plane is the right distance away from each particle with the normal facing away from them, and the final equation ensures that the plane equation is normalized to a distance function. These four equations represent the intersection of three hyperplanes and a hypercylinder in 4D {a, b, c, d} space. We solve this system analytically by first finding the line of common intersection of the first three equations, and then intersecting this line with the cylinder represented by the final equation. The system has two solutions, representing the top and bottom planes of our convex hull shape. The above calculation describes how to find the planar regions of the convex hull of a set of three spheres. By computing the conic and spherical convex hull facets ( Figure 5 , bottom right) in a similar fashion, we can easily compute the signed distance between this convex hull and a point in space. To evaluate our final level set value, we compute the minimum signed distance from a query point to all nearby convex hulls. We evaluate the level set on each of the vertices of our adaptive BCC mesh, and we extract a triangle mesh using a marching tetrahedra algorithm. We then perform a light mesh smoothing to increase the reliability of any curvature computations. The algorithm as described works perfectly for computing the level set outside of our particle surface, but it may lead to small gaps inside. To avoid the creation of holes, we temporarily reassign each particle’s radius: r i temp = max(r i , −kφ i ) where φ i is the particle’s stored level set value from the previous time step, and k is a constant set to 0.75 in our simulations. Using this temporary radius to compute the signed distance as described above will remove erroneous gaps inside the liquid. We need to compute liquid surfaces both for final visualization as well as for several calculations during the progress of our simulation. For the final visualization, we compute an especially highresolution BCC mesh from all of our particles and proceed with the algorithm above. The final surface creation is trivially parallelized, and takes around five minutes average per frame for all of our simulations. We attempt to speed up the surface creation routine used for simulation computations by computing on the moderate-resolution BCC mesh used for simulation and ignoring ballistic particles (Section 3). We compare our surface creation routine with a few existing methods in Figure 4 . Most previous algorithms perform poorly in this comparison because they were not designed for particles with varying radii.
        
          
          Figure 5: The 2D version of our surface creation algorithm takes a pair of particles (top left) and computes their convex hull (bottom left). In 3D, we convert three nearby particles (top right) into a convex hull (bottom right) consisting of spherical (orange), conic (dark blue), and planar (light blue) segments.
        
      
      
        <H1>6 Implementation</H1>
        At this point we have described all of the components of our simulator. The resulting algorithm can be seen in Algorithm 1. In the beginning of each step (line 2), we typically compute the level-set for the current particle configuration as described in Section 5. We require the distance to the surface in several steps of our algorithm, so we store the level set values for each particle (line 3). When enough time has passed to trigger an update of the mesh, it becomes necessary to evaluate the sizing function. At this point, additional user-defined sizing functions could be computed as well. Having the information from the sizing functions ready, we create a new BCC mesh and perform particle merging and splitting. For mapping the particle velocities onto the grid (line 9) we use an SPH-like kernel function, which is weighted by the particle volume: max(v i (4r i 2 /d 2 − 1), 0), where v i is the particle volume and d is
        Algorithm 1: One step of our simulation algorithm. 1 begin 2 Compute simulation surface S 3 Pre-compute φ for all particles 4 Correct particle positions x i 5 if Mesh update necessary then 6 Evaluate sizing function S(x) at x i 7 Build octree and BCC mesh 8 Merge and split particles 9 Compute mesh velocity u from particle velocities 10 Extrapolate u outside the liquid 11 Solve pressure p on the tetrahedral mesh, update u 12 Update particle velocities with gradient of p 13 Advect particles with u
        the distance to the particle center normalized with its radius. The particle velocity update of line 12 uses barycentric interpolations as explained in Section 3. Likewise, the grid-based velocity extrapolation of line 10 uses the nodal velocities of Section 3. A time step is completed by performing the pressure projection and advecting the particles in the resulting divergence-free velocity field.
      
      
        <H1>7 Results and Discussion</H1>
        To evaluate the performance and robustness of our method in comparison to previous work we have performed an extensive series of tests. A selection of these can be found in the accompanying comparison video. One comparison that is particularly interesting is the one comparing our method to an FVM based simulation. Using a graded BCC mesh leads to problems with the latter, as the position of the circumcenter lies exactly on a face for the graded tetrahedrons. In the graded region, this can result in two pressure samples from adjacent tetrahedra being placed at the exact same position. <Cit_context CITid_52="NEUTRAL">To alleviate this problem, </Cit_context>
<InlineCitation CITid="52">[Batty et al. 2010]</InlineCitation>
<Cit_context CITid_52="NEUTRAL"> propose to slightly offset the pressure samples from the faces.</Cit_context> <Cit_context CITid_52="CRITICISM">However, our implementation of their method exhibited slow convergence and the velocity artifacts despite this fix.</Cit_context> The influence of the different components of our sizing function on the evolution of a simulation is difficult to depict with static images, so we refer to the accompanying video for a comparison. To evaluate the basis of our adaptive model without any influence of the camera dependent sizing function, we have simulated the simple geometric configuration shown in Figure 3 . For this setup, resolutions from 8 to 256 were used, resulting in 6 levels of adaptivity. Timing information for the main steps of our algorithm over the course of this simulation can be found in Figure 8 and Figure 9 . For this simulation, the initial configuration consisted of 168, 161 particles, and momentarily peaked up to 1, 048, 776 during the maximal extent of the splash (settling down again to around 250 thousand in the end). Note that a full sampling of the initial configuration with a regular grid would have required approximately 6 million particles. Our measurements show that the run-time of our method has a strong linear relationship to the number of particles, and thus the visual complexity of the simulation. The per-frame time is low at the beginning and end of the simulation, but strongly peaks during the complex splash in its middle. Our visibility sizing function is highlighted by the setup shown in Figure 6 . Here the computational resources are focused on the visible region of a rotating camera, as the liquid splashes around a U-shaped corridor. Our solver efficiently resolves the complex motion near the camera, while effectively reducing the computational cost for parts that are not visible. The simulation of Figure 7 shows
        
          
          Figure 6: Our visibility sizing function: as the liquid flows along the U-shaped corridor, the visible volume is simulated with a high resolution (surface shown in top row), while regions outside of the view frustrum are coarsened (particle view in bottom row).
        
        
          
             Setup Min. ∆x −1 Min. ∆x s −1 Max. ∆x −1 Duration frames
            
              
              
                
                   Figure 3
                   8
                   16
                   256
                   5h:09m
                   240
                
                
                   Figure 6
                   16
                   32
                   256
                   4h:26m
                   330
                
                
                   Figure 7
                   16
                   64
                   512
                   5h:55m
                   480
                
                
                   Figure 1
                   8
                   32
                   1024
                   12h:8m
                   160
                
              
            
          
          Setup Min. ∆x −1 Min. ∆x −1 s Max. ∆x −1 Duration frames Figure 3 8 16 256 5h:09m 240 Figure 6 16 32 256 4h:26m 330 Figure 7 16 64 512 5h:55m 480 Figure 1 8 32 1024 12h:8m 160
          Table 1: Resolutions and running times for our simulations (not including final surface creation). Here, ∆x −1 and ∆x −1 s denote the
        
        number of BCC cells along one spatial axis for the simulation and for the surface generation, respectively. The simulations were run on a workstation with an Intel Core i7-3960X CPU with 3.30GHz running under Linux.
        a liquid interacting with a highly detailed obstacle. The κ solid component of our sizing function ensures that geometrically complex regions near the obstacle are simulated with higher accuracy. In this way, we can resolve the detailed flow of liquid through the holes in the obstacle. Figure 1 shows a situation that would be challenging to simulate with a regular solver. Without adaptivity, the large open liquid surface with complex splashes in a localized region would require huge amounts of computational resources. Our method can simulate this setup very efficiently, and in a fully coupled manner with an effective high resolution. The large open region is successfully coarsened by our sizing function, resulting in subtle wave motions around the splashes. In this case, the whole simulation with 8 different octree levels and a maximum resolution of up to 1024 cells took on average only 4.6 minutes per frame to compute. Just to illustrate the amount of detail in this setup – our adaptive version initially used 1.7 million particles, while a regular sampling at the finest resolution would have required roughly 400 million. Further runtime and resolution details for our simulations can be found in Table 1 . Discussion We found our discretization (Section 3) beneficial in a number of ways. We store the pressure variables on tetrahedral vertices, and there are far fewer vertices than tetrahedra in a given mesh. Consequently, the pressure solve has fewer variables and is faster to solve. Also, by counting degrees of freedom and constraints, we can see that our discretization prevents the locking ar- tifacts which are common in other methods. However, the lower number of pressure constraints also implies that the highest frequencies of the velocity field may be unconstrained. In our case a regularization via PIC interpolation acts to diminish any highfrequency artifacts. Our method uses a FLIP scheme instead of a purely Eulerian method. We store all physical variables on the FLIP particles, so information is carried from one time step to the next in a Lagrangian manner. As a result, we are allowed to aggressively remesh the tetrahedral background grid without worrying about excessive damping or re-sampling artifacts. On the other hand, FLIP simulations have a well-known problem of creating noisy particle distributions, because there are typically several times more particles than velocity variables on the background grid. We utilize particle repositioning to improve the distribution quality, at the expense of slight inaccuracies due to displacing physical variables. We noticed that our new surface creation routine is essential for maintaining detailed simulations in the presence of accurate freesurface boundary conditions. One major benefit of our method is that it can easily create perfectly flat surfaces from a mixture of differently-sized particles. These flat surfaces represent the equilibrium state of a fluid simulation, so our animations are able to smoothly settle down as time progresses. Without a method for accurately reproducing flat surfaces, second-order boundary conditions will introduce additional forces in the locations of surface bumps, which artificially prevent a simulation from settling down. While we believe that our surface creation routine is indispensable, it is quite expensive to compute. In the future we would like to optimize the surface computation. Our simulations perform quite well for large differences in resolutions, but we have only been able to push them to a certain point in our current implementation. We found that using too sharp of a grading in our sizing function can place coarse and fine simulation elements too close together and potentially result in artifacts. For example, when small particles land in very coarse cells after violent splashes, these particles can get stuck in mid air. Occasionally, this can also lead to an overly strong weight for such particles during the velocity mapping, resulting in momentum artifacts. Our adaptive numerical viscosity in Eq. (14) can also exhibit dangerously small damping values for very fine resolutions, so we clamped the blending coefficient to a minimum value of 0.1 in Figure 1 . In Section 4 we introduced a novel collection of sizing functions for adaptively selecting details from a fluid simulation. While we presented specific parameters for the sake of reproducibility, these values were not meticulously tuned and are certainly not optimal. The task of choosing an ideal sizing function is still an open problem that we are interested in pursuing in the future. In particular, we are interested in taking more temporal information into account. This could lead to more gradual changes in resolution, at the expense of a slightly higher particle count.
        
          Figure 8: This graph shows durations for the different parts of our algorithm over the course of the simulation from Figure 3 . Note that we only include the computationally more expensive steps here, and not the re-meshing (which is done in intervals).
        
        
          Figure 9: The time required for our re-meshing and particle merging &amp; splitting computations over time for Figure 3 . Note that we perform them only every ten simulation steps.
        
        
          
          Figure 7: A simulation of detailed flow through a complex obstacle. The liquid correctly flows through the orifices at the center of the filigree.
        
      
      
        <H1>8 Conclusions and Outlook</H1>
        We have presented a novel framework for highly adaptive liquid simulation. In our method, a novel, robust discretization works together with accurate embedded boundary conditions and a flexible sizing function to allow for aggressive adaptivity and high computational performance. In this way, we can efficiently compute tough simulation setups, such as large surfaces with very localized details. We have additionally presented a novel surface creation method that yields smooth surfaces in the presence of strongly varying particle radii, which turned out to be an important building block for our framework. We chose a BCC mesh generation because it is, to the best of our knowledge, the fastest way to generate high-quality meshes. However, despite its efficiency, mesh generation is still a bottleneck for our simulation. This is partly due to the fact that it is a mostly serial operation that is difficult to parallelize (most other steps of our algorithm parallelize easily). So, instead of computing the mesh from scratch each time, we are interested in exploring techniques for continuous re-meshing. Also, our choice of piece-wise constant basis functions for velocity indicates that our discretization could lead to difficulties when it is used for diffusion or viscosity solves. It will be interesting to see how these could be incorporated into our framework. Finally, we are highly interested in applying our method to other types of phenomena, such as smoke and fire simulations, or visco-elastic materials. It will be very interesting to leverage the benefits of our framework for extreme adaptivity in these situations.
      
      
        <H1>Acknowledgements</H1>
        We would like to thank the anonymous reviewers for their helpful feedback. We also wish to thank Reiji Tsuruno for providing us with computational resources, and Pascal Clausen as well as Ramprasad Sampath for constructive discussions. This work was supported by the Japan Society for the Promotion of Science (JSPS). Finally, we would like to express our gratitude to the authors of the ANN library, which we use for kd-tree look-ups, and to the Mitsuba renderer, which we have used to render all images in this paper.
      
      
        <H1>References</H1>
        
          A DAMS , B., P AULY , M., K EISER , R., AND G UIBAS , L. J. 2007. Adaptively sampled particle fluids. In ACM SIGGRAPH 2007 papers, 48.
          A NDO , R., T HUEREY , N., AND T SURUNO , R. 2012. Preserving Fluid Sheets with Adaptively Sampled Anisotropic Particles. IEEE Transactions on Visualization and Computer Graphics 18 (8), 1202–1214.
          B ATTY , C., AND B RIDSON , R. 2008. Accurate viscous free surfaces for buckling, coiling, and rotating liquids. In Proceedings of the 2008 ACM/Eurographics Symposium on Computer Animation, 219–228.
          B ATTY , C., B ERTAILS , F., AND B RIDSON , R. 2007. A fast variational framework for accurate solid-fluid coupling. ACM Trans. Graph. 26, 3 (July).
          B ATTY , C., X ENOS , S., AND H OUSTON , B. 2010. Tetrahedral embedded boundary methods for accurate and flexible adaptive fluids. In Proceedings of Eurographics.
          B HATTACHARYA , H., G AO , Y., AND B ARGTEIL , A. W. 2011. A level-set method for skinning animated particle data. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          B OYD , L., AND B RIDSON , R. 2012. Multiflip for energetic twophase fluid simulation. ACM Trans. Graph. 31, 2, 16:1–16:12.
          B RIDSON , R. 2008. Fluid Simulation for Computer Graphics. AK Peters/CRC Press.
          B ROCHU , T., B ATTY , C., AND B RIDSON , R. 2010. Matching fluid simulation elements to surface geometry and topology. ACM Trans. Graph. 29, 4 (July), 47:1–47:9.
          C HENTANEZ , N., F ELDMAN , B. E., L ABELLE , F., O’B RIEN , J. F., AND S HEWCHUK , J. R. 2007. Liquid simulation on lattice-based tetrahedral meshes. In Proceedings of the 2007 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 219–228.
          C LAUSEN , P., W ICKE , M., S HEWCHUK , J., AND O’B RIEN , J. 2013. Simulating liquids and solid-liquid interactions with Lagrangian meshes. ACM Trans. Graph..
          E NRIGHT , D., N GUYEN , D., G IBOU , F., AND F EDKIW , R. 2003. Using the Particle Level Set Method and a Second Order Accurate Pressure Boundary Condition for Free-Surface Flows. Proc. of the 4th ASME-JSME Joint Fluids Engineering Conference.
          E NRIGHT , D., L OSASSO , F., AND F EDKIW , R. 2005. A fast and accurate semi-Lagrangian particle level set method. Comput. Struct. 83, 6-7, 479–490.
          H ARLOW , F., AND W ELCH , E. 1965. Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. Phys. Fluids 8 (12), 2182–2189.
          H ONG , W., H OUSE , D. H., AND K EYSER , J. 2009. An adaptive sampling approach to incompressible particle-based fluid. In TPCG, Eurographics Association, W. Tang and J. P. Collomosse, Eds., 69–76.
          I RVING , G., S CHROEDER , C., AND F EDKIW , R. 2007. Volume conserving finite element simulations of deformable models. ACM Trans. Graph. 26, 3 (July).
          K LINGNER , B. M., F ELDMAN , B. E., C HENTANEZ , N., AND O’B RIEN , J. F. 2006. Fluid animation with dynamic meshes. ACM Trans. Graph. 25, 3, 820–825.
          L ABELLE , F., AND S HEWCHUK , J. R. 2007. Isosurface stuffing: Fast tetrahedral meshes with good dihedral angles. ACM Trans. Graph. 26, 3 (July).
          L EW , A. J., AND B USCAGLIA , G. C. 2008. A discontinuousgalerkin-based immersed boundary method. International Journal for Numerical Methods in Engineering 76, 4, 427–454.
          L OSASSO , F., G IBOU , F., AND F EDKIW , R. 2004. Simulating water and smoke with an octree data structure. ACM Trans. Graph. 23, 3 (Aug.), 457–462.
          L OSASSO , F., F EDKIW , R., AND O SHER , S. 2005. Spatially adaptive techniques for level set methods and incompressible flow. Computers and Fluids 35, 2006.
          M ISZTAL , M. K., B RIDSON , R., E RLEBEN , K., B ÆRENTZEN , J. A., AND A NTON , F. 2010. Optimization-based fluid simulation on unstructured meshes. In VRIPHYS, Eurographics Association, 11–20.
          M ULLEN , P., C RANE , K., P AVLOV , D., T ONG , Y., AND D ES BRUN , M. 2009. Energy-preserving integrators for fluid animation. ACM Trans. Graph. 28 (July), 38:1–38:8.
          P FAFF , T., T HUEREY , N., C OHEN , J., T ARIQ , S., AND G ROSS , M. 2010. Scalable fluid simulation using anisotropic turbulence particles. In ACM Transactions on Graphics (TOG), vol. 29, ACM, 174.
          S IN , F., B ARGTEIL , A. W., AND H ODGINS , J. K. 2009. A pointbased method for animating incompressible flow. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          S OLENTHALER , B., AND G ROSS , M. 2011. Two-scale particle simulation. ACM Trans. Graph. 30, 4 (July), 81:1–81:8.
          S TAM , J. 1999. Stable fluids. In Proceedings of SIGGRAPH ’99, ACM, 121–128.
          W OJTAN , C., AND T URK , G. 2008. Fast viscoelastic behavior with thin features. ACM Trans. Graph. 27, 3, 1–8.
          Y U , J., AND T URK , G. 2010. Reconstructing surfaces of particlebased fluids using anisotropic kernels. In Proceedings of the 2010 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 217–225.
          Z HU , Y., AND B RIDSON , R. 2005. Animating sand as a fluid. ACM Trans. Graph. 24, 3 (July), 965–972.
        
      
      
        A Ghost Fluid Coefficients
        Here we describe how to compute the ghost fluid coefficients θ n given the 4 × 4 pressure matrix entries of a single tetrahedron. Reorganizing Eq. (11) gives:
        
          16
          λ 2 + αw 1 a + αw 2 b + αw 3 p 1 b 1 a + βw 1 λ 3 + βw 2 c + βw 3 p 2 = b 2 . b + γw 1 c + γw 2 λ 4 + γw 3 p 3 b 3
        
        Note that each of the θ n has two degree of freedom, and thus each w n also has two degrees of freedom. As we know that the resulting matrix needs to be symmetric, which gives us the following constraints: a + αw 2 = a + βw 1 , b + γw 1 = b + αw 3 , and c + βw 3 = c + γw 2 . As the w n linearly depend on θ n , that means: αθ 2 = βθ 1 , γθ 1 = αθ 3 , and βθ 3 = γθ 2 . When we re-write these constraints in matrix form, and include the barycentric coordinate constraint θ 1 + θ 2 + θ 3 = 1 we get the following linear system:
        
          17
           −β α 0   0  γ 0 −α θ 1 0   0 1 −γ 1 β 1   θ θ 3 2 =   1 0  
        
        As the rank of top three rows of the matrix is 2, we can drop one of them. Removing the first row from the system gives us the following full-rank, 3 × 3 matrix:
        
          18
          γ 0 −α θ 1 0 0 −γ β θ 2 = 0 1 1 1 θ 3 1
        
        The analytical solution of this system is:
        
          19
          θ 1 1 α θ 2 = β . θ 3 α + β + γ γ
        
        This means that for our discretization, the ghost pressure coefficients θ n are given by the tetrahedron’s matrix entries from Eq.10. More specifically, by those for the vertex that is located outside of the liquid, i.e., α, β and γ. Substituting this equation into Eq.9 and Eq.6 yields the final equation for the ghost pressure Eq. (12).
      
    
  

</Document>
