<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A37_C07_Efficient_Simulation_of_Inextensible_Cloth_RHETORICAL_v1.xml">


  
    5dea618cb3c2811ff0b2ff5618860302e73237c3b57391624fcf5c334257b987
    3wy5
    http://dx.doi.org/10.1145/1276377.1276438
  
  
    
      
        <Title>Efficient Simulation of Inextensible Cloth</Title>
      
      
        
          Rony Goldenthal
        
        
          David Harmon 1 Raanan Fattal 3 Michel Bercovier 2 Eitan Grinspun 1 1 Columbia University 2 The Hebrew University of Jerusalem 3 University of California
          2
        
        
          Berkeley
        
      
      <Abstract>
<Sentence inAbstract="true" rhetoricalClass="DRI_Challenge">Many textiles do not noticeably stretch under their own weight.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Challenge">Unfortunately, for better performance many cloth solvers disregard this fact.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Outcome_Contribution">We propose a method to obtain very low strain along the warp and weft direction using Constrained Lagrangian Mechanics and a novel fast projection method.</Sentence> <Sentence inAbstract="true" rhetoricalClass="DRI_Outcome">The resulting algorithm acts as a velocity filter that easily integrates into existing simulation code.</Sentence>
</Abstract>
	  CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation I.6.8 [Simulation and Modeling]: Types of Simulation—Animation Keywords: Physically-based Modeling, Cloth simulation, Constrained Lagrangian Mechanics, Constraints, Stretching, Inextensibility, Isometry.
	  
	  
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Our eyes are very sensitive to the behavior of fabrics, to the extent that we can identify the kind of fabric simply from its shape and motion <CitSpan>[Griffiths and Kulke 2002]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">One important fact is that most fabrics do not stretch under their own weight.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Challenge">Unfortunately, for many popular cloth solvers, a reduction of permissible stretching is synonymous with degradation in performance: for tractable simulation times one may settle for an unrealistic 10% or more strain (compare 1% and 10%, Figure 1 ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">Our work alleviates this problem by introducing a numerical solver that excels at timestepping quasi-inextensible surfaces (stretching below 1%).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The solver builds on a framework of Constrained Lagrangian Mechanics (CLM) <CitSpan>[Marsden 1999]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Warp and weft, the perpendicular sets of strands that make up a textile, are prohibited from stretching by enforcing constraint equations, not by integrating spring forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">We present numerical evidence supporting the observation that a constraint-based method is inherently well-suited to operate in the quasi-inextensible regime.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In contrast, for this regime spring-based methods are known to experience a range of difficulties, leading to the adoption of various strain limiting <CitSpan>[Provot 1995]</CitSpan> and strain rate limiting algorithms.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">We are motivated by the work of <CitSpan>Bridson et al. [2002]</CitSpan>, who viewed strain limiting as one of multiple velocity filtering passes (another being collision handling).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The velocity filter paradigm enables the design of modular systems with mix-and-match flexibility.</Sentence>
      
        
        Figure 1: Importance of capturing inextensibility. For efficiency, many simulation methods allow 10% or more strain, whereas many fabrics do not visibly stretch. A 1m 2 patch, pinned at two corners
      
      <Sentence inAbstract="false" rhetoricalClass="Sentence">1m apart, is allowed to relax under gravity.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">We compare (left to right) three simulations of progressively smaller permissible strain with an actual denim patch.</Sentence>
      <Sentence inAbstract="false" rhetoricalClass="Sentence">Contributions We propose a novel CLM formulation that is implicit on the constraint gradient (§4.1).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">We prove that the implicit method’s nonlinear equations correspond to a minimization problem (§4.2): this result motivates a fast projection method for enforcing inextensibility (§4.3).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">We describe an implementation of fast projection as a simple and efficient velocity filter, as part of a framework that decouples timestepping, inextensibility, and collision passes (§4.4).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">Consequently, the fast projection method easily incorporates with a code’s existing bending, damping, and collision models, to yield accelerated performance (§5).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Before discussing these contributions, we summarize the relevant literature (§2) and describe the basic discrete cloth model (§3).</Sentence>
      
        <H1>2 Related Work</H1>
      
      <Sentence inAbstract="false" rhetoricalClass="DRI_Background">For brevity, we review work on stretch resistance; for broad surveys on cloth simulation see <CitSpan>[House and Breen 2000; Choi and Ko 2005]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The most general approach is to treat cloth as an elastic material <CitSpan>[Terzopoulos et al. 1987; Breen et al. 1994; Eberhardt et al. 1996; Baraff and Witkin 1998; Choi and Ko 2002]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">To reduce visible stretching, elastic models typically adopt large elastic moduli or stiff springs, degrading numerical stability <CitSpan>[Hauth et al. 2003]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">To address the stiffness of the resulting differential equations, <CitSpan>Baraff and Witkin [1998]</CitSpan> proposed implicit integration, allowing for large, stable timesteps; adaptive timestepping was required to prevent over-stretching.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">
<CitSpan>Eberhardt [2000] and Boxerman et al. [2003]</CitSpan> adopted implicit-explicit (IMEX) formulations, which treat only a subset of forces implicitly.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our method is closely related to the IMEX approach, in the sense that stretching forces are singled out for special treatment.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">These works, and many of their sequels, improved performance by allowing some perceptible stretch of the fabric.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In the quasiinextensible regime, however, implicit methods encounter numerical limitations <CitSpan>[Volino and Magnenat-Thalmann 2001; Boxerman 2003; Hauth et al. 2003]</CitSpan>: the condition number of the implicit system grows with the elastic material stiffness, forcing iterative solvers to perform many iterations; additionally, timestepping algorithms such as Backward Euler and BDF2 introduce undesirable numerical damping when the system is stiff <CitSpan>[Boxerman 2003]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Given a stiff differential equation, an alternative to implicit integration is to reduce the stiff component and reformulate it as a constraint <CitSpan>[Hairer et al. 2002]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In the smooth setting, the penalty-force and constraint-based approaches are equivalent in the limit of an infinitely stiff penalty term <CitSpan>[Bercovier and Pat 1984]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">In the discrete setting, the constraint-based approach may be implemented with various iterative or global algorithms, as surveyed below: <CitSpan>Iterative enforcement Provot [1995]</CitSpan> corrected edge lengths by iteratively displacing the incident vertices on stretched springs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">While simple to implement, this approach suffers from poor convergence since each displacement may stretch other incident springs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Therefore, Provot’s method is used in cases where tight tolerances are not required, e.g., <CitSpan>[Desbrun et al. 1999; Meyer et al. 2001; Fuhrmann et al. 2003]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Bridson et al. [2002; 2003] used Provot’s approach in conjunction with strain rate limiting, bounding the rate of change of spring length per timestep to 10% of the current length.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">
<CitSpan>Müller et al. [2006]</CitSpan> used a non-linear Gauss-Seidel approach to enforce inextensibility on each constraint separately.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Bridson et al. observed that iterative strain limiting algorithms behave essentially as Jacobi or Gauss-Seidel solvers.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In this light, it is not surprising that for finely-discretized quasi-inextensible fabrics, iterative constraint enforcement requires a prohibitive number of iterations (see §5).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Global enforcement In contrast to iterative constraint enforcement, <CitSpan>House et al. [1996]</CitSpan> used Lagrange multipliers with CLM to treat stretching, and presented a hierarchical treatment of the constraint forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">The Lagrange multiplier approach alleviates the difficulties associated with poor numerical conditioning and artificial damping.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">House et al. later encountered difficulties in handling collision response within the proposed framework [2000].</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">By building on the velocity-filter paradigm, our method handles both inextensibility and complex collisions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">House et al. formulated constraints as in <CitSpan>[Witkin et al. 1990]</CitSpan>, which is subject to numerical drift that may be exacerbated by the discontinuities introduced during collision response.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Drift may be attenuated using constraint-restoring springs, but the authors reported difficulty in adjusting the spring coefficients.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">We postulate that one reason for their difficulties with drift was consequent to the linearization of the constraint equation, which permitted higher order errors to accumulate over time.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our method does not linearize the constraint equations, and therefore it is not subject to drift.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Recently, <CitSpan>Tsiknis [2006]</CitSpan> proposed triangle-based strain limiting together with a global stitching step for stable constraint enforcement.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">
<CitSpan>Hong et al. [2005]</CitSpan> used a linearized implicit formulation in order to improve stability of constrained dynamics.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">This allowed for larger timesteps and reduced the need for springs to maintain the cloth on the constraint manifold.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Both of these approaches enforce inextensibility only for strain exceeding 10%.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In summary, when the tolerance for stretching is very small, modeling stretch response with spring-based or strain-limiting approaches is costly and even intractable; constraint-based methods present a promising alternative.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">The remainder of this paper discusses algorithms that excel at simulating quasi-inextensible cloth.</Sentence>
      
        <H1>3 Cloth Model</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Woven fabrics are not a continuous material, rather they are a complex mechanical network of interleaving yarn <CitSpan>[Breen et al. 1994]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Since the constituent yarn is often quasi-inextensible, the material’s warp and weft directions do not stretch perceptibly.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">In imposing inextensibility on all edges of a triangle mesh, one quickly runs into parasitic stiffness in the bending modes, or locking <CitSpan>[Zienkiewicz and Taylor 1989]</CitSpan>, since locally-convex regions of a triangle mesh are rigid under isometry.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Instead, we consider warpweft aligned quadrilateral meshes with a sparse number of triangles (quad-dominant meshes).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">A degree of freedom (DOF) counting argument suggests that constraining all edges of a quad mesh may circumvent the rigidification that occurs with triangle meshes: Given n vertices, we have 3n positional DOFs; their triangulation (resp.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">quadrangulation) introduces approximately 3n (resp.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">2n) edges, with corresponding inextensibility constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Subtracting constraints from positional DOFs leaves nearly zero DOFs for a triangulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In the case of a quadrangulation, O(n) DOFs remain, and we see that in a flat configuration they correspond to the normal direction at each vertex.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Furthermore, under general mesh positions, the constraints are linearly independent, with a full-rank Jacobian treatable by a direct solver (§4).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">We ask that a warpor weft-aligned quad edge, (p a , p b ), maintain its undeformed length, l, by enforcing</Sentence>
        
          1
          C(p a , p b ) = p b − p a 2 /l − l = 0 .
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">The solve will require the constraint gradient</Sentence>
        
          2
          ∇ p b C(p a , p b ) = 2(p b − p a )/l .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since shearing modes excite only a mechanical interaction of warp and weft, and not a stretching of yarn, fabric does indeed shear perceptibly.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Therefore, we model shear using non-stiff stretch springs applied on both diagonals of each quad.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The complete model of in-plane deformation is compatible with an existing code’s quador triangle-based treatment of bending and collisions.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">With this simple formulation of inextensibility constraints in place, what is needed is an efficient method for enforcing constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In the following, we develop such a method.</Sentence>
      
      
        <H1>4 Constrained Dynamics</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Given a quadrilateral mesh with n vertices and m edges, the numerical integration algorithm for constrained dynamics can be developed directly from the augmented Lagrange equation <CitSpan>[Marsden 1999]</CitSpan>, L(x, v) = 1 v T Mv −V (x) − C(x) T λ , 2 where x(t) is the time-varying 3n-vector of vertex positions, v(t) = x(t) is its time derivative, M is the 3n × 3n mass matrix, and V (x) is the stored energy (e.g., bending, shear, and gravity).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">C(x) is the m-vector of constraints, with the i th entry corresponding to the violation of inextensibility of the i th edge, as computed by <CitSpan>(1)</CitSpan>; λ is the m-vector of Lagrange multipliers.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The corresponding EulerLagrange equations are</Sentence>
        
          4
          M v = −∇V (x) − ∇C(x) T λ , C(x) = 0 ,
        
        <Sentence inAbstract="false" rhetoricalClass="Sentence">where ∇ ≡ ∇ x is the gradient with respect to position, and −∇V (x) is the potential force.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The term −∇C(x) T λ may be viewed as the constraint-maintaining force, where the factors −∇C(x) T and λ determine the direction and scaling for the force, respectively.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">∇C(x) is a rectangular matrix whose dimensions are m × 3n.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For simulation, we must discretize <CitSpan>(3) and (4)</CitSpan> in time using one of various schemes, each with benefits and drawbacks.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">One may choose differing explicit or implicit schemes for the potential and the constraint forces (similarly, potential forces are split and separately discretized in <CitSpan>[Ascher et al. 1997]</CitSpan>).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">The discrete equations replace x(t) and v(t) with {x 0 , x 1 , x 2 , .</Sentence> . .<Sentence inAbstract="false" rhetoricalClass="Sentence">} and {v 0 , v 1 , v 2 , .</Sentence> . .<Sentence inAbstract="false" rhetoricalClass="Sentence">}, where x n and v n are the position and velocity of the mesh at time t = nh, and h is the size of the timestep.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">One widely-used family of discretizations includes SHAKE and RATTLE, which extend the (unconstrained) Verlet scheme <CitSpan>[Hairer et al. 2002]</CitSpan> by considering a constraint force direction, −∇C(x) T , evaluated at the beginning of the timestep.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Unfortunately, enforcing length-preserving constraints with SHAKE fails for four common geometric configurations, which we refer to as <CitSpan>(Q1)–(Q4)</CitSpan> and depict in Figure 2 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">This figure is a reproduction from <CitSpan>[Barth et al. 1994]</CitSpan>, which discusses these drawbacks in SHAKE but does not offer a solution.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">In the figure, solid and hollow dots represent edge endpoints at the start and end of the timestep, as the particles would evolve if no constraints were applied.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">If the constraint direction, −∇C(x) T , is evaluated at the beginning of the timestep, x n , as in SHAKE, then no scaling, λ , of the constraint direction yields a satisfied end-of-timestep constraint, C(x n+1 ) = 0.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Numerically, for <CitSpan>(Q2)–(Q4)</CitSpan> this observation manifests as a singular Jacobian in Newton’s method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">These four cases correspond to rapid change in edge length or orientation; in practice, they occur often.</Sentence>
        <CitSpan>(Q1) (Q2) (Q3) (Q4)</CitSpan>
        
          Figure 2: Failure modes of methods using an explicit constraint direction. Reproduced from a discussion of SHAKE in <CitSpan>[Barth et al. 1994]</CitSpan>.
        
      
      
        <H2>4.1 Implicit constraint direction (ICD)</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Consider evaluating the constraint direction, −∇C(x) T , at the end of the timestep.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We observe (and prove in Appendix A) that this resolves <CitSpan>(Q1), (Q2) and (Q4)</CitSpan>; <CitSpan>(Q3)</CitSpan> remains, but is automatically remedied by decreasing the timestep.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Consider the ICD timestep, which treats potential forces explicitly 1 : v n+1 = v n − hM −1 ∇V (x n ) + ∇C(x n+1 ) T λ n+1 , x n+1 = x n + hv n+1 , C(x n+1 ) = 0 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Define x 0 n+1 =x n +hv n −h 2 M −1 ∇V (x n ), i.e., x n+1 0 is the position at the end of an unconstrained timestep; define δ x n+1 = x n+1 − x 0 n+1 , i.e., δ x n+1 is the correction of the unconstrained step.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Next, eliminate v n+1 by rewriting the above system as two equations, F( δ x n+1 , λ n+1 ) = 0 and C(x n+1 ) = 0, in the free variables δ x n+1 and λ n+1 , keeping in mind that x n+1 is a linear function in δ x n+1 , and defining F( δ x n+1 , λ n+1 ) = δ x n+1 + h 2 M −1 ∇C(x n+1 ) T λ n+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">F( δ x n+1 , λ n+1 ) and C(x n+1 ) are the residuals of the discretization of <CitSpan>(3) and (4)</CitSpan>, respectively.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">In particular, F measures the deviation 1 For an implicit treatment, write ∇V (x n+1 ) in place of ∇V (x n ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">of the trajectory away from that dictated by the governing (potential and constraint) forces; equivalently, it states that the correction of the unconstrained step is due to the constraint forces.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">C measures the deviation from the constraint manifold (in our case, the extensibility of the material).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To implement ICD, we solve for the roots of F and C up to a desired tolerance using Newton’s method.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Solving for an ICD step is costly, because there are many unknowns (≈ 5n), and each Newton step requires the solution of an indefinite linear system, whose matrix is costly to assemble.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In §4.3, we develop an approximation to ICD that addresses these drawbacks without sacrificing constraint accuracy or robustness.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">To arrive at this fast projection method, the following section considers ICD from an alternative, geometric viewpoint.</Sentence>
      
      
        <H2>4.2 Step and project (SAP)</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Consider for a moment an alternative approach to constrained integration in two steps: (a) step forward only the potential forces to arrive at the unconstrained position, x n+1 0 ; (b) enforce the constraints by projecting onto the constraint manifold M = {x n+1 |C(x n+1 ) = 0}.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Methods of this form are known as manifold-projection methods <CitSpan>[Hairer et al. 2002]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To define a specific method, we must choose a projection operator.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In the method we refer to as SAP, we write the projection of the unconstrained point onto the constraint manifold as x n+1 0 + δ x n+1 , so that the projected point extremizes the objective function W ( δ x n+1 , λ n+1 ) = 1 ( δ x n+1 ) T M( δ x n+1 ) + C(x n+1 ) T λ n+1 , 2h 2 with respect to the free variables δ x n+1 and λ n+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Simply put, we choose the point on the constraint manifold closest to x n+1 0 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To define closest, we need a measure of distance.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Take M as the physical mass matrix (usually arising from a finite-basis representation of x and a surface mass density).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Then the choice ( δ x n+1 ) T M( δ x n+1 ) corresponds to the L 2 norm of the mass-weighted displacement of the mesh as it moves from x 0 n+1 to x n+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Formally, it is a discretization of the smooth integral x n+1 − x 0 n+1 2 ρ d A , S evaluated over the reference (material) domain, S. Here x n+1 and x 0 n+1 are the piecewise linear immersion functions mapping each point of S into R 3 , and ρ is the (possibly nonuniform) surface mass density.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We use · to denote the Euclidean norm in R 3 .</Sentence>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Theorem 1: ICD ≡ SAP .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Proof: The stationary equations for W ( δ x n+1 , λ n+1 ) are the ICD equations, F( δ x n+1 , λ n+1 ) = 0 and C(x n+1 ) = 0.</Sentence>
        <Sentence inAbstract="false" rhetoricalClass="Sentence">Corollary In 4.1, we interpreted the roots of C and F from the ICD view.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We can interpret these roots from the SAP view as follows: C(x n+1 ) = 0 corresponds to finding some point on the constraint manifold.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">C(x n+1 ) = 0 with F( δ x n+1 , λ n+1 ) = 0 corresponds to finding the closest point on the constraint manifold.</Sentence>
      
      
        <H2>4.3 Fast projection method</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To solve SAP, one might extremize W ( δ x n+1 , λ n+1 ) using Newton’s method: each iteration would improve upon a guess for the shortest step, δ x n+1 that projects x n+1 0 onto the constraint manifold.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Algorithm 1 Fast projection is a velocity filter that enforces constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">It combines the robustness of using an implicit constraint direction with the efficiency of approximate manifold projection.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Input: v // candidate velocity Input: x // known start-of-step position 1: j ← 0 2: x 0 ← x + h v // unconstrained timestep 3: while strain of x j exceeds threshold do 4: Solve linear system <CitSpan>(7)</CitSpan> for δ λ j+1 5: Evaluate <CitSpan>(5)</CitSpan> to obtain δ x j+1 6: x j+1 ← x j + δ x j+1 7: j ← j + 1 8: end while Output: 1 h (x j − x) // constraint-enforcing velocity Fast projection also uses a sequence of iterations, but it relaxes the requirement of SAP: starting with the unconstrained position, x n+1 0 , we propose to find a close, but not necessarily closest, point on the constraint manifold, by taking a sequence of “smallest” steps.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Fast projection starts at x n+1 0 , and takes a sequence of steps, δ x n+1 j , j = 1, 2, . . ., toward the constraint manifold, with each step as short as possible.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">A step of fast projection Projection onto the constraint manifold occurs at a fixed instant in time.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Therefore, we omit the superscripts (n + 1), which refer to time, in order to emphasize the subscripts, j, which refer to a specific iteration of fast projection, e.g., we write the input position, x n+1 0 , as x 0 , and progressively closer approximations to the constrained position as x 1 , x 2 , .</Sentence> . .. <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Formally, the ( j + 1) th step of fast projection, x j+1 = x j + δ x j+1 , extremizes the objective function
        W ( δ x j+1 , δ λ j+1 ) = 2h 1 2 ( δ x j+1 ) T M( δ x j+1 ) + C(x j+1 ) T δ λ j+1 ,
        with respect to the step increment, δ x j+1 , and the auxiliary variable δ λ j+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Expanding the constraint to first order, we obtain a quadratic objective function, whose stationary equations with respect to δ x j+1 and δ λ j+1 are</Sentence>
        C(x j+1 ) = C(x j + δ x j+1 ) ≈ C(x j ) + ∇C(x j ) δ x j+1 ,
        
          5
          δ x j+1 = −h 2 M −1 ∇C(x j ) T δ λ j+1 ,
        
        
          6
          ∇C(x j ) δ x j+1 = −C(x j ) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Substituting <CitSpan>(5)</CitSpan> into <CitSpan>(6)</CitSpan>, we eliminate δ x j+1 and solve a linear system in δ λ j+1 :</Sentence>
        
          7
          h 2 ∇C(x j )M −1 ∇C(x j ) T δ λ j+1 = C(x j ) .
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Since the linear system matrix involves M −1 , the assembly of this system is most efficient for diagonal (e.g., lumped) mass matrices.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Finally, we compute the increment <CitSpan>(5)</CitSpan> to obtain x j+1 = x j + δ x j+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">As with ICD/SAP, a fast projection step requires a linear solve.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">However, fast projection’s system, <CitSpan>(7)</CitSpan>, is smaller (≈ 2n × 2n compared to ≈ 5n × 5n), positive definite (compared to indefinite) and sparser.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">As a result it is considerably cheaper to evaluate, assemble, and solve than its ICD/SAP counterpart.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Fast projection algorithm We repeatedly take fast projection steps until the maximal strain is below a threshold, i.e., the constraint may be satisfied up to a given tolerance.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">This process is summarized in Algorithm 1.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Fast projection finds a manifold point, x n+1 , that is close, but not closest, to the unconstrained point, x 0 n+1 .</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Referring to the Corollary, we conclude that fast projection exactly solves C = 0 while it approximates F = 0.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">One important question is whether the fast projection’s error in F is acceptable.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Compare a sequence of fast projection iterations to ICD/SAP’s sequence of Newton iterations.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The first iteration of these methods is identical.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">At the end of this first iteration, F, C ∈ O(h 2 ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Additional fast projection iterations seek C → 0, and since C ∈ O(h 2 ), increments in x are O(h 2 ), therefore F remains in O(h 2 ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Observe that F ∈ O(h 2 ) is considered acceptable in many contexts, e.g., <CitSpan>[Baraff and Witkin 1998; Choi and Ko 2002]</CitSpan> halt the Newton process after a single iteration.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">To verify this claim, we measured F throughout the ballet dancer sequence.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">As recorded in Figure 3 , the first iteration of the fast projection method eliminates first-order error.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The remaining iterations perturb F only to higher-order (often decreasing the error further).</Sentence>
        -4 3.5 x 10 error 2.5 after after last first iteration iteration F vertex 1.5 per 0.5 0.0 0 0.2 0.4 0.6 0.8 1 simulation time
        
          Figure 3: Effect of fast projection on the residual. Using the ballet dancer sequence, at each timestep (horizontal axis) we measured the residual, F (vertical axis), after the first and last iterations of fast projection (dashed-red and solid-blue curves, respectively).
        
        2 10 40 Fast Projection Implicit Spring (seconds) (seconds) 30 1 10 20 time time 10 0 10 0 10 1 10 0 10 -1 20 40 60 80 allowed strain (%) number of vertices (a) (b)
        
          Figure 4: Performance of fast projection vs. implicit springs. For a 1D chain simulated in MATLAB, we plot the computation time of one simulated second, as a function (a) of permissible strain (loglog plot for 80 vertices), and (b) of discretization resolution (linear plot for 1% permissible strain).
        
      
      
        <H2>4.4 Implementation</H2>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We implement fast projection as a velocity filter, enabling easy integration into our existing cloth simulation system; refer to Algorithm 1.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Step 3 requires solving a sparse symmetric positive definite linear system; we use the PARDISO <CitSpan>[Schenk and Gärtner 2006]</CitSpan> solver.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Each row of ∇C(x n+1 j ) corresponds to one edge, and is computed using <CitSpan>(2)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The right-hand side, C(x n+1 j ), is given by <CitSpan>(1)</CitSpan>.</Sentence>
        10 4 x10 2 15 Fast-Projection ICD Shake (seconds) 10 3 (seconds) 10 SL-Jacobi SL-Gauss-Seidel 2 time 10 time 5 1 10 0 10 1 10 0 10 -1 0 5000 10000 allowed strain (%) number of vertices (a) (b)
        
          Figure 5: Performance of several constraint-enforcing methods. For a 2D cloth, simulated in C++, we plot the computation time of one simulated second, as a function (a) of permissible strain (log-log plot for 5041 vertices), and (b) of discretization resolution (linear plot for 1% permissible strain).
          
        
        (a) (b)
        
          Figure 6:
        
        <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Qualitative visual comparison.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Snapshot of a cloth draped using (a) fast projection and (b) implicit constraint direction.</Sentence>
      
      
        <H1>5 Results</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We describe several experiments comparing various stretchenforcement methods.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">All timings are with reference to a single process on a 2.66GHz Intel Core 2 Duo.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">One-dimensional chain Our first experiment compares the performance of fast projection against an implicit treatment of stiff springs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We observe the scaling of computational cost as a function of (a) permissible strain and (b) mesh resolution.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The physical setup consists of a chain pinned at the top node and released to free fall under gravity.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The simple 1D chain resists stretching, but not bending.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">In this didactic example, timings refer to MATLAB’s (sparse) direct solver.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Our method shows asymptotically better performance as permissible strain vanishes (see Figure 4a ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Likewise, our algorithm exhibits favorable performance as mesh resolution increases (see Figure 4b ).</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Using 80 vertices and 1% strain, the fast projection method achieves a 25× speedup.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Note that there exists considerable difficulty in setting spring coefficients a priori to satisfy a given strain limit.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">For settings more pragmatic than a simple chain, such as the following draping experiment, we are unable (despite considerable effort) to set spring coefficients that achieve a prescribed small strain.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">This explains why spring methods are often treated with strain-limiting procedures.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Draping cloth The next experiment compares fast projection, ICD, SHAKE, and the strain limiting approach.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We evaluate how the spatial discretization and permissible strain affect performance of these four algorithms.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">The setup consists of draping a cloth over a polygonal model of a sphere.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We measure strain before the collision reaction pass.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For the strain limiting algorithms (both Jacobi and Gauss-Siedel), we iterate until strain is in the permissible range.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">With GaussSiedel, we apply a random permutation to reduce bias resulting from the particular edge ordering.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">For SHAKE, we use the acceleration suggested in <CitSpan>[Barth et al. 1994]</CitSpan> to rebuild the matrix once per step or when it fails to converge.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">As a consequence, the algorithm requires extremely small timesteps to converge, but each timestep is relatively inexpensive, as matrix re-assembly and re-factoring is infrequent.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">ICD is able to use larger timesteps than SHAKE and still converge, however, since each timestep is substantially more expensive than a SHAKE step, the overall time is higher.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 5a shows a timing comparison of these methods, and Figure 5b compares performance as the stiffness is increased for a cloth mesh with approximately 5000 vertices.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">All CLM methods scale equally well, asymptotically better than the strain limiting approach, with the fast projection being the fastest.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">As we refine the resolution, and allow strain of 1% ( Figure 5b ), the fast projection method outperforms the other methods.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figure 6 shows the same frame from simulations that use the fast projection and ICD methods, with qualitatively similar results.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Figures 7 and 8 show still frames from more complex simulations demonstrating that fast projection is capable of producing complex, realistic simulations of cloth.</Sentence>
        
          
          Figure 7: Inextensibility and dynamics. Inextensibility ensures that the tight-fitting pants do not drop past the dancer’s narrow waist. Using fast projection, an implicit treatment of shear and bending, and a mesh with 10600 vertices, the average simulation time per (30Hz) frame was 9 seconds.
        
      
      
        <H1>6 Discussion</H1>
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Our experiments focus on measuring the performance of enforcing inextensibility using CLM compared to strain limiting and stiff springs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">In addition to the direct benefit of fast projection on computation times, further benefits can be reaped from the resulting inextensibility.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">For example, the work of <CitSpan>Bergou et al. [2006]</CitSpan> assumes inextensibility in order to accelerate bending computation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">In adopting the velocity-filtering viewpoint, we gain speed, simplicity, and software modularity—all key to a practical and maintainable implementation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">However, this comes at a theoretical cost: there is no longer an efficient way to perfectly enforce both ideal inextensibility and ideal collision handling, since one filter must execute before the other, and both ideals correspond to sharp constraints.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">To enforce both perfectly would require combining them in a single pass, an elegant and exciting prospect from the standpoint of theory, but one which is likely to introduce considerable complexity and convergence challenges.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Practically, we observe that this drawback does not cause artifacts in our simulation, for several reasons: first, we execute collision-handling last, to avoid glaring collision artifacts, yet we assert that empirically our strain remains negligible, as required.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">Second, unlike constraint-enforcement approaches such as <CitSpan>[Witkin et al. 1990]</CitSpan>, the inextensibility filter does not assume that the constraint is maintained at the beginning of the timestep and errors are not accumulated during the simulation.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Conclusion Despite the fact that the most common fabrics do not visibly stretch when draped over the body, the trend in our community is to favor stretching formulations based on penalty-springs.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome">The consequent numerical difficulties are then addressed by a combination of (a) relaxing realism by allowing 10% strain, and (b) adopting simple iterative strain and strain-rate algorithms that have poor convergence behavior.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">With Constrained Lagrangian Mechanics as our alternative point of departure, we demonstrate a straightforward filter, with good convergence behavior, for enforcing inextensibility.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Outcome_Contribution">We provide one immediate and pragmatic approach to fast and realistic fabric simulation using CLM, and we hope that it will spur a renaissance of activity along this direction.</Sentence> <Sentence inAbstract="false" rhetoricalClass="Sentence">Acknowledgments We are grateful for the valuable feedback from our reviewers, and in particular for the keen eyes and diligent guidance of the primary reviewer.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">We thank OptiTex for providing the 3D garment geometry as well as the animated figurines.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">We are grateful to David Ismailov for setting up the cloth models, and Ruzz Oved and Yaniv Gorali for lighting and shading our scenes.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Unspecified">Our work benefited from the valuable insights of Jerrold E. Marsden, Ari Stern, and Max Wardetzky, and from the generous support of the NSF (MSPA 0528402, CSR 0614770, CAREER 0643268), Autodesk, mental images, NVIDIA, and Elsevier.</Sentence>
      
      
        <H1>References</H1>
        
          A SCHER , U. M., R UUTH , S. J., AND S PITERI , R. J. 1997. Implicit–explicit Runge–Kutta methods for time-dependent partial differential equations. Applied Numerical Mathematics: Transactions of IMACS 25, 2–3, 151–167.
          B ARAFF , D., AND W ITKIN , A. 1998. Large steps in cloth simulation. In Proceedings of SIGGRAPH 98, ACM Press / ACM SIGGRAPH, New York, NY, USA, 43–54.
          B ARTH , E., K UCZERA , K., L EIMKUHLER , B., AND S KEEL , R. 1994. Algorithms for Constrained Molecular Dynamics. March.
          B ERCOVIER , M., AND P AT , T. 1984. A C 0 finite element method for the analysis of inextensibile pipe lines. Computers and Structures 18, 6, 1019–1023.
          B ERGOU , M., W ARDETZKY , M., H ARMON , D., Z ORIN , D., AND G RINSPUN , E. 2006. A quadratic bending model for inextensible surfaces. In Fourth Eurographics Symposium on Geometry Processing, 227–230.
          B OXERMAN , E. 2003. Speeding up cloth simulation. Master’s thesis, University of British Columbia.
          B REEN , D. E., H OUSE , D. H., AND W OZNY , M. J. 1994. Predicting the drape of woven cloth using interacting particles. In Proceedings of ACM SIGGRAPH 1994, ACM Press/ACM SIGGRAPH, New York, NY, USA, 365–372.
          B RIDSON , R., F EDKIW , R. P., AND A NDERSON , J. 2002. Robust treatment of collisions, contact, and friction for cloth animation. ACM Transactions on Graphics 21, 3 (July), 594–603.
          B RIDSON , R., M ARINO , S., AND F EDKIW , R. 2003. Simulation of clothing with folds and wrinkles. In Symposium on Computer animation, 28–36.
          C HOI , K.-J., AND K O , H.-S. 2002. Stable but responsive cloth. ACM Transactions on Graphics” 21, 3, 604–611.
          C HOI , K.-J., AND K O , H.-S. 2005. Research problems in clothing simulation. Computer-Aided Design 37, 6, 585–592.
          D ESBRUN , M., S CHR ODER  ̈ , P., AND B ARR , A. 1999. Interactive animation of structured deformable objects. In Graphics Interface ’99, 1–8.
          E BERHARDT , B., W EBER , A., AND S TRASSER , W. 1996. A fast, flexible, particle-system model for cloth draping. IEEE Comput. Graph. Appl. 16, 5, 52–59.
          E BERHARDT , B., E TZMUSS , O., AND H AUTH , M. 2000. Implicitexplicit schemes for fast animation with particle systems 137– 154.
          F UHRMANN , A., G ROSS , C., AND L UCKAS , V. 2003. Interactive animation of cloth including self collision detection. In WSCG ’03, 141–148.
          G RIFFITHS , P., AND K ULKE , T. 2002. Clothing movement— visual sensory evaluation and its correlation to fabric properties. Journal of sensory studies 17, 3, 229–255.
          H AIRER , E., L UBICH , C., AND W ANNER , G. 2002. Geometric Numerical Integration. No. 31 in Springer Series in Computational Mathematics. Springer-Verlag.
          H AUTH , M., E TZMUSS , O., AND S TRASSER , W. 2003. Analysis of numerical methods for the simulation of deformable models. The Visual Computer 19, 7-8, 581–600.
          H ONG , M., C HOI , M.-H., J UNG , S., W ELCH , S., AND T RAPP , J. 2005. Effective constrained dynamic simulation using implicit constraint enforcement. In International Conference on Robotics and Automation, 4520–4525.
          H OUSE , D. H., AND B REEN , D. E., Eds. 2000. Cloth modeling and animation. A. K. Peters, Ltd., Natick, MA, USA.
          H OUSE , D. H., D E V AUL , R. W., AND B REEN , D. E. 1996. Towards simulating cloth dynamics using interacting particles. International Journal of Clothing Science and Technology 8, 3, 75–94.
          M ARSDEN , J. 1999. Introduction to Mechanics and Symmetry. Springer.
          M EYER , M., D EBUNNE , G., D ESBRUN , M., AND B ARR , A. H. 2001. Interactive animation of cloth-like objects in virtual reality. The Journal of Visualization and Computer Animation 12, 1 (Feb.), 1–12.
          M ULLER  ̈ , M., H EIDELBERGER , B., H ENNIX , M., AND R AT CLIFF , J. 2006. Position based dynamics. In Proceedings of Virtual Reality Interactions and Physical Simulation (VRIPHYS), C. Mendoza and I. Navazo, Eds., 71–80.
          P ROVOT , X. 1995. Deformation constraints in a mass-spring model to describe rigid cloth behavior. In Graphics Interface, 147–154.
          S CHENK , O., AND G ARTNER  ̈ , K. 2006. On fast factorization pivoting methods for sparse symmetric indefinite systems. Elec. Trans. Numer. Anal 23, 158–179.
		  T ERZOPOULOS , D., P LATT , J., B ARR , A., AND F LEISCHER , K. 1987. Elastically deformable models. In Computer Graphics (Proceedings of ACM SIGGRAPH 87), ACM Press, New York, NY, USA, 205–214. 
		  T SIKNIS , K. D. 2006. Better cloth through unbiased strain limiting and physics-aware subdivision. Master’s thesis, The University of British Columbia.
V OLINO , P., AND M AGNENAT -T HALMANN , N. 2001. Comparing efficiency of integration methods for cloth simulation. Computer Graphics International, 265–274. W ITKIN , A., G LEICHER , M., AND W ELCH , W. 1990. Interactive dynamics. Computer Graphics (Proceedings of ACM SIGGRAPH 90) 24, 2, 11–21. 
        
        
          
          
          Figure 8: Enforcing inextensibility using fast projection yields lively motion with detailed wrinkles and folds. Frames from ballet and runway sequences simulated using fast projection. The elastic term was integrated implicitly (top) and explicitly (bottom), respectively. The cloth contains 8325 (top) and 10688 (bottom) vertices, with average simulation time per (30Hz) frame of 5.2 and 7.8 seconds, respectively.
        
       
      
      
        Appendix A
        <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">We briefly explain why ICD and fast projection (FP) are not troubled by configurations <CitSpan>(Q1), (Q2)</CitSpan>, and <CitSpan>(Q4)</CitSpan>, and are resilient to <CitSpan>(Q3)</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Background">Facts about the behavior of SHAKE are taken from <CitSpan>[Barth et al. 1994]</CitSpan>.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Q1 SHAKE’s force ∇C(x n ) T λ n+1 cannot reduce the single edge’s length back to l; our force ∇C(x n+1 j ) T λ n+1 can reduce that edge’s length back to l.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Q2 ∇C(x n+1 j ) and ∇C(x n ) T are both full-rank, yet SHAKE fails since ∇C(x n+1 j )M −1 ∇C(x n ) T is singular; FP uses ∇C(x n+1 j )M −1 ∇C(x n+1 j ) T , and ICD uses ∇C(x n+1 j )D∇C(x n+1 j ) T , where D is a symmetric full-rank matrix; in both cases this product is not singular.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Q3 ICD and FP may fail if ∇C(x n+1 j ) is rank-deficient; for sufficiently small timestep, h, this case is always avoidable.</Sentence> <Sentence inAbstract="false" rhetoricalClass="DRI_Approach">Q4 ∇C(x n ) is rank-deficient, so SHAKE fails; ICD and FP do not use ∇C(x n ).</Sentence>
      
    
  

</Document>
