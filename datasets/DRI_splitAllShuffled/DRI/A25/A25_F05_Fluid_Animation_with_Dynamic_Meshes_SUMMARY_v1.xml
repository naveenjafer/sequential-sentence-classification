<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A25_F05_Fluid_Animation_with_Dynamic_Meshes_SUMMARY_v1.xml">


  
    29dd9660c10228b001729ce8e0bc4153ee4445b609ab646c168d467337a763fb
    3x5y
    http://dx.doi.org/10.1145/1141911.1141961
  
  
    
      Computer Graphics Proceedings, Annual Conference Series, 2006
      
        <Title>Fluid Animation with Dynamic Meshes</Title>
      
      
        
          Bryan M. Klingner Bryan E. Feldman Nuttapong Chentanez James F. O’Brien University of California
        
        
          Berkeley
        
      
      
        
        Figure 1: Top: A paddle mixes smoke in a tank. Bottom: A cross-section of the simulation meshes used for each frame.
      
      <Abstract>
<Sentence inAbstract="true">This paper presents a method for animating fluid using unstructured tetrahedral meshes that change at each time step.</Sentence> <Sentence inAbstract="true">We show that meshes that conform well to changing boundaries and that focus computation in the visually important parts of the domain can be generated quickly and reliably using existing techniques.</Sentence> <Sentence inAbstract="true">We also describe a new approach to two-way coupling of fluid and rigid bodies that, while general, benefits from remeshing.</Sentence> <Sentence inAbstract="true">Overall, the method provides a flexible environment for creating complex scenes involving fluid animation.</Sentence>
</Abstract>
	  Keywords: Natural phenomena, physically based animation, computational fluid dynamics. CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Physically based modeling; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation; I.6.8 [Simulation and Modeling]: Types of Simulation—Animation.	  
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence inAbstract="false" summaryRelevanceScore="1.67">Although systems for physically based fluid animation have developed rapidly in recent years and can now reliably generate production-quality results, they still have some limitations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Simulation domains can change substantially from step to step because of deforming boundaries, moving obstacles, and evolving fluid motion, yet current systems based on fixed grids are not ideally suited to handle these situations.</Sentence>
      E-mail: {klingner|feldman|nchentan|job}@eecs.berkeley.edu From the ACM SIGGRAPH 2006 conference proceedings. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. <Sentence inAbstract="false" summaryRelevanceScore="1.0">ACM SIGGRAPH 2006, Boston, MA c Copyright ACM 2006
      We propose a method to simulate fluids with such rapidly changing domains by generating a new tetrahedral simulation mesh at each time step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">When generating the mesh, we use the position and shape of boundaries as well as criteria based on the visually important parts of the fluid and velocity field to construct a sizing field that dictates the desired edge length for tetrahedra throughout the domain.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">We then use an efficient and reliable meshing algorithm adapted from <CitSpan>[ Alliez et al., 2005 ]</CitSpan> to produce a mesh that is refined according to this field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">We use unstructured tetrahedral meshes because they conform to curved and irregular boundaries better than axis-aligned grids with the same number of grid elements and allow for precise control of refinement throughout the domain.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">We transfer the physical properties of the simulation from the old mesh to the new mesh using a generalization of the semi-Lagrangian velocity advection technique that introduces no additional smoothing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">We then perform a mass conservation step that has been extended to allow a new, single-step solution of two-way coupling between fluid and rigid bodies.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Overall, this approach provides a flexible framework for fluid simulation that opens the door to many features.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We have implemented the system and tested it in a variety of scenarios such as the one shown in Figure 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">We have found that the combination of unstructured tetrahedral domains and dynamic remeshing creates a versatile environment for the creation of complex and visually interesting fluid animations.</Sentence>
      
        <H1>2 Background</H1>
      
      <Sentence inAbstract="false" summaryRelevanceScore="1.67">The animation of fluids through physical simulation has become an important tool in the visual effects industry.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">One approach that has been popular in recent years makes use of a spatial discretization based on regular, fixed, hexahedral grids.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Some examples of this approach can be found in <CitSpan>[Foster and Metaxas, 1996], [Foster and Metaxas, 1997], [Stam, 1999], [Yngve et al., 2000], [Fedkiw et al., 2001], [Foster and Fedkiw, 2001], [Enright et al., 2002], [Carlson et al., 2002], [Feldman et al., 2003]</CitSpan>, and <CitSpan>[Goktekin et al., 2004]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The most commonly used storage scheme for these approaches is the “staggered grid” scheme.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This method offsets storage of different quantities on the grid, and was first described by <CitSpan>[Harlow and Welch, 1965]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Efforts have been made to enhance these methods to allow for better conformance to irregular boundaries such as the free surface of liquids, complex obstacles, or irregularly shaped domains.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">
<CitSpan>[Losasso et al., 2004]</CitSpan> described an octree-based method that retains many of the advantages of regular grids while allowing computational effort to be focused in particular parts of the simulation domain; this enables detailed tracking of moving boundaries such as liquid surfaces.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Both <CitSpan>[Carlson et al., 2004] and [Guendelman et al., 2005]</CitSpan> have demonstrated methods for two-way coupling of obstacles to fluid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Unstructured tetrahedra have also been used for fluid simulation within the graphics community.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Two examples of this are <CitSpan>[Feldman et al., 2005a] and [Elcott et al., 2005]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The first method uses a velocity-based approach while the second uses a vorticity-based formulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">It is a blend of ideas from these two papers, along with a generalization of the semi-Lagrangian velocity advection technique for moving meshes described in <CitSpan>[Feldman et al., 2005b]</CitSpan> that forms the heart of our method.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The idea of moving meshes independent of a fixed or particle-centric coordinate system is not a new one; arbitrary Lagrangian-Eulerian (ALE) methods were designed for just this purpose.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">They have proven useful in the simulation of highly deformable elastic materials.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">ALE was first described in <CitSpan>[Hirt et al., 1974]</CitSpan>, where it was used with finite differences to solve compressible fluid problems.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">
<CitSpan>[Donea et al., 1977]</CitSpan> went on to apply ALE in a finite element setting.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">An excellent survey of the development of ALE methods appears in <CitSpan>[Donea et al., 2004]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Examples within the graphics literature that feature moving meshes without remeshing include <CitSpan>[Shah et al., 2004] and [Rasmussen et al., 2004]</CitSpan>, both of which translate the grid to follow the visually important portion of the fluid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Another approach to handling changing domains is to dispense with the mesh altogether, instead using Lagrangian particles for simulation of fluids.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">A few examples of this approach are <CitSpan>[Terzopoulos et al., 1989], [Desbrun and Cani, 1996], [Cani and Desbrun, 1997], [Stora et al., 1999], [Müller et al., 2003], [Premo ze et al., 2003]</CitSpan>, and <CitSpan>[Müller et al., 2004]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">These meshless methods are particularly well suited to changing domains because points can move freely without concerns about mesh quality.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Because we regenerate a new simulation mesh at each time step, the viability of our method hinges on fast, high-quality, reliable tetrahedral mesh generation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">While a history of unstructured mesh generation is outside the scope of this paper, <CitSpan>[Owen, 1998] and [Teng and Wong, 2000]</CitSpan> provide good surveys of the field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">For our mesh generator we selected the approach described in <CitSpan>[ Alliez et al., 2005 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This innovative method produces meshes which conform to domains of arbitrary topology quickly and reliably.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Also, it allows for the local edge length of the tetrahedra to be specified arbitrarily throughout space, which allows us to easily perform adaptive mesh refinement from step to step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The meshes produced by this technique are Delaunay, which provides improved gradient estimation and allows us to significantly simplify some of the expressions that arise when interpolating velocity values stored on the mesh.</Sentence>
      820
      Computer Graphics Proceedings, Annual Conference Series, 2006
      
        <H1>3 Methods</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="3.67">The key contribution of our method is to demonstrate the freedom granted by remeshing at each simulation time step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">The core of our system is based on the simple, efficient methods for discretizing the inviscid Euler equations on tetrahe- dral meshes described in <CitSpan>[Elcott et al., 2005] and [Feldman et al., 2005a]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We have made a few modifications in order to combine the best aspects of both approaches that are described below.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Once we have a good discretization, we need a way to propagate information from one mesh to the next.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">
<CitSpan>[Feldman et al., 2005b]</CitSpan> details a generalization of the standard semiLagrangian velocity advection technique that allows simulation state to be transferred between deforming domains without incurring additional smoothing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We demonstrate that their approach can easily be applied to transfer information between two arbitrary, topologically unrelated meshes, which is required to achieve more general evolution of the simulation domain from step to step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Finally, we need to quickly and reliably generate a new tetrahedral mesh for each time step that suits the current simulation conditions, such as conformance to boundaries and obstacles as well as any desired refinement.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Although methods have long existed to mesh arbitrary domains, most are relatively slow in comparison to simulation running times or don’t reliably terminate under realistic conditions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The availability of efficient, versatile meshing algorithms such as <CitSpan>[ Alliez et al., 2005 ]</CitSpan> has made the generation of a new mesh at each time step practical.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Any changes that were required to make these pieces work together harmoniously are discussed below.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Also, we describe a new, single-step method to achieve two-way coupling between obstacle and fluid motion.</Sentence>
        
          <H2>3.1 Discretization</H2>
          <Sentence inAbstract="false" summaryRelevanceScore="2.00">We use a staggered fluid state storage scheme that stores pressures at tetrahedron circumcenters and “face-normal velocities,” the component of velocity in the direction of the face normal, at the face circumcenters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Similar schemes have been used in <CitSpan>[Botta and Hempel, 1996], [Elcott et al., 2005] and [Feldman et al., 2005a]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">These methods are a generalization of the staggered grid scheme originally proposed by <CitSpan>[Harlow and Welch, 1965]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This staggered method is used to discretize the inviscid Euler equations:</Sentence>
          
            1
            ∂u p f = − (u · ) u − + ∂t ρ ρ
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.0">subject to the mass conservation constraint for incompress-</Sentence>
          
            2
            ible fluids: · u =0 .
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.0">In these equations, u is the fluid velocity, t time, p pressure, ρ density, and f any external forces.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The symbol denotes T the vector of differential operators = [∂/∂x, ∂/∂y, ∂/∂z] .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We account for the changes in the mesh over a time step directly during semi-Lagrangian advection (see Section 3.2).</Sentence>
          
            <H3>3.1.1 Discrete Derivative Operators</H3>
            <Sentence inAbstract="false" summaryRelevanceScore="2.00">Divergence and gradient operators are needed as part of the mass conservation step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We make discrete estimates of these derivatives following the formulation presented in <CitSpan>[Losasso et al., 2004] and [Elcott et al., 2005]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The divergence of a tetrahedron is computed as an area weighted sum of the tetrahedron’s face normal velocities.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The gradient at a face circumcenter in the direction of the face’s normal is computed using finite differences.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The difference in circumcenter pressures adjacent to a face is divided by the distance between these circumcenters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In Delaunay meshes, the line connecting adjacent tetrahedra circumcenters passes through the circumcenter of the face between them and is in the direction of that face’s normal.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This property of Delaunay meshes motivates our storage scheme at circumcenters because the gradient estimate is equivalent to the gradient of a piecewise linear function that interpolates the circumcenter values.</Sentence>
            821
            ACM SIGGRAPH 2006, Boston, MA, July 30–August 3, 2006
            Current step
          
          
            <H3>3.1.2 Velocity Interpolation</H3>
            <Sentence inAbstract="false" summaryRelevanceScore="2.00">The staggered scheme stores only the component of velocity in the face normal direction.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For both the semi-Lagrangian step and to advect smoke particles for rendering, a full velocity vector must be found at arbitrary positions in the mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We interpolate velocity vectors from face normal velocities using the two-step method developed in <CitSpan>[Elcott et al., 2005]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">First, a velocity vector, u t , is computed at each tetrahedron circumcenter, then we interpolate within Voronoi cells using u t values at the cell vertices.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Velocity u t for tetrahedron t is found by solving the small linear system N t u t = z t where N t is a matrix containing 4 rows of the face normals of t and z t is a vector of the 4 face normal velocities associated with t.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">For a divergence-free field, this solution has the remarkable property that interpolating back to the face circumcenters exactly recovers the original face-normal velocities.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Thus interpolating the u t velocities also exactly interpolates the face-normal velocity components, and does not incur the error one would otherwise expect from a twostep interpolation method.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">To find a velocity at an arbitrary point we interpolate within the Voronoi cell using the tetrahedra velocities associated with the cell.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This interpolation is based on the method of <CitSpan>[Warren et al., 2004]</CitSpan>, which presents a way to interpolate within a general convex polytope.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">They interpolate the value at the point x as a weighted sum of the polytope’s node values where node t’s unnormalized weight is computed as</Sentence>
            
              3
              |N t | w t (x) = . f ∈σ t n f · x + d f
            
            <Sentence inAbstract="false" summaryRelevanceScore="1.0">Here, σ t is the set of polytope faces that intersect at node t.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The denominator is the product of distances from x to the faces in σ t computed using the face normals,n f , and plane offsets, d f .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">|N t | is the determinant of a matrix of face normals in σ.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Weights from all nodes are normalized to sum to 1 before use in the weighted sum.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">To simplify this computation we take advantage of two properties: 1) in a Delaunay mesh, edges are in the direction of the Voronoi cell’s face normals and 2) the volume of tetrahedron t is 1/6|E t | where E t is a matrix formed from the three vectors of edges emanating from a common node of t.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">After some manipulation, which is omitted for brevity, Equation <CitSpan>(3)</CitSpan> applied to node weights within a Voronoi cell can be simplified to</Sentence>
            
              4
              6Vol(t) w t (x) = 3 i=1 (p i − p v ) · (c t − x)
            
            <Sentence inAbstract="false" summaryRelevanceScore="1.0">where w t (x) is the weight associated with the node at tetrahedra t’s circumcenter, Vol(t) is the volume of tetrahedron t, p v is the position of the node associated with the Voronoi cell, p i are positions of the other nodes of t, c t the circumcenter of t, and x the interpolation position.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">A similar observation appears in <CitSpan>[Ju et al., 2005]</CitSpan>, and we find that with it the velocity interpolation is quite efficient.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">All quantities appearing in Equation <CitSpan>(4)</CitSpan> are already stored for use in other parts of the timestep, saving the need to compute the terms in Equation <CitSpan>(3)</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">When advecting large numbers of particles, velocities at nodes of tetrahedra can be first be found using Equation <CitSpan>(4)</CitSpan> and then quickly interpolated in a linear fasion over the tetrahedra to advect the particles.</Sentence>
          
        
        
          <H2>3.2 Generalized Semi-Lagrangian Step</H2>
          <Sentence inAbstract="false" summaryRelevanceScore="1.67">The simple and stable semi-Lagrangian method has become the standard tool for advection of the velocity field for graphical applications <CitSpan>[Stam, 1999]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The basic idea of the method x A two-dimensional representation of the generalized semi-Lagrangian advection step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We trace back from the position where a velocity is stored in the new mesh, x i = (x, y), interpolate the velocity using the old mesh and velocity field, and update the velocity in the new mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">is that we can find a velocity that will advect to a point by tracing back from that point and interpolating the old velocity field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This method does not rely on velocities being stored at any particular place, as long as the velocity can be interpolated throughout space.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We can extend this technique naturally to meshes which change arbitrarily at each time step as in <CitSpan>[Feldman et al., 2005b]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This extension does not incur any additional smoothing compared to using semi-Lagrangian advection with static meshes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Suppose at time t velocities are stored at locations x (t) (in our case, the face circumcenters), and we want to find (t) the velocity at a particular face location x i .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We trace back (t) from x i through the velocity field of the previous time step to a point x i , which has no necessary correspondence to any feature of the old mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Then, we update the velocity at (t) x i to the value interpolated from the old velocity field at x i .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Because the velocities from the previous step are stored on a different mesh, we have to trace back and interpolate using this previous mesh (see Figure 2 ).</Sentence>
          y x i (t) x Previous step x i y
          
            Figure 2:
          
        
        
          <H2>3.3 Remeshing</H2>
          <Sentence inAbstract="false" summaryRelevanceScore="2.00">The domain boundaries, obstacles, and smoke are free to move and change from step to step of the simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">By regenerating the mesh at each time step we can ensure that our domain conforms well to boundaries and is refined in visually important areas.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We accomplish this by using the variational tetrahedral meshing algorithm presented in <CitSpan>[ Alliez et al., 2005 ]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This method allows for generation of tetrahedral meshes that conform well to an arbitrary input surface mesh, have no restrictions on topology (i.e., allow nested voids), and allow for sizing of tetrahedra throughout the domain based on arbitrary criteria.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Our implementation differs from the original algorithm in a couple of details.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">As in the original method, refinement of the mesh is controlled by a sizing function μ(x) that, for any point x in the simulation domain, returns the desired local edge length of the tetrahedra.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">While the original algorithm builds this sizing function by finding the minimum combination of local feature size and distance to a boundary point Left: a visualization of the sizing field for a rectangular domain with an irregular obstacle at the top and a plume of smoke at the bottom.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Right: the resulting simulation mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Obstacle faces are colored green.</Sentence>
          822
          Computer Graphics Proceedings, Annual Conference Series, 2006
          
            
            Figure 3:
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.0">from x, we instead formulate it as follows:</Sentence>
          
            5
            μ(x) = k 0 + min (k d d(x), k s (1 − s(x)) , k ω (1 − ω(x)))
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.0">In this equation, k 0 is an offset value that controls the minimum value of the sizing field, and hence the minimum local edge length of tetrahedra.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">d(x) is the distance to the closest obstacle or boundary which demands refinement, s(x) is a function of the density of smoke particles, and ω(x) is a function of the vorticity of the velocity field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The parameters k d , k s , and k ω respectively control the weight each of these functions has on the sizing field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">These three factors are the same as those used for octree refinement in <CitSpan>[Losasso et al., 2004]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The overall goal of the sizing field is to focus computational effort in the most visually important parts of the scene, that is, near closed boundaries, where the velocity field varies most, and where smoke is visible.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Figure 3 shows an example of a sizing field and the resulting mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Figure 4 demonstrates the benefits of refinement near areas of high vorticity and smoke density.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This meshing method is iterative, so the mesh from the previous simulation time step can be used as an initial guess for the node placement in the mesh at the next simulation time step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Because there is, in general, strong temporal coherence between steps of the simulation, the sizing field does not change too much and so the nodes from the previous step are often a good initialization.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Before the algorithm proceeds, the initial node placement is corrected to match the sizing field of the current step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">One other modification we made to the algorithm is that, when optimizing the node positions, we move nodes to the average of the barycenters of the surrounding tetrahedra instead of the circumcenters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We have found that while this tends to slightly decrease the average quality of tetrahedra in the mesh, it often leads to substantial improvements in the quality of the worst elements of the mesh, which are of more concern for numerical simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Of course, remeshing takes time, so it is important to consider the impact it has on overall simulation performance.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The time spent generating meshes for each simulation step varies, but generally accounts for less than a quarter of the overall simulation time.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In Section 4 we show timing information for several examples.</Sentence>
        
        
          <H2>3.4 Two-way Coupling and Mass Conservation</H2>
          <Sentence inAbstract="false" summaryRelevanceScore="2.00">The motion of fluid and rigid bodies that mutually effect each other can be complex and visually appealing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The interaction occurs as a consequence of the conditions that:
          1.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The velocities in the normal direction are the same at the interface of the fluid and the rigid body surface.</Sentence>
          2. <Sentence inAbstract="false" summaryRelevanceScore="1.67">The fluid velocity is divergence free and the rigid body velocity is rigid.</Sentence> 3. <Sentence inAbstract="false" summaryRelevanceScore="1.67">The linear and angular momentum of the combined system is conserved.</Sentence>
          <Sentence inAbstract="false" summaryRelevanceScore="1.33">In <CitSpan>[Carlson et al., 2004]</CitSpan> these conditions are enforced sequentially.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">While for many cases this produces results that look very good, under some situations artifacts can be created because enforcing one of the conditions in general will break a previously enforced one.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Examples of such artifacts might be fluid leaking through solid boundaries or poor performance in piston-like situations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Our implementation differs from <CitSpan>[Carlson et al., 2004]</CitSpan> in a couple of ways, but most significantly we enforce these conditions simultaneously within the mass conservation step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">In general, the mass conservation step solves for pressures that accelerate the velocity field to be divergence free.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In previous works, including those with two-way coupling, the mass conservation step treats faces to behave as fluid or explicitly prescribes their velocities.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">For fluid faces, the pressure accelerates the velocity proportional to the gradient of the pressure while for prescribed faces, the pressure does not effect the fluid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">For a more complete discussion of fluid/prescribed-velocity mass conservation see <CitSpan>[Fedkiw et al., 2001]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">We extend mass conservation to include a dynamic, rigid body.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">To do so, we solve for acceleration of the fluid and the rigid body, ignoring pressure for both.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We then solve for a pressure term that satisfies boundary and incompressibility constraints to find the final accelerations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The rigid body accelerations can be computed by creating a matrix R that is multiplied by a vector of the pressures that surround a rigid body.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">R can be formed by a series of matrix multiplications:</Sentence>
          
            6
             b 1  R =  . . .  M 0 −1 I −1 0 A 1 b T 1 ··· A k b T k b k
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.0">where b i = n T i | (r i × n i ) T , n i is the normal of the ith face, r i is the vector from the rigid objects center of mass to position of the ith face, and A i is the area of that face.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The rightmost matrix finds the net force-torque couple acting on a rigid body by summing up the contribution due to pressure forces acting on rigid body mesh faces.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The force-torque couple is converted to a linear and angular acceleration of A comparison between uniform and selectively refined simulation meshes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Left: a frame from a simulation using approximately 43000 uniformly sized tetrahedra.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Right: the same frame using approximately 32000 tetrahedra refined near areas of high vorticity and smoke density.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">The refined mesh preserves the fine detail in the velocity field and near the visible smoke, enhancing vortex action and natural movement.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The runtimes of the two are equivalent.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">the body by the middle (6×6) block matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">M is a diagonal matrix with the mass of the rigid body on the diagonals and I is the inertia matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The leftmost matrix in the multiplication returns the acceleration of the fluid-rigid faces in the direction of the face normal due to the linear and angular acceleration of the rigid body.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">By construction, accelerations generated by this matrix behave rigidly.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Computing pressure accelerations of both the fluid and fluid-rigid faces can be expressed as a matrix A multiplied by a vector of all the pressures.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">A row of A that corresponds to a face with fluid on both sides contains the same entries as the standard gradient matrix multiplied by −1/ρ.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">A row of A that belongs to a face at the fluid-rigid interface has element values obtained from the corresponding row of R. The elements of this row are placed at columns corresponding to the pressures that surround the rigid-body.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">With A built, mass conservation including two way coupling proceeds much in the same way as in the all-fluid case, with A replacing the role of the discrete gradient matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For a given vector of pressures, p, the intermediate velocity field, z ∗ , is accelerated to the end-of-step velocity, z, by z = z ∗ + ∆tAp.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For the fluid faces, z ∗ is found by applying all terms of Equation <CitSpan>(1)</CitSpan> except the pressure term.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For the fluid-rigid faces, z ∗ is found using a rigid body simulator without pressure forces applied.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">To find a particular pressure that accelerates z ∗ such that z is divergence free we solve the linear system</Sentence>
          
            
            Figure 4:
          
          823
          ACM SIGGRAPH 2006, Boston, MA, July 30–August 3, 2006
          
            
            Figure 5:
          
          Red particles are transfered from the left tank to the right by squeezing and releasing the central bulb. The blue valves are coupled to the fluid simulation and prevent backflow. Remeshing time Total time Percent per frame (mean) per frame (mean) remeshing Figure 1 13.2 sec 64.8 sec 20.3% Figure 5 8.33 sec 44.5 sec 18.7% 5.76 sec 35.8 sec 16.1% 313 sec 796 sec 39.3% A comparison of remeshing and simulation time for selected examples.
          
            7
            ∆tDAp = −Dz ∗ .
          
          <Sentence inAbstract="false" summaryRelevanceScore="1.33">This linear system can be solved efficiently using PCG since the the matrix DA, which replaces the discrete Laplacian from the all fluid case, is also a positive-definite symmetric matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Using the same machinery, we can also interact with constrained rigid bodies.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This simply requires finding an R matrix that correctly computes face accelerations due to pressure.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For example, one could easily alter R such that the body was constrained to just rotate about the origin by replacing b i in Equation <CitSpan>(6)</CitSpan> with b i = (r i × n i ) T and using only the I −1 block for the center matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This idea could be extended further to include even articulated bodies.</Sentence>
        
      
      
        <H1>4 Results and Discussion</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.33">We implemented the method described above in matlab 1 and C, making use of Pyramid [Jonathan Shewchuck, personal communication] for Delaunay triangulation and pixie 2 for all renderings.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Typical simulation times for meshes with 100,000 tetrahedra were about 1 minute per frame.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Table 1 compares remeshing and simulation times for several of the examples presented in this paper.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The images in Figure 1 show smoke in a tank mixed by the scripted motion of a paddle.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Refinement of the simulation mesh near the paddle ensures good conformance to its curved surfaces that produce interesting vortex effects in the smoke.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">1 http://www.mathworks.com 2 http://sourceforge.net/projects/pixie In Figure 5 , a pump transfers particles from the left tank to the right tank as the bulb in the middle is squeezed and released.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The blue valves on either side of the bulb prevent backflow.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The motion of these valves is not scripted.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Instead, they are modeled as rigid bodies constrained to rotate about an axis and their motion is caused by two-way interaction with the fluid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Figure 6 demonstrates the two-way interaction of the Stanford bunny with smoke cannons.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">On the left is a lighter bunny which is tossed about by the force of the cannons and also affects the motion of the smoke.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">On the right is a heavier bunny that drops quickly to the ground.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In Figure 7 , smoke moves through an array of obstacles in a higher resolution mesh of over 500,000 tetradra.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Although quality of the mesh elements does not suffer at this level of refinement, the proportion of time spent meshing increases to 39.3%.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The motion of the smoke at the higher resolution is more lively and exhibits more fine-scale detail.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">A vorticity enhancement method, such as those in <CitSpan>[Fedkiw et al., 2001] and [Selle et al., 2005]</CitSpan> could be used to further enhance the fluid motion but we do not find such enhancement necessary and so have not implemented it.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">We have presented a system for performing fluid animation using unstructured tetrahedral domains that can change arbitrarily at each time step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Although our current implementation models completely fluid-filled domains, we believe it would be well-suited for use with surface tracking techniques for liquid simulation.</Sentence>
        
          Table 1:
        
      
      
        <H1>Acknowledgments</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">We thank the other members of the Berkeley Graphics Group for their helpful criticism and comments.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This work was supported in part by California MICRO 04-066 and 05-044, and by generous support from Apple Computer, Pixar Animation Studios, Autodesk, Intel Corporation, Sony Computer Entertainment America, and the Alfred P. Sloan Foundation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Klingner and Feldman were supported by NSF Graduate Fellowships.</Sentence>
      
      
        <H1>References</H1>
        
          Alliez, P., Cohen-Steiner, D., Yvinec, M., and Desbrun, M. 2005. Variational tetrahedral meshing. In the Proceedings of ACM SIGGRAPH 2005, 617–625.
          Botta, N., and Hempel, D. 1996. A finite volume projection method for the numerical
          solution of the incompressible navier-stokes equations on triangular grids. First International Symposium on Finite Volumes for Complex Applications, 15–18 (July), 355 363.
          Cani, M.-P., and Desbrun, M. 1997. Animation of deformable models using implicit surfaces. IEEE Transactions on Visualization and Computer Graphics 3, 1 (Jan.), 39–50.
          Carlson, M., Mucha, P. J., Van Horn III, R. B., and Turk, G. 2002. Melting and flowing. In the ACM SIGGRAPH 2002 Symposium on Computer Animation, 167–174.
          Carlson, M., Mucha, P. J., and Turk, G. 2004. Rigid fluid: animating the interplay between rigid bodies and fluid. In the Proceedings of ACM SIGGRAPH 2004, 377–384.
          Desbrun, M., and Cani, M.-P. 1996. Smoothed particles: A new paradigm for animating highly deformable bodies. In Computer Animation and Simulation 1996, 61–76.
          Donea, J., Fasoli-Stella, P., and Giuliani, S. 1977. Lagrangian and eulerian finite element techniques for transient fluid-structure interaction problems. In Trans. 4th SMIRT Conf.
          Donea, J., Huerta, A., Ponthot, J.-P., and Rodr ́ıguez-Ferran, A. 2004. The Encyclopedia of Computational Mechanics. John Wiley &amp; Sons Inc., New York.
          Elcott, S., Tong, Y., Kanso, E., Schr ̈oder, P., and Desbrun, M. 2005. Discrete, circulation preserving, and stable simplicial fluids.Preprint, Caltech.
          Enright, D. P., Marschner, S. R., and Fedkiw, R. P. 2002. Animation and rendering of complex water surfaces. In the Proceedings of ACM SIGGRAPH 2002, 736–744.
          Fedkiw, R., Stam, J., and Jensen, H. W. 2001. Visual simulation of smoke. In the Proceedings of ACM SIGGRAPH 2001, 15–22.
          Feldman, B. E., O’Brien, J. F., and Arikan, O. 2003. Animating suspended particle explosions. In the Proceedings of ACM SIGGRAPH 2003, 708–715.
          Feldman, B. E., O’Brien, J. F., and Klingner, B. M. 2005. Animating gases with hybrid meshes. In Proceedings of ACM SIGGRAPH 2005.
          Feldman, B. E., O’Brien, J. F., Klingner, B. M., and Goktekin, T. G. 2005. Fluids in
          deforming meshes. In ACM SIGGRAPH/Eurographics Symposium on Computer Animation 2005.
          Foster, N., and Fedkiw, R. 2001. Practical animation of liquids. In the Proceedings of ACM SIGGRAPH 2001, 23–30.
          Foster, N., and Metaxas, D. 1996. Realistic animation of liquids. In Graphics Interface 1996, 204–212.
          Foster, N., and Metaxas, D. 1997. Modeling the motion of a hot, turbulent gas. In the Proceedings of ACM SIGGRAPH 97, 181–188.
          Goktekin, T. G., Bargteil, A. W., and O’Brien, J. F. 2004. A method for animating viscoelastic fluids. In the Proceedings of ACM SIGGRAPH 2004, 463–468.
          Guendelman, E., Selle, A., Losasso, F., and Fedkiw, R. 2005. Coupling water and smoke to thin deformable and rigid shells. In the Proceedings of ACM SIGGRAPH 2005, 973–981.
          Harlow, F., and Welch, J. 1965. Numerical calculation of time dependent viscous incompressible flow of fluid with a free surface. The Physics of Fluids 8, 2182–2189.
          Hirt, C., Amsden, A., and Cook, J. 1974. An arbitrary lagrangianeulerian computing method for all flow speeds. Journal of Computational Physics 14, 227–253.
          Ju, T., Schaefer, S., Warren, J., and Desbrun, M. 2005. A geometric construction of coordinates for convex polyhedra using polar duals. In Eurographics Symposium on Geometry Processing 2005, 181–186.
          Losasso, F., Gibou, F., and Fedkiw, R. 2004. Simulating water and smoke with an octree data structure. In the Proceedings of ACM SIGGRAPH 2004, 457–462.
          M ̈uller, M., Charypar, D., and Gross, M. 2003. Particle-based fluid simulation for interactive applications. In the ACM SIGGRAPH 2003 Symposium on Computer Animation, 154–159.
          M ̈uller, M., Keiser, R., Nealen, A., Pauly, M., Gross, M., and Alexa, M. 2004. Point based animation of elastic, plastic and melting objects. In the ACM SIGGRAPH 2004 Symposium on Computer Animation, 141–151.
          Owen, S. J. 1998. A survey of unstructured mesh generation technology. In the 7 th International Meshing Roundtable, 239–267.
          Premoˇze, S., Tasdizen, T., Bigler, J., Lefohn, A., and Whitaker, R. 2003. Particle-based simulation of fluids. Computer Graphics Forum 22, 3 (Sept.), 401–410.
          Rasmussen, N., Enright, D., Nguyen, D., Marino, S., Sumner, N., Geiger, W., Hoon, S., and Fedkiw, R. 20 4. Directable photorealistic liquids. In the ACM SIGGRAPH 2004
          Symposium on Computer Animation, 193–202.
          Selle, A., Rasmussen, N., and Fedkiw, R. 2005. A vortex particle method for smoke, water, and explosions. In the Proceedings ofACM SIGGRAPH 2005, 910–914.
          Shah, M., Cohen, J., Patel, S., Lee, P., and Pighin, F. 2004. Extended galilean invariance
          for adaptive fluid simulation. In 2004ACM SIGGRAPH / Eurographics Symposium on Computer Animation, 13 – 221. Stam, J. 1999. Stable fluids. In the Proceedings of ACM SIGGRAPH 99, 121–128.
          Stora, D., Agliati, P.-O., Cani, M.-P., Neyret, F., and Gascuel, J.D. 1999. Animating lava flows. In Graphics Interface 99, 203–210.
          Teng, S.-H., and Wong, C. W. 2000. Unstructured mesh generation: Theory, practice, and perspectives. International journal of computational geometry applications 10, 3, 227–266.
          Terzopoulos, D., Platt, J., and Fleischer, K. 1989. Heating and melting deformable models (from goop to glop). In Graphics Interface 1989, 219–226.
          Warren, J., Schaefer, S., Hirani, A. N., and Desbrun, M. 2004. Barycentric coordinates for convex sets. To appear in Advances in Computational and Applied Mathematics.
          Yngve, G. D., O’Brien, J. F., and Hodgins, J. K. 2000. Animating explosions. In the
          Proceedings of ACM SIGGRAPH 2000, 29–36.
        
        
          
          Figure 6:
        
        
          
          Figure 7:
        
      
    
  

</Document>
