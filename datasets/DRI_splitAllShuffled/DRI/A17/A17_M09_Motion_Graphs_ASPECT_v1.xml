<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A17_M09_Motion_Graphs_ASPECT_v1.xml">


  
    314cdb4ffe999411ffe446ddb3cfdf25d59e148dce001ad40723a3406bd5b5cb
    3y2s
    http://dx.doi.org/10.2172/7134495
  
  
    
      
        <Title>Motion Graphs</Title>
      
      To appear in Proceedings of SIGGRAPH ’02
      
        
          Lucas Kovar Michael Gleicher ∗ Frédéric Pighin † University of Wisconsin-Madison University of Wisconsin-Madison University of Southern California Institute for Creative Technologies
          ∗
        
      
      ∗ e-mail: {kovar,gleicher}@cs.wisc.edu † e-mail: pighin@ict.usc.edu
      
        
      
      <Abstract>
<Sentence aspectClass="NONE" inAbstract="true">In this paper we present a novel method for creating realistic, controllable motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Given a corpus of motion capture data, we automatically construct a directed graph called a motion graph that encapsulates connections among the database.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">The motion graph consists both of pieces of original motion and automatically generated transitions.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Motion can be generated simply by building walks on the graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">We present a general framework for extracting particular graph walks that meet a user’s specifications.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">We then show how this framework can be applied to the specific problem of generating different styles of locomotion along arbitrary paths.</Sentence>
</Abstract>
	CR Categories:  I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism Keywords: motion synthesis, motion capture, animation with constraints
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Realistic human motion is an important part of media like video games and movies.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">More lifelike characters make for more immersive environments and more believable special effects.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">At the same time, realistic animation of human motion is a challenging task, as people have proven to be adept at discerning the subtleties of human movement and identifying inaccuracies.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">One common solution to this problem is motion capture.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">However, while motion capture is a reliable way of acquiring realistic human motion, by itself it is a technique for reproducing motion.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Motion capture data has proven to be difficult to modify, and editing techniques are reliable only for small changes to a motion.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This limits the utility of motion capture  if the data on hand isn’t sufficiently similar to what is desired, then often there is little that can be done other than acquire more data, a time-consuming and expensive process.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This in particular is a problem for applications that require motion to be synthesized dynamically, such as interactive environments.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our goal is to retain the realism of motion capture while also giving a user the ability to control and direct a character.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, we would like to be able to ask a character to walk around a room without worrying about having a piece of motion data that contains the correct number of steps and travels in the right directions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also need to be able to direct characters who can perform multiple actions, rather than those who are only capable of walking around.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">This paper presents a method for synthesizing streams of motions based on a corpus of captured movement while preserving the quality of the original data.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Given a set of motion capture data, we compile a structure called a motion graph that encodes how the captured clips may be re-assembled in different ways.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">The motion graph is a directed graph wherein edges contain either pieces of original motion data or automatically generated transitions.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">The nodes then serve as choice points where these small bits of motion join seamlessly.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Because our methods automatically detect and create transitions between motions, users needn’t capture motions specifically designed to connect to one another.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">If desired, the user can tune the high-level structure of the motion graph to produce desired degrees of connectivity among different parts.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Motion graphs transform the motion synthesis problem into one of selecting sequences of nodes, or graph walks.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">By drawing upon algorithms from graph theory and AI planning, we can extract graph walks that satisfy certain properties, thereby giving us control over the synthesized motions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To demonstrate the potential of our approach, we introduce a simple example.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We were donated 78.5 seconds of motion capture, or about 2400 frames of animation, of a performer randomly walking around with both sharp and smooth turns.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Since the motion was donated, we did not carefully plan out each movement, as the literature suggests is critical to successful application of motion capture data <CitSpan>[Washburn 2001]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">From this data we constructed a motion graph and used an algorithm described later in this paper to extract motions that travelled along paths sketched on the ground.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Characteristic movements of the original data like sharp turns were automatically used when appropriate, as seen in Figure 1 .</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">It is possible to place additional constraints on the desired motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, we noticed that part of the motion had the character sneaking around.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">By labelling these frames as special, we were able to specify that at certain points along the path the character must only use sneaking movements, and at other parts of the motion it must use normal walking motions, as is also shown in Figure 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The remainder of this paper is organized as follows.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In Section 2 we describe related work.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In Section 3 we describe how a motion graph is constructed from a database of motion capture.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In Section 4 we set forth a general framework for extracting motion from the motion graph that meets user specifications.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Section 5 discusses the specific problem of generating movements along a path and how it is handled in our framework.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We conclude in Section 6 with a discussion of the scalability of our approach to large data sets and potential future work.</Sentence>
      1
      To appear in Proceedings of SIGGRAPH ’02
      
        
        Figure 1: The top images show original motion capture data; two are walking motions and one is a sneaking motion. The black curves show the paths travelled by the character. The bottom images show new motion generated by a motion graph built out of these examples plus their mirror images. Images 1 and 2 show the result of having the motion graph fit walking motion to the smooth yellow paths. The black curve is the actual position of the center of mass on each frame. Image 3 shows motion formed by having the character switch from walking to sneaking halfway down the path.
      
      
        <H1>2 Related Work</H1>
        <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Much previous work with motion capture has revolved around editing individual clips of motion.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Motion warping <CitSpan>[Witkin and Popović 1995]</CitSpan> can be used to smoothly add small changes to a motion.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Retargeting <CitSpan>[Gleicher 1998; Lee and Shin 1999]</CitSpan> maps the motion of a performer to a character of different proportions while retaining important constraints like footplants.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Various signal processing operations <CitSpan>[Bruderlin and Williams 1995]</CitSpan> can be applied to motion data.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Our work is different from these efforts in that it involves creating continuous streams of motion, rather than modifying specific clips.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">One strategy for motion synthesis is to perform multi-target blends among a set of examples, yielding a continuous space of parameterized motion.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Wiley and Hahn [1997]</CitSpan> used linear interpolation to create parameterizations of walking at various inclinations and reaching to various locations.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Rose et al. [1998]</CitSpan> used radial basis functions to blend among clips representing the same motion performed in different styles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These works have a focus complementary to ours: while they are mainly concerned with generating parameterizations of individual clips, we are concerned with constructing controllable sequences of clips.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Another popular approach to motion synthesis is to construct statistical models.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Pullen and Bregler [2000]</CitSpan> used kernel-based probability distributions to synthesize new motion based on the statistical properties of example motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Coherency was added to the model by explicitly accounting for correlations between parameters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>Bowden [2000], Galata et al. [2001]</CitSpan>, and <CitSpan>Brand and Hertzmann [2000]</CitSpan> all processed motion capture data by constructing abstract “states” which each represent entire sets of poses.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Transition probabilities between states were used to drive motion synthesis.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Since these statistical models synthesize motion based on abstractions of data rather than actual data, they risk losing important detail.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In our work we have tighter guarantees on the quality of generated motion.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Moreover, these systems did not focus on the satisfaction of high-level constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We generate motion by piecing together example motions from a database.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Numerous other researchers have pursued similar strategies.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Perlin [1995] and Perlin and Goldberg [1996]</CitSpan> used a rulebased system and simple blends to attach procedurally generated motion into coherent streams.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Faloutsos et al. [2001]</CitSpan> used support vector machines to create motion sequences as compositions of actions generated from a set of physically based controllers.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Since our system involves motion capture data, rather than procedural or physically based motion, we require different approaches to identifying and generating transitions.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Also, these systems were mainly concerned with appropriately generating individual transitions, whereas we address the problem of generating entire motions (with many transitions) that meet user-specified criteria.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Lamouret and van de Panne [1996]</CitSpan> developed a system that used a database to extract motion meeting high-level constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, their system was applied to a simple agent with five degrees of freedom, whereas we generate motion for a far more sophisticated character.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Molina-Tanco and Hilton [2000]</CitSpan> used a state-based statistical model similar to those mentioned in the previous paragraph to rearrange segments of original motion data.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">These segments were attached using linear interpolation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The user could create motion by selecting keyframe poses, which were connected with a highprobability sequence of states.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our work considers more general and sophisticated sets of constraints.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Work similar to ours has been done in the gaming industry to meet the requirements of online motion generation.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Many companies use move trees <CitSpan>[Mizuguchi et al. 2001]</CitSpan>, which (like motion graphs) are graph structures representing connections in a database of motion.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, move trees are created manually — short motion clips are collected in carefully scripted capture sessions and blends are created by hand using interactive tools.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Motion graphs are constructed automatically.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Also, move trees are typically geared for rudimentary motion planning (“I want to turn left, so I should follow this transition”), as opposed to more complicated objectives.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The generation of transitions is an important part of our approach.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Early work in this area was done by <CitSpan>Perlin [1995]</CitSpan>, who presented a simple method for smoothly interpolating between two clips to create a blend.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Lee [2000]</CitSpan> defined orientation filters that allowed these blending operations to be performed on rotational data in a more principled fashion.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Rose et al. [1996]</CitSpan> presented a more complex method for creating transitions that preserved kinematic constraints and basic dynamic properties.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our main application of motion graphs is to control a character’s locomotion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This problem is important enough to have received a great deal of prior attention.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Because a character’s path isn’t generally known in advance, synthesis is required.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Procedural and physically based synthesis methods have been developed for a few activities such as walking <CitSpan>[Multon et al. 1999; Sun and Metaxas 2001]</CitSpan> and running <CitSpan>[Hodgins et al. 1995; Bruderlin and Calvert 1996]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">While techniques such as these can generate flexible motion paths, the current range of movement styles is limited.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Also, these methods do not produce the quality of motion attainable by hand animation or motion capture.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">
<CitSpan>While Gleicher [2001]</CitSpan> presented a method for editing the path traversed in a clip of motion capture, it did not address the need for continuous streams of motion, nor could it choose which clip is correct to fit a path (e.g. that a turning motion is better when we have a curved path).</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Our basic approach — detecting transitions, constructing a graph, and using graph search techniques to find sequences satisfying user demands — has been applied previously to other problems.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Schödl et al. [2000]</CitSpan> developed a similar method for synthesizing seamless streams of video from example footage and driving these streams according to high-level user input.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since writing this paper, we have learned of similar work done concurrently by a number of research groups.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Arikan and Forsythe [2002]</CitSpan> constructed from a motion database a hierarchical graph similar to ours and used a randomized search algorithm to extract motion that meets user constraints.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Lee et al. [2002]</CitSpan> also constructed a graph and generated motion via three user interfaces: a list of choices, a sketch-based interface similar to what we use for path fitting (Section 5), and a live video feed.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">
<CitSpan>Pullen and Bregler [2002]</CitSpan> keyframed a subset of a character’s degrees of freedom and matched small segments of this keyframed animation with the lower frequency bands of motion data.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This resulted in sequences of short clips forming complete motions.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Li et al [2002] generated a two-level statistical model of motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At the lower level were linear dynamic systems representing characteristic movements called “textons”, and the higher level contained transition probabilities among textons.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This model was used both to generate new motion based on user keyframes and to edit existing motion.</Sentence>
        2
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H1>3 Motion Graph Construction</H1>
        <Sentence aspectClass="NONE" inAbstract="false">In this section, we define the motion graph structure and the procedure for constructing it from a database of clips.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A clip of motion is defined as a regular sampling of the character’s parameters, which consist of the position of the root joint and quaternions representing the orientations of each joint.</Sentence> We
        
          Figure 2: Consider a motion graph built from two initial clips. (top) We can trivially
        
        <Sentence aspectClass="NONE" inAbstract="false">insert a node to divide an initial clip into two smaller clips.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">(bottom) We can also insert a transition joining either two different initial clips or different parts of the same initial clip.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">also allow clips (or, more generally, sets of frames) to be annotated with other information, such as descriptive labels (“walking,” “karate”) and constraint information (left heel must be planted on these frames).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A motion graph is a directed graph where all edges correspond to clips of motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Nodes serve as choice points connecting these clips, i.e., each outgoing edge is potentially the successor to any incoming edge.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A trivial motion graph can be created by placing all the initial clips from the database as arcs in the graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This creates a disconnected graph with 2n nodes, one at the beginning and end of each clip.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, an initial clip can be broken into two clips by inserting a node, since the later part of the motion is a valid successor to the earlier part (see Figure 2 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A more interesting graph requires greater connectivity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For a node to have multiple outgoing edges, there must be multiple clips that can follow the clip(s) leading into the node.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since it is unlikely that two pieces of original data are sufficiently similar, we need to create clips expressly for this purpose.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Transitions are clips designed such that they can seamlessly connect two segments of original data.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">By introducing nodes within the initial clips and inserting transition clips between otherwise disconnected nodes, we can create a wellconnected structure with a wide range of possible graph walks (see Figure 2 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Unfortunately, creating transitions is a hard animation problem.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Imagine, for example, creating a transition between a run and a backflip.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In real life this would require several seconds for an athlete to perform, and the transition motion looks little like the motions it connects.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence the problem of automatically creating such a transition is arguably as difficult as that of creating realistic motion in the first place.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">On the other hand, if two motions are “close” to each other then simple blending techniques can reliably generate a transition.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In light of this, our strategy is to identify portions of the initial clips that are sufficiently similar that straightforward blending is almost certain to produce valid transitions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The remainder of this section is divided into three parts.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First we describe our algorithm for detecting a set of candidate transition points.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the following two sections we discuss how we select among these candidate transitions and how blends are created at the chosen transition points.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, we explain how to prune the graph to eliminate problematic edges.</Sentence>
        3
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>3.1 Detecting Candidate Transitions</H2>
        <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">As in our system, motion capture data is typically represented as vectors of parameters specifying the root position and joint rotations of a skeleton on each frame.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">One might attempt to locate transition points by computing some vector norm to measure the difference between poses at each pair of frames.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, such a simple approach is ill-advised, as it fails to address a number of important issues:
        1.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Simple vector norms fail to account for the meanings of the parameters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Specifically, in the joint angle representation some parameters have a much greater overall effect on the character than others (e.g., hip orientation vs. wrist orientation).</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Moreover, there is no meaningful way to assign fixed weights to these parameters, as the effect of a joint rotation on the shape of the body depends on the current configuration of the body.</Sentence> 2. <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">A motion is defined only up to a rigid 2D coordinate transformation.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">That is, the motion is fundamentally unchanged if we translate it along the floor plane or rotate it about the vertical axis.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence comparing two motions requires identifying compatible coordinate systems.</Sentence> 3. <Sentence aspectClass="NONE" inAbstract="false">Smooth blends require more information than can be obtained at individual frames.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A seamless transition must account not only for differences in body posture, but also in joint velocities, accelerations, and possibly higher-order derivatives.</Sentence>
        <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our similarity metric incorporates each of these considerations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To motivate it, we note that the skeleton is only a means to an end.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">In a typical animation, a polygonal mesh is deformed according to the skeleton’s pose.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">This mesh is all that is seen, and hence it is a natural focus when considering how close two frames of animation are to each other.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this reason we measure the distance between two frames of animation in terms of a point cloud driven by the skeleton.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Ideally this point cloud is a downsampling of the mesh defining the character.</Sentence>     <Sentence aspectClass="NONE" inAbstract="false">To calculate the distance D( i , ¡ j ) between two frames i and ¡ j , we consider the point clouds formed over two windows of frames of user-defined length k, one bordered at the beginning by   i and the other bordered at the end by ¡ j .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">That is, each point cloud is the composition of smaller point clouds representing the pose at each frame in the window.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The use of windows of frames effectively incorporates derivative information into the metric, and is similar to the approach in <CitSpan>[Schödl et al. 2000]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The size of the   windows are the same as the length of the transitions, so D( i , ¡ j ) is affected by every pair of frames that form the transition.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We use a value of k corresponding to a window of about a third of a second in length, as in <CitSpan>[Mizuguchi et al. 2001]</CitSpan>   The distance between i and ¡ j may be calculated by computing a weighted sum of squared distances between corresponding points p i and p i in the two point clouds.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To address the problem of finding coordinate systems for these point clouds (item 2 in the above list), we calculate the minimal weighted sum of squared distances given that an arbitrary rigid 2D transformation may be applied to the second point cloud:</Sentence>
        
          1
          θ min ,x ,z ∑ i w i p i − T θ ,x 0 ,z 0 p i 2
        
        <Sentence aspectClass="NONE" inAbstract="false">where the linear transformation T θ ,x 0 ,z 0 rotates a point p about the y (vertical) axis by θ degrees and then translates it by (x 0 , z 0 ).</Sentence> The
        
          
          Figure 3: An example error function for two motions. The entry at (i, j) contains the error for making a transition from the i th frame of the first motion to the j th frame of
        
        <Sentence aspectClass="NONE" inAbstract="false">the second.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">White values correspond to lower errors and black values to higher errors.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The colored dots represent local minima.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">index is over the number of points in each point cloud.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The weights w i may be chosen both to assign more importance to certain joints (e.g., those with constraints) and to taper off towards the end of the window.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This optimization has a closed-form solution:</Sentence>
        
          2
          θ = arctan ∑ ∑ i i w w i i (x (x i i z x i i − + x z i i z z i i ) ) − − ∑ ∑ i i 1 1 w w i i (xz (xx − + x zz z) )
        
        
          3
          1 x 0 = ∑ w (x − x cos( θ ) − z sin θ )
        
        
          4
          1 z 0 = ∑ w (z + x sin( θ ) − z cos θ )
        
        <Sentence aspectClass="NONE" inAbstract="false">where x = ∑ i w i x i and the other barred terms are defined similarly.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We compute the distance as defined above for every pair of frames in the database, forming a sampled 2D error function.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Figure 3 shows a typical result.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">To make our transition model more compact, we find all the local minima of this error function, thereby extracting the “sweet spots” at which transitions are locally the most opportune.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This tactic was also used in <CitSpan>[Schödl et al. 2000]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These local minima are our candidate transition points.</Sentence>
      
      
        <H2>3.2 Selecting Transition Points</H2>
        <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">A local minimum in the distance function does not necessarily imply a high-quality transition; it only implies a transition better than its neighbors.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We are specifically interested in local minima with small error values.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">The simplest approach is to only accept local minima below an empirically determined threshold.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This can be done without user intervention.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, often users will want to set the threshold themselves to pick an acceptable tradeoff between having good transitions (low threshold) and having high connectivity (high threshold).</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Different kinds of motions have different fidelity requirements.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, walking motions have very exacting requirements on the transitions — people have seen others walk nearly every day since birth and consequently have a keen sense of what a walk should look like.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">On the other hand, most people are less familiar with ballet motions and would be less likely to detect inaccuracies in such motion.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">As a result, we allow a user to apply different thresholds to different pairs of motions; transitions among ballet motions may have a higher acceptance threshold than transitions among walking motions.</Sentence>
        4
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>3.3 Creating Transitions</H2>
          <Sentence aspectClass="NONE" inAbstract="false">If D( i , ¡ j ) meets the threshold requirements, we create a tran    sition by blending frames i to i+k−1 with frames ¡ j−k+1 to ¡ j , inclusive.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The first step is to apply the appropriate aligning 2D transformation to motion .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then on frame p of the transition ¡ (0 ≤ p &lt; k) we linearly interpolate the root positions and perform spherical linear interpolation on joint rotations:</Sentence>
        
          5
          R p = α (p)R + [1 − α (p)]R i+p j−k+1+p
        
        
          6
          q ip = sler p(q i ¢ , q i £ , α (p)) i+p j−k+1+p
        
        <Sentence aspectClass="NONE" inAbstract="false">where R p is the root position on the p th transition frame and q ip is the rotation of the i th joint on the p th transition frame.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To maintain continuity we choose the blend weights α (p) according to the conditions that α (p) = 1 for p ≤ −1, α (p) = 0 for p ≥ k, and that α (p) has C 1 continuity everywhere.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This requires</Sentence>
        
          7
          α (p) = 2( p + 1 ) 3 − 3( p + 1 ) 2 + 1, −1 &lt; p &lt; k k k
        
        <Sentence aspectClass="NONE" inAbstract="false">Other transition schemes, such as <CitSpan>[Rose et al. 1996]</CitSpan>, may be used in place of this one.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">The use of linear blends means that constraints in the original motion may be violated.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, one of the character’s feet may slide when it ought to be planted.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This can be corrected by using constraint annotations in the original motions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We treat constraints as binary signals: on a given frame a particular constraint either exists or it does not.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Blending these signals in analogy to equations 5   and 6 amounts to using the constraints from in the first half of the transition and the constraints from in the second half.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this ¡ manner each transition is automatically annotated with constraint information, and these constraints may later be enforced as a postprocessing step when motion is extracted form the graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will discuss constraint enforcement in more detail in the next section.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Descriptive labels attached to the motions are carried along into transitions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Specifically, if a transition frame is a blend between a frame with a set of labels L 1 and another frame with a set of labels L 2 , then it has the union of these labels L 1 ∪ L 2 .</Sentence>
        1 2 3 4 5 6 7 8
        
          Figure 4: A simple motion graph. The largest strongly connected component is <CitSpan>[1, 2, 3, 6, 7, 8]</CitSpan>. Node 4 is a sink and 5 is a dead end.
        
      
      
        <H2>3.4 Pruning The Graph</H2>
        <Sentence aspectClass="NONE" inAbstract="false">In its current state there are no guarantees that the graph can synthesize motion indefinitely, since there may be nodes (called dead ends) that are not part of any cycle (see Figure 4 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Once such a node is entered there is a bound on how much additional motion can be generated.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Other nodes (called sinks) may be part of one or more cycles but nonetheless only be able to reach a small fraction of the total number of nodes in the graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While arbitrarily long motion may still be generated once a sink is entered, this motion is confined to a small part of the database.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, some nodes may have incoming edges such that no outgoing edges contain the same set of descriptive labels.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This is dangerous since logical discontinuities may be forced into a motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, a character currently in a “boxing” motion may have no choice but to transition to a “ballet” motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To address these problems, we prune the graph such that, starting from any edge, it is possible to generate arbitrarily long streams of motion of the same type such that as much of the database as possible is used.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is done as follows.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Every frame of original data is associated with a (possibly empty) set of labels.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Say there are n unique sets.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For each set, form the subgraph consisting of all edges whose frames have exactly this set of labels.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Compute the strongly connected components (SCCs) of this subgraph, where an SCC is a maximal set of nodes such that there is a connecting graph walk for any ordered pair of nodes (u, v).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The SCCs can be computed in O(V + E) time using an algorithm due to Tarjan.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We eliminate from this subgraph (and hence the original motion graph) any edge that does not attach two nodes in the largest SCC.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Once this process is completed for all n label sets, any nodes with no edges are discarded.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A warning is given to the user if the largest SCC for a given set of labels contains below a threshold number of frames.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, a warning is given if for any ordered pair of SCCs there is no way to transition from the first to the second.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In either case, the user may wish to adjust the transition thresholds (Section 3.2) to give the graph greater connectivity.</Sentence>
      
      
        <H1>4 Extracting Motion</H1>
        <Sentence aspectClass="NONE" inAbstract="false">By this stage we have finished constructing the motion graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">After describing exactly how a graph walk can be converted into displayable motion, we will consider the general problem of extracting motion that satisfies user constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our algorithm involves solving an optimization problem, and so we conclude this section with some general recommendations on how to pose the optimization.</Sentence>
        5
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>4.1 Converting Graph Walks To Motion</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Since every edge on the motion graph is a piece of motion, a graph walk corresponds to a motion generated by placing these pieces one after another.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The only issue is to place each piece in the correct location and orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In other words, each frame must be transformed by an appropriate 2D rigid transformation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At the start of a graph walk this transformation is the identity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Whenever we exit a transition edge, the current transformation is multiplied by the transformation that aligned the pieces of motion connected by the transition (Section 3.1).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As noted in Section 3.3, the use of linear blends to create transitions can cause artifacts, the most common of which is feet that slide when they ought to be planted.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, every graph walk is automatically annotated with constraint information (such as that the foot must be planted).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These constraints are either specified directly in the original motions or generated as in Section 3.3, depending on whether the frame is original data or a transition.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These constraints may be satisfied using a variety of methods, such as <CitSpan>[Gleicher 1998]</CitSpan> or <CitSpan>[Lee and Shin 1999]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our work we used the method described in <CitSpan>[Kovar et al. 2002]</CitSpan>.</Sentence>
      
      
        <H2>4.2 Searching For Motion</H2>
        <Sentence aspectClass="NONE" inAbstract="false">We are now in a position to consider the problem of finding motion that satisfies user-specified requirements.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It is worth first noting that only very special graph walks are likely to be useful.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, while a random graph walk will generate a continuous stream of motion, such an algorithm has little use other than an elaborate screen saver.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As a more detailed example, consider computing an all-pairs shortest graph walk table for the graph.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">That is, given a suitable metric — say, time elapsed or distance travelled — we can use standard graph algorithms like Floyd-Warshall to find for each pair of nodes u and v the connecting graph walk that minimizes the metric.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">With this in hand we could, for example, generate the motion that connects one clip to another as quickly as possible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is less useful than it might appear at first.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, there are no guarantees that the shortest graph walk is short in an absolute sense.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our larger test graphs (between a few and several thousand nodes) the average shortest path between any two nodes was on the order of two seconds.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is not because the graphs were poorly connected.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since the transitions were about one-third of a second apiece, this means there were on average only five or six transitions separating any two of the thousands of nodes.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Second, there is no control over what happens during the graph walk — we can’t specify what direction the character travels in or where she ends up.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">More generally, the sorts of motions that a user is likely to be interested in probably don’t involve minimizing metrics as simple as total elapsed time.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, for complicated metrics there is typically no simple way of finding the globally optimal graph walk.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence we focus instead on local search methods that try to find a satisfactory graph walk within a reasonable amount of time.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We now present our framework for extracting graph walks that conform to a user’s specifications.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We cast motion extraction as a search problem and use branch and bound to increase the efficiency of this search.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The user supplies a scalar function g(w, e) that evaluates the additional error accrued by appending an edge e to the existing path w, which may be the empty path 0.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">/ The total error f (w) of the path is defined as follows:</Sentence>
        
          8
          n f (w) = f ([e 1 , . . . , e n ]) = ∑ g([e 1 , . . . , e i−1 ], e i ) i=1
        
        <Sentence aspectClass="NONE" inAbstract="false">where w is comprised of the edges e 1 , . . . , e n .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We require g(w, e) to be nonnegative, which means that we can never decrease the total error by adding more edges to a graph walk.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In addition to f and g, the user must also supply a halting condition indicating when no additional edges should be added to a graph walk.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A graph walk satisfying the halting condition is called complete.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The start of the graph walk may either be specified by the user or chosen at random.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our goal is find a complete graph walk w that minimizes f .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To give the user control over what sorts of motions should be considered in the search, we allow restrictions on what edges may be appended to a given walk w.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, the user may decide that within a particular window of time a graph walk may only contain “sneaking” edges.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">A naıve solution is to use depth-first search to evaluate f for all complete graph walks and then select the best one.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, the number of possible graph walks grows exponentially with the average size of a complete graph walk.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">To address this we use a branch and bound strategy to cull branches of the search that are incapable of yielding a minimum.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since g(w, e) by assumption never decreases, f (w) is a lower bound on f (w + v) for any v, where w + v is the graph walk composed of v appended to w.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus we can keep track of the current best complete graph walk w opt and immediately halt any branch of the search for which the graph walk’s error exceeds f (w opt ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, the user may define a threshold error ε such that if f (w) &lt; ε , then w is considered to be “good enough” and the search is halted.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Branch and bound is most successful when we can attain a tight lower bound early in the search process.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this reason it is worthwhile to have a heuristic for ordering the edges we explore out of a particular node.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">One simple heuristic is to order the children greedily — that is, given a set of unexplored children c 1 , . . . , c n , we search the one that minimizes g(w, c i ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While branch and bound reduces the number of graph walks we have to test against f , it does not change the fact that the search process is inherently exponential — it merely lowers the effective branching factor.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this reason we generate a graph walk incrementally.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At each step we use branch and bound to find an optimal graph walk of n frames.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We retain the first m frames of this graph walk and use the final retained node as a starting point for another search.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This process continues until a complete graph walk is generated.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our implementation we used values of n from 80 to 120 frames (2 3 2 to 4 seconds) and m from 25 to 30 frames (about one second).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Sometimes it is useful to have a degree of randomness in the search process, such as when one is animating a crowd.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">There are a couple of easy ways to add randomness to the search process without sacrificing a good result.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">The first is to select a start for the search at random.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">The second is retain the r best graph walks at the end of each iteration of the search and randomly pick among the ones whose error is within some tolerance of the best solution.</Sentence>
      
      
        <H2>4.3 Deciding What To Ask For</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Since the motion extracted from the graph is determined by the function g, it is worth considering what sorts of functions are likely to produce desirable results.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To understand the issues involved, we consider a simple example.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Imagine we want to lay down two clips on the floor and create a motion that starts at the first clip and ends at the second.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Both clips must end up in the specified position and orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can formally state this problem as follows: given a starting node N in the graph and a target edge e, find a graph walk this section.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The halting condition was to play a specific clip of two kicking motions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The error of a complete graph walk (which necessarily ended with the kicking clip) was determined by how far away this kicking clip was from being in a particular position and orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The character spends approximately seven seconds making minute adjustments to its orientation in an attempt to better align itself with the final clip.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The highlighted line shows the the path of the target clip in its desired position and orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">that ends with e such that the transformation T applied to e is as close as possible to a given transformation T .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">What one will receive is a motion like in Figure 5 , where the initial clip is a walking motion and the final clip is a kick.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The character turns around in place several times in an attempt to better line up with the target clip.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While it’s conceivable that given a larger database we would have found a better motion, the problem here is with the function we passed into the search algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, it gives no guidance as to what should be done in the middle of the motion; all that matters is that the final clip be in the right position and orientation.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This means the character is allowed to do whatever is possible in order to make the final fit, even if the motion is nothing that a real person would do.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Second, the goal is probably more specific than necessary.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If it doesn’t matter what kick the character does, then it should be allowed to choose a kick that doesn’t require such effort to aim.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More generally, there are two lessons we can draw from this example.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, g should give some sort of guidance throughout the entire motion, as arbitrary motion is almost never desirable.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Second, g should be no more restrictive than necessary, in order to give the search algorithm more goals to seek.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note the tradeoff here — guiding the search toward a particular result must be balanced against unduly preventing it from considering all available options.</Sentence>
        6
        To appear in Proceedings of SIGGRAPH ’02
        
          
          Figure 5: The above motion was generated using the search algorithm discussed in
        
      
      
        <H1>5 Path Synthesis</H1>
        <Sentence aspectClass="NONE" inAbstract="false">We have cast motion extraction as an optimization problem, and we have given some reasons why the formulation of this optimization can be difficult.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To demonstrate that it is nonetheless possible to come up with optimization criteria that allow us to solve a real problem, we apply the preceding framework to path synthesis.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This problem is simple to state: given a path P specified by the user, generate motion such that the character travels along P. In this section we present our algorithm for path synthesis, present results, and discuss applications of the technique.</Sentence>
      
      
        <H2>5.1 Implementing Path Synthesis</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Given the framework in the previous section, our only tasks are to define an error function g(w, e) and appropriate halting criteria.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The basic idea is to estimate the actual path P travelled by the character during a graph walk and measure how different it is from P. The graph walk is complete when P is sufficiently long.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">A simple way to determine P is to project the root onto the floor at each frame, forming a piecewise linear curve 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Let P(s) be the point on P whose arc-length distance from the start of P is s.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The i th frame of the graph walk, w i , is at some arc length s(w i ) from the start of P .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We define the corresponding point on P as the point at the same arc length, P(s(w i )).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the j th frame of e, we calculate the squared distance between P (s(e j )) and P(s(e j )).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">g(w, e) is the sum of these errors:</Sentence>
        
          9
          n g(w, e) = ∑ P (s(e i )) − P(s(e i )) 2 i=1
        
        <Sentence aspectClass="NONE" inAbstract="false">Note that s(e i ) depends on the total arc length of w, which is why this equation is a function of w as well as e.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The halting condition for path synthesis is when the current total length of P meets or exceeds that of P. Any frames on the graph walk at an arc length longer than the total length of P are mapped to the last point on P. The error function g(w, e) was chosen for a number of reasons.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">First, it is efficient to compute, which is important in making the search algorithm practical.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Second, the character is given incentive to make definite progress along the path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we were to have required the character to merely be near the path, then it would have no reason not to alternate between travelling forwards and backwards.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, this metric allows the character to travel at whatever speed is appropriate for what needs to be done.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, a sharp turn will not cover distance at the same rate as walking straight forward.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Since both actions are equally important for accurate path synthesis, it is important that one not be given undue preference over the other.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">One potential problem with this metric is that a character who stands still will never have an incentive to move forward, as it can accrue zero error by remaining in place.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While we have not encountered this particular problem in practice, it can be countered by requiring at least a small amount of forward progress γ on each frame.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More exactly, we can replace in Equation 9 the function s(e i ) with t(e i ) = max(t(e i−1 ) + s(e i ) − s(e i−1 ),t(e i−1 ) + γ ).</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Typically the user will want all generated motion to be of a single type, such as walking.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This corresponds to confining the search to the subgraph containing the appropriate set of descriptive labels.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More interestingly, one can require different types of motion on different parts of the path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, one might want the character to walk along the first half of the path and sneak down the rest.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The necessary modifications to accomplish this are simple.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will consider the case of two different motion types; the generalization to higher numbers is trivial.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We divide the original path into two smaller adjoining paths, P 1 and P 2 , based on where the transition from type T 1 to type T 2 is to occur.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the character is currently fitting P 2 , then the algorithm is identical to the single-type case.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If the character is fitting P 1 , then we check to see if we are a threshold distance from the end of P 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If not, we continue to only consider edges of type T 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Otherwise we allow the search to try both edges of type T 1 and T 2 ; in the latter case we switch to fitting P 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that we only allow this switch to occur once on any given graph walk, which prevents the resulting motion from randomly switching between the two actions.</Sentence>
      
      
        <H2>5.2 Results</H2>
        <Sentence aspectClass="NONE" inAbstract="false">While the examples shown in Figure 1 suggest that our technique is viable, it perhaps isn’t surprising that we were able to find accurate fits to the given paths.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As shown in the upper portion of the 1 In our implementation we defined the path as a spline approximating this piecewise linear path, although this has little impact on the results.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">figure, the input motion had a fair amount of variation, including straight-ahead marches, sharp turns, and smooth changes of curvature.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">However, our algorithm is still useful when the input database is not as rich.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Refer to Figure 6 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We started with a single 12.8second clip of an actor sneaking along the indicated path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To stretch this data further, we created a mirror-image motion and then built a motion graph out of the two.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">From these we were able to construct the new motions shown at the bottom of the figure, both of which are themselves approximately 13 seconds in length.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Figure 7 shows fits to a more complicated path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The first example uses walking motions and the second uses martial arts motions; the latter demonstrates that our approach works even on motions that are not obviously locomotion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the walking motion, the total computation time was nearly the same as the length of the generated animation (58.1 seconds of calculation for 54.9 seconds animation).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The martial arts motion is 87.7 seconds long and required just 15.0 seconds of computation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In general, in our test cases the duration of a generated motion was either greater than or approximately equal to the amount of time needed to produce it.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Both motion graphs had approximately 3000 frames (100 seconds) of animation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, Figure 8 shows paths containing constraints on the allowable motion type.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the first section of each path the character is required to walk, in the second it must sneak, and in the third it is to perform martial arts moves.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Not only does the character follow the path well, but transitions between action types occur quite close to their specified locations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This example used a database of approximately 6000 frames (200 seconds).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">All examples were computed on a 1.3GHz Athlon.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For our largest graph (about 6000 frames), approximately twenty-five minutes were needed to compute the locations of all candidate transitions points.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Approximately five minutes of user time were required to select transition thresholds, and it took less than a minute to calculate blends at these transitions and prune the resulting graph.</Sentence>
        7
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H2>5.3 Applications Of Path Synthesis</H2>
        <Sentence aspectClass="NONE" inAbstract="false">Directable locomotion is a general enough need that the preceding algorithm has many applications.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Interactive Control.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We can use path synthesis techniques to give a user interactive control over a character.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, when the user hits the left arrow key the character might start travelling east.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">To accomplish this, we can use the path fitting algorithm to find the sequence of edges starting from our current location on the graph that best allow the character to travel east.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The first edge on the resulting graph walk is the next clip that will be played.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This process may then be repeated.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To make this practical, we can precompute for every node in the graph a sequence of graph walks that fit straight-line paths in a sampling of directions (0 degrees, 30 degrees, .</Sentence> . . ). <Sentence aspectClass="NONE" inAbstract="false">The first edges on these paths are then stored for later use; they are the best edges to follow given the direction the character is supposed to travel in.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">High-Level Keyframing.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we want a character to perform certain actions in a specific sequence and in specific locations, we can draw a path with subsections requiring the appropriate action types.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This allows us to generate complex animations without the tedium of manual keyframing.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this reason we term this process “highlevel” keyframing — the user generates an animation based on what should be happening and where.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Motion Dumping.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If an AI algorithm is used to determine that a character must travel along a certain path or start performing certain actions, the motion graph may be used to “dump” motion on top of the algorithm’s result.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence motion graphs may be used as a back-end for animating non-player characters in video games and interactive environments — the paths and action types can be specified by a high-level process and the motion graph would fill in the details.</Sentence> Crowds. <Sentence aspectClass="ADVANTAGE" inAbstract="false">While our discussion so far has focused on a single character, there’s no reason why it couldn’t be applied to several characters in parallel.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Motion graphs may be used as a practical tool for crowd generation.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">For example, a standard collision-avoidance algorithm could be used to generate a path for each individual, and the motion graph could then generate motion that conforms to this path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Moreover, we can use the techniques described at the end of Section 4.2 to add randomness to the generated motion.</Sentence>
      
      
        <H1>6 Discussion</H1>
        <Sentence aspectClass="NOVELTY" inAbstract="false">In this paper we have presented a framework for generating realistic, controllable motion through a database of motion capture.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Our approach involves automatically constructing a graph that encapsulates connections among different pieces of motion in the database and then searching this graph for motions that satisfy user constraints.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">We have applied our framework to the problem of path synthesis.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As we had limited access to data, our largest examples used a database of several thousand frames of motion.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">While we believe this was sufficient to show the potential of our method, a character with a truly diverse set of actions might require hundreds or thousands of times more data.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence the scalability of our framework bears discussion.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">The principle computational bottleneck in graph construction is locating candidate transitions (Section 3.1).</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">This requires comparing every pair of the F frames in the database and therefore involves O<CitSpan>(F 2 )</CitSpan> operations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, this calculation is trivial to parallelize, and distances between old frames needn’t be recomputed if additions are made to the database.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">It is the exception rather than the rule that two pieces of motion are sufficiently similar that a transition is possible, and hence motion graphs tend to be sparse.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our experience the necessary amount of storage is approximately proportional to the size of the database.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">The number of edges leaving a node in general grows with the size of the graph, meaning the branching factor in our search algorithm may grow as well.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, we expect that future motion graphs will be larger mainly because the character will be able to perform more actions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">That is, for example, having increasing amounts of walking motion isn’t particularly useful once one can direct a character along nearly any path.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Hence the branching factor in a particular subgraph will remain stationary once that subgraph is sufficiently large.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We anticipate that typical graph searches will be restricted to one or two subgraphs, and so we expect that the search will remain practical even for larger graphs.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We conclude with a brief discussion of future work.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">One limitation of our approach is that the transition thresholds must be specified by hand, since (as discussed in Section 3.2) different kinds of motions have different fidelity requirements.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">Setting thresholds in databases involving many different kinds of motions may be overly laborious, and so we are investigating methods for automating this process.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A second area of future work is to incorporate parameterizable motions <CitSpan>[Wiley and Hahn 1997; Rose et al. 1998]</CitSpan> into our system, rather than having every node correspond to a static piece of motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This would add flexibility to the search process and potentially allow generated motion to better satisfy user constraints.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, we are interested in applying motion graphs to problems other than path synthesis.</Sentence>
        8
        To appear in Proceedings of SIGGRAPH ’02
        
          
          Figure 6: The leftmost image shows the original motion and its reflection and the following images show motion generated by our path synthesis algorithm. The thick yellow lines were the paths to be fit and the black line is an approximation of the actual path of the character. Note how we are able to accurately fit nontrivial paths despite the limited variation in the path of the original motion.
        
        
          
          Figure 7: The left image shows a walking motion generated to fit to a path that spells “Hello” in cursive. The right image shows a karate motion fit to the same path. The total calculation time for the walking motion was 58.1 seconds and the animation itself is 54.9 seconds. The 87.7-second karate motion was computed in just 15.0 seconds. All computation was done on a 1.3gHz Athlon.
        
        
          
          Figure 8: These images are both fits to paths wherein the character is required to walk, then sneak, and finally perform martial arts moves. The desired transition points are indicated by where the curve changes color. Note that the character both fits the path accurately and switches to the appropriate motion type close to the desired location.
        
        9
        To appear in Proceedings of SIGGRAPH ’02
      
      
        <H1>Acknowledgements</H1>
        <Sentence aspectClass="NONE" inAbstract="false">We would like to acknowledge Andrew Gardner, Alex Mohr, and John Schreiner for assisting in video production, proofreading, and other technical matters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also thank the University of Southern California’s School of Film and Television for their support and the reviewers for their many useful suggestions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our work was made possible through generous motion data donations from Spectrum Studios (particularly Demian Gordon), House of Moves, and The Ohio State University.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This work was supported in part by NSF grants CCR-9984506 and IIS-0097456, the U.S. Army 2 , the Wisconsin Alumni Research Fund’s University Industrial Relations program, equipment donations from IBM, NVidia, and Intel, and software donations from Discreet, Alias/Wavefront, and Pixar.</Sentence>
      
      
        <H1>References</H1>
        
          A RIKAN , O., AND F ORSYTHE , D. 2002. Interactive motion generation from examples. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          B OWDEN , R. 2000. Learning statistical models of human motion. In IEEE Workshop on Human Modelling, Analysis, and Synthesis, CVPR 2000, IEEE Computer Society.
          B RAND , M., AND H ERTZMANN , A. 2000. Style machines. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, ACM SIGGRAPH, 183–192.
          B RUDERLIN , A., AND C ALVERT , T. 1996. Knowledge-driven, interactive animation of human running. In Graphics Interface, Canadian Human-Computer Communications Society, 213–221.
          B RUDERLIN , A., AND W ILLIAMS , L. 1995. Motion signal processing. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 97–104.
          F ALOUTSOS , P., VAN DE P ANNE , M., AND T ERZOPOULOS , D. 2001. Composable controllers for physics-based character animation. In Proceedings of ACM SIGGRAPH 2001, Annual Conference Series, ACM SIGGRAPH, 251–260.
          G ALATA , A., J OGNSON , N., AND H OGG , D. 2001. Learning variable-length markov models of behavior. Computer Vision and Image Understanding Journal 81, 3, 398–413.
          G LEICHER , M. 1998. Retargeting motion to new characters. In Proceedings 0f ACM SIGGRAPH 98, Annual Conference Series, ACM SIGGRAPH, 33–42.
          G LEICHER , M. 2001. Motion path editing. In Proceedings 2001 ACM Symposium on Interactive 3D Graphics, ACM.
          H ODGINS , J. K., W OOTEN , W. L., B ROGAN , D. C., AND O’B RIEN , J. F. 1995. Animating human athletics. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 71–78.
          K OVAR , L., G LEICHER , M., AND S CHREINER , J. 2002. Footskate cleanup for motion capture editing. Tech. rep., University of Wisconsin, Madison.
          L AMOURET , A., AND P ANNE , M. 1996. Motion synthesis by example. Computer animation and Simulation, 199–212.
          L EE , J., AND S HIN , S. Y. 1999. A hierarchical approach to interactive motion editing for human-like figures. In Proceedings of ACM SIGGRAPH 99, Annual Conference Series, ACM SIGGRAPH, 39–48.
          L EE , J., C HAI , J., R EITSMA , P. S. A., H ODGINS , J. K., AND P OLLARD , N. S. 2002. Interactive control of avatars animated with human motion data. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          L EE , J. 2000. A hierarchical approach to motion analysis and synthesis for articulated figures. PhD thesis, Department of Computer Science, Korea Advanced Institute of Science and Technology.
          L I , Y., W ANG , T., AND S HUM , H.-Y. 2002. Motion texture: A two-level statistical model for character motion synthesis. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH. 2 This paper does not necessarily reflect the position or the policy of the
          Government, and no official endorsement should be inferred
          M IZUGUCHI , M., B UCHANAN , J., AND C ALVERT , T. 2001. Data driven motion transitions for interactive games. In Eurographics 2001 Short Presentations.
          M OLINA -T ANCO , L., AND H ILTON , A. 2000. Realistic synthesis of novel human movements from a database of motion capture examples. In Proceedings of the Workshop on Human Motion, IEEE Computer Society, 137–142.
          M ULTON , F., F RANCE , L., C ANI , M.-P., AND D EBUNNE , G. 1999. Computer animation of human walking: a survey. The Journal of Visualization and Computer Animation 10, 39–54. Published under the name Marie-Paule Cani-Gascuel.
          P ERLIN , K., AND G OLDBERG , A. 1996. Improv: A system for scripting interactive actors in virtual worlds. In Proceedings of ACM SIGGRAPH 96, ACM SIGGRAPH, 205–216.
          P ERLIN , K. 1995. Real time responsive animation with personality. IEEE Transactions on Visualization and Computer Graphics 1, 1 (Mar.), 5–15.
          P ULLEN , K., AND B REGLER , C. 2000. Animating by multi-level sampling. In IEEE Computer Animation Conference, CGS and IEEE, 36–42.
          P ULLEN , K., AND B REGLER , C. 2002. Motion capture assisted animation: Texturing and synthesis. In Proceedings of ACM SIGGRAPH 2002, Annual Conference Series, ACM SIGGRAPH.
          R OSE , C., G UENTER , B., B ODENHEIMER , B., AND C OHEN , M. F. 1996. Efficient generation of motion transitions using spacetime constraints. In Proceedings of ACM SIGGRAPH 1996, Annual Conference Series, ACM SIGGRAPH, 147–154.
          R OSE , C., C OHEN , M., AND B ODENHEIMER , B. 1998. Verbs and adverbs: Multidimensional motion interpolation. IEEE Computer Graphics and Application 18, 5, 32–40.
          S CH ODL  ̈ , A., S ZELISKI , R., S ALESIN , D., AND E SSA , I. 2000. Video textures. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, ACM SIGGRAPH, 489–498.
          S UN , H. C., AND M ETAXAS , D. N. 2001. Automating gait animation. In Proceedings of ACM SIGGRAPH 2001, Annual Conference Series, ACM SIGGRAPH, 261– 270.
          W ASHBURN , D. 2001. The quest for pure motion capture. Game Developer (December).
          W ILEY , D., AND H AHN , J. 1997. Interpolation synthesis of articulated figure motion. IEEE Computer Graphics and Application 17, 6, 39–45.
          W ITKIN , A., AND P OPOVI C  ́ , Z. 1995. Motion warping. In Proceedings of ACM SIGGRAPH 95, Annual Conference Series, ACM SIGGRAPH, 105–108.
        
        10
      
    
  

</Document>
