<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A27_F07_Highly_Adaptive_Liquid_Simulations__on_Tetrahedral_Meshes_SUMMARY_v1.xml">


  
    1bc32fd79f71ddaed6dc90f472a41b0eaae0eba6d03053a8819e16a4b2305917
    3x6m
    http://dx.doi.org/10.1145/2461912.2461982
  
  
    
      
        <Title>Highly Adaptive Liquid Simulations on Tetrahedral Meshes</Title>
      
      
        
          Ryoichi Ando ∗ Nils Thürey † Kyushu University ScanlineVFX
          ∗
        
      
      ∗ E-mail: and@verygood.aid.design.kyushu-u.ac.jp † E-mail: nils.thuerey@scanlinevfx.com ‡ E-mail: wojtan@ist.ac.at
      
        
        Figure 1: Our adaptive simulation framework allows us to efficiently simulate highly detailed splashes on large open surfaces. In this case, maximum BCC mesh resolutions from 8 to 1024 cells were used, leading to strong horizontal grading along the surface.
      
      <Abstract>
<Sentence inAbstract="true">We introduce a new method for efficiently simulating liquid with extreme amounts of spatial adaptivity.</Sentence> <Sentence inAbstract="true">Our method combines several key components to drastically speed up the simulation of largescale fluid phenomena: We leverage an alternative Eulerian tetrahedral mesh discretization to significantly reduce the complexity of the pressure solve while increasing the robustness with respect to element quality and removing the possibility of locking.</Sentence> <Sentence inAbstract="true">Next, we enable subtle free-surface phenomena by deriving novel second-order boundary conditions consistent with our discretization.</Sentence> <Sentence inAbstract="true">We couple this discretization with a spatially adaptive Fluid-Implicit Particle (FLIP) method, enabling efficient, robust, minimally-dissipative simulations that can undergo sharp changes in spatial resolution while minimizing artifacts.</Sentence> <Sentence inAbstract="true">Along the way, we provide a new method for generating a smooth and detailed surface from a set of particles with variable sizes.</Sentence> <Sentence inAbstract="true">Finally, we explore several new sizing functions for determining spatially adaptive simulation resolutions, and we show how to couple them to our simulator.</Sentence> <Sentence inAbstract="true">We combine each of these elements to produce a simulation algorithm that is capable of creating animations at high maximum resolutions while avoiding common pitfalls like inaccurate boundary conditions and inefficient computation.</Sentence>
</Abstract>
	  I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Physically based modeling Keywords: motion editing, motion signal-processing, spacetime constraints, motion capture.	  
	  
      
        
          Chris Wojtan ‡ IST Austria
        
      
      Links:
      
        
      
      DL PDF
      
        
      
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence inAbstract="false" summaryRelevanceScore="5.00">This paper aims to produce fluid simulations with a high degree of spatial adaptivity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">We desire to enable a simulator to focus its computational resources on the visually interesting regions of a fluid flow, while remaining computationally efficient and avoiding common artifacts due to a spatially adaptive pressure solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Previous approaches have made great strides towards this goal, but they often exhibit visual artifacts, a lack of computational robustness, or an unacceptably hefty computational expense.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The groundbreaking work of <CitSpan>Losasso et al. [2004]</CitSpan> introduced an octree for spatial adaptivity, but it suffers from spurious flows at T-junctions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Finite volume methods <CitSpan>[Batty et al. 2010]</CitSpan> repair these spatial artifacts at the expense of solving a significantly larger system of equations and sacrificing computational stability near poorly-shaped elements.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Furthermore, many existing methods still are not truly spatially adaptive in the sense that their computational complexity is still tied to a uniform grid or spatial parameter.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">We introduce a combination of techniques that successfully makes adaptive fluid simulation practical at large scales.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">We first reduce memory and computational costs by switching from a finite volume method to a discretization with a significantly smaller linear system for the pressure solve, which has the side effect of increasing the simulator’s robustness to poor-quality elements and effectively preventing locking artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">We next derive second-order Dirichlet boundary conditions consistent with our discretization to benefit from the subtle surface dynamics associated with an accurate pressure solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">We combine this robust and efficient tetrahedral meshbased fluid simulator with a spatially adaptive method for sampling particles for FLIP-based velocity advection, giving us a method free from any single spatial resolution.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">In addition to our adaptive FLIP simulator, we also introduce a new method for computing a surface from a distribution of particles with variable radii.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.33">We found that this method out-performs previous methods in cases of extreme spatial adaptivity by exhibiting smoother surfaces without sacrificing detail.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our fluid simulator works well with spatially adaptive tetrahedral meshes, but it is another question to decide exactly how these adaptive meshes should be generated.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We investigate various methods for generating these adaptive meshes by experimenting with several sizing functions, allowing us to precisely dictate where simulation detail should occur.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Some examples are a surface curvature-based metric that adds detail only where needed on the fluid surface, a turbulence metric that adds detail only where interesting fluid motion occurs, and a visibility metric that adds detail only in front of a virtual camera.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">Concretely, the contributions of our work are: • a novel tetrahedral discretization of the pressure projection step that is efficient to solve and robust to poor-quality elements; • an accurate treatment of second-order boundary conditions within the tetrahedral mesh; • a new technique for extracting a smooth surface from particles with varying radii; • and the inclusion of a flexible sizing function to focus computational resources on important areas of the flow with minimal overhead.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">These contributions work together to produce a practical fluid simulator that exhibits low computational and memory complexity, fewer visual artifacts, and a high effective simulation resolution.</Sentence>
      
        <H1>2 Related Work</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our work is based on the Fluid-Implicit Particle (FLIP) method introduced to the computer graphics community by <CitSpan>Zhu and Bridson [2005]</CitSpan>, which arguably represents the state-of the art for detailed and robust liquid simulations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The algorithm still follows the general ideas of the Stable Fluid solver <CitSpan>[Stam 1999]</CitSpan>, and can be readily combined with second-order treatment of free surface boundary conditions <CitSpan>[Enright et al. 2003]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">FLIP derives its success from the fact that it uses particles to compute an accurate, nondiffusive transport of flow quantities, in combination with a gridbased solve to accurately enforce constraints for mass conservation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The FLIP algorithm is heavily used in the special effects industry, and recent advances have introduced accurate coupling with obstacles <CitSpan>[Batty et al. 2007]</CitSpan>, highly viscous materials <CitSpan>[Batty and Bridson 2008]</CitSpan>, and two-phase flows <CitSpan>[Boyd and Bridson 2012]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Traditionally, Cartesian grids are very popular for fluid simulations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The Marker-And-Cell (MAC) approach <CitSpan>[Harlow and Welch 1965]</CitSpan>, which stores velocity components at cell faces and pressure samples at cell centers, results in discretizations with good properties in terms of stability and accuracy.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">An inherent difficulty is that simulations on regular grids become prohibitively expensive for large resolutions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Thus, many works have proposed methods to focus the computations on regions that are of particular interest.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">One example are octrees, which were used by Losasso et al. [2004; 2005] to refine the computational grid in a controllable way.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">This approach, however, suffers from numerical diffusion and an inconsistent discretization near the tree’s T-junctions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Targeting a similar direction as our work, <CitSpan>Hong et al. [2009] and Ando et al. [2012]</CitSpan> have demonstrated methods to adapt the resolution of FLIP particles in a simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Both methods, in contrast to ours, focus on static computational grids and are restricted to smaller differences in particle size.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Although Cartesian grids are widely used, they are limited in their flexibility to adapt to a simulation setup.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Because of this, tetrahedral grids are popular for methods targeting adaptivity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In combination with a suitable method to discretize the problem at hand, they allow for very flexible computational grids.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">One example is the work of Klingner et al. <CitSpan>[Klingner et al. 2006]</CitSpan> which demonstrated the use of a Stable Fluids based solver for tetrahedral grids conforming to object boundaries.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Another example is the non-linear fluid solver developed by <CitSpan>Mullen et al. [2009]</CitSpan>, which leads to an energy conserving solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Unlike these methods, we make use of a non-conforming grid with Body-Centered Cubic (BCC) lattices.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">These meshes were also used by <CitSpan>Chentanez et al. [2007]</CitSpan> and by <CitSpan>Batty et al. [2010]</CitSpan> for liquid simulations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We will denote this class of algorithms as Finite Volume Methods (FVM).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">These methods are primarily suitable for uniformly sampled particles, and we will demonstrate in Section 7 that their placement of pressure samples at tetrahedral circumcenters leads to numerical problems in combination with graded BCC meshes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Another direction of research performs fluid simulations based on arbitrary elements.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">
<CitSpan>Clausen et al. [2013] and Misztal et al. [2010]</CitSpan> have proposed a method to simulate liquids with a computational grid conforming to a triangulation of a liquid surface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Both methods lead to an increased computational cost in comparison to the more efficient tetrahedral BCC meshes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">
<CitSpan>Sin et al. [2009]</CitSpan> proposed an alternative method for hybrid Lagrangian-Eulerian solvers which combines a Voronoi-based pressure solver and particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Using this Vornoi-based approach for tetrahedral meshes would yield a pressure matrix similar to ours.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Like our method, <CitSpan>Brochu et al. [2010]</CitSpan> used this discretization in combination with embedded second-order boundary conditions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Both of these approaches discretize velocities with per-face flux values, while we store velocity vectors at cell barycenters.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Adaptive simulations have also been explored in the context of SPH simulations without Eulerian grids.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The work of <CitSpan>[Adams et al. 2007]</CitSpan> shares similarities with our approach, as it is able to simulate a wider range of particle radii, and it proposes a surface reconstruction method in the adaptive setting.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We will show in Section 5 that our surface creation method results in surfaces with fewer visual artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Additionally, a robust and efficient method for adaptive SPH simulations was introduced by <CitSpan>Solenthaler et al. [2011]</CitSpan>, but this work primarily targets the coupling of two different particle resolutions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Several other methods have been proposed to reconstruct smooth surfaces around collections of particles without orientation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">One approach that is commonly used is to compute a signed distance function with averaged particle radii and centroids <CitSpan>[Zhu and Bridson 2005]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">A variant of this approach, taking into account information about the spatial variance of the particle’s neighborhood was proposed by <CitSpan>Yu et al. [2010]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Both methods primarily target particles with constant radius.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">More recently, a level-set based method was proposed that computes a constrained optimization with bihar- monic smoothing <CitSpan>[Bhattacharya et al. 2011]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">However, such an optimization would be complicated to apply in our unstructured setting.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">In contrast to these methods, our approach for surface creation computes the union of convex hulls around triplets of particles, which leads to a smooth and closed surface around a collection of arbitrarily sized particles.</Sentence>
      
      
        <H1>3 Fluid Solver</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="3.33">The aim of our method is to solve the Navier-Stokes equations, which for incompressible, Newtonian, inviscid flows can be written as ρDu/Dt = − p + f , with the additional constraint · u = 0 to enforce a divergence-free velocity field.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Here, u, p and f denote velocity, pressure and external forces, respectively, while D/Dt denotes the material derivative.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The density ρ is constant in our case.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We solve these equations using operator splitting <CitSpan>[Stam 1999]</CitSpan>, and a level set φ(x) = 0 defines the position of the liquid-gas interface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Spatial Discretization An inherent strength of the FLIP algorithm is its hybrid nature.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The motion of the fluid is computed in a Lagrangian manner using particles, while the pressure projection step is computed on an Eulerian grid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We will now describe how we compute the pressure projection using a tetrahedral discretization.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This projection of the velocities into a divergence-free state can be formulated as the Poisson problem</Sentence>
        
          1
          ∆t 2 p = · u ∗ , ρ
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where u ∗ denotes an intermediate velocity after the advection.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In the following, however, we prefer an alternate view that looks at this problem from an energy minimization perspective: we want to compute the minimal change in kinetic energy necessary to reach a divergence-free state of the flow similar to <CitSpan>[Batty et al. 2007]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This can be formulated as:</Sentence>
        
          2
          p = arg min 1 ||u ∗ − ∆t p|| 2 ρdV p Ω 2 ρ
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.33">Here, Ω represents the domain of the computational grid, and we choose to discretize this space using tetrahedral cells.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This has the advantage of giving us a natural way to handle cells of different size, while yielding a consistent discretization of the differential operators involved.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We store pressure samples at the nodes of the tetrahedral mesh, while velocities are stored at cell centers.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This configuration is illustrated in Figure 2 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Note that by assuming a piece-wise constant velocity and a linear change of pressure within a cell, this setup results in a constant pressure gradient per tetrahedron, by construction.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In the following, we denote the number of cells with m and the number of nodes with n, and we indicate discretized quantities with caret notation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Based on this representation we can discretize Eq.</Sentence> <CitSpan>(2)</CitSpan> with
        
          3
          m p = arg min 1 || u ˆ i ∗ − ∆t [ ] p|| 2 ρV i , p ˆ 2 ρ i
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where we denote the volume of a cell with V i and the discretized gradient operator with [ ].</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">It consists of a m×n matrix, computing a per-tetrahedron gradient from nodal values.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Consequently, we define the divergence operator to be the transpose of the discretized gradient.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Before we go ahead to define [ ], we want to outline the rest of the steps for our pressure solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We solve equation Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(3)</CitSpan> with the commonly used least squares technique, yielding</Sentence>
        
          4
          ∆t T T ∗ [ ] V [ ] p = [ ] V u ˆ , ρ
        
        
          
          
          
          Figure 2:
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.33">Our discretization compared to previous approaches: the MAC grid stores velocity components normal to faces and pressure values at the center.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The FVM discretizations follow along these lines and store velocities normal to faces and pressure values at the circumcenter of a cell.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In our approach we store a 3component velocity vector at the barycenter of a cell and pressure values at each node.</Sentence>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where V denotes a matrix containing the V i as diagonal entries.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The [ ] T [ ] matrix-matrix multiplication results in a square n × n matrix, which is symmetric and positive definite.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In the following, we will denote the matrix on the left hand side of Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(4)</CitSpan> as A. Given appropriate boundary conditions, we can use standard tools, such as a commonly used pre-conditioned conjugate gradient solver to compute a solution (we use the one suggested in <CitSpan>[Bridson 2008]</CitSpan>).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Now, all that is left to construct the left-hand side matrix and the right-hand side terms for Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(4)</CitSpan> is to define [ ].</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">As we assume a linear change of the pressure for each cell, we can use simple barycentric interpolation to retrieve the pressure p at a position inside a cell.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Given the nodal pressure values p 1..</Sentence>
<Sentence inAbstract="false" summaryRelevanceScore="1.0">4 and barycentric weights σ 1..</Sentence>
<Sentence inAbstract="false" summaryRelevanceScore="1.0">4 this means p = σ 1 p 1 + σ 2 p 2 + σ 3 p 3 + σ 4 p 4 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In line with finite element methods using linear elements, we define the gradient based on the partial derivatives of the barycentric interpolation.</Sentence> E.g.<Sentence inAbstract="false" summaryRelevanceScore="1.0">, the first component of the gradient for a cell is computed with</Sentence>
        
          5
          ∂ ∂σ 1 ∂σ 2 ∂σ 3 ∂σ 4 p = p 1 + p 2 + p 3 + p 4 . ∂x ∂x ∂x ∂x ∂x
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">To set up the final linear system of Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(4)</CitSpan> for the pressure solve, we loop over all tetrahedra to compute the derivatives of the barycentric interpolation, adding their contributions to the global matrix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In contrast to previous work, our pressure solve is a linear system that has n degrees of freedom, n being the number of nodes in the tetrahedral mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For our BCC mesh, n is in practice smaller than the number of tetrahedra m (by a factor of 6 on average).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">A direct implication of this smaller linear system is that it is faster to solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">A second, less obvious implication of the smaller linear system is that it effectively prevents artifacts known as locking.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">These artifacts are commonly observed in finite element methods for problems in elasticity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Different methods have been proposed to circumvent these problems, e.g., using linear elements for pressure instead of piece-wise constant ones <CitSpan>[Irving et al. 2007]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Other works explicitly smooth the pressure field to reduce locking problems <CitSpan>[Misztal et al. 2010]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In general, locking can be observed if the pressure basis can represent more, and higher-frequency, functions than the basis for the velocity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Thus, choosing a more restrictive basis for pressure, as in <CitSpan>[Irving et al. 2007]</CitSpan>, or explicitly removing high-frequency information from the pressure <CitSpan>[Misztal et al. 2010]</CitSpan>, reduces the chance of locking.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Our method, by construction, has more degrees of freedom for representing velocity fields than pressure fields.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Although we cannot prove that a local configuration over-constraining the velocities will never occur, the larger number of degrees of freedom for our velocities effectively prevents locking artifacts, and we have not encountered any in our tests.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Boundary Conditions Second-order boundary conditions are a central component for accurate and visually appealing simulations with non-conforming grids.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Achieving second-order accuracy for obstacle boundary conditions is straightforward with our discretization: we can rely on the formulation of previous work <CitSpan>[Batty et al. 2007]</CitSpan>, and set the volume of a cell V i in Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(4)</CitSpan> to the volume that is filled with fluid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For the free surface, we have to ensure that the Dirichlet boundary condition p = 0 is satisfied at the interface position.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Usually, this means computing a pressure value for nodes outside of the liquid so that a linear interpolation along an edge of a cell gives zero at the correct position <CitSpan>[Enright et al. 2005; Lew and Buscaglia 2008]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Considering two pressure samples along an edge, we’ll denote values inside the air with a G subscript, and values inside the liquid with an L subscript in the following.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For a Cartesian MAC grid, the ghost pressure value p G is given by p G = p L φ G /φ L .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In our case, however, this approach does not yield the desired result.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The reason is that our velocity samples are not in line with the direct connections of the pressure samples – they are not locally orthogonal to each other.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Instead, we have to ensure the boundary conditions result in the correct pressure value at the cell center.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In the following we will show how to derive suitable free-surface boundary conditions to ensure second-order accuracy within our framework.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In order to achieve accurate and smooth surface motions with our method, we compute the ghost pressure values p G with a linear combination of liquid pressure values as:</Sentence>
        
          6
          p G = w 1 p 1 + w 2 p 2 + w 3 p 3 ,
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where w n and p n denote unknown coefficients and adjacent liquid pressures in the same tetrahedron.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Note that for p i that are not inside of the liquid, we set w i = 0.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">In line with the traditional ghost fluid method, we define p G uniquely for each tetrahedron.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">To handle the most general case, let’s suppose that p 1..</Sentence>
<Sentence inAbstract="false" summaryRelevanceScore="1.0">3 are all liquid pressure values.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Once we have a value for p G , we can compute a pressure gradient for the tetrahedron and update the velocity at its center with:</Sentence>
        
          7
          u ˆ new = u ˆ ∗ − ∆t [ ] p G p 1 p 2 p 3 T ρ
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">In order to do this we need to compute the coefficients w n .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">p G can be rewritten in terms of a barycentric interpolation of the three values in the liquid as:</Sentence>
        
          8
          p G = p L φ G / φ  ̃ L
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">with φ  ̃ L = θ 1 φ 1 + θ 2 φ 2 + θ 3 φ 3 , and p L = θ 1 p 1 + θ 2 p 2 + θ 3 p 3 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Here the θ n are a set of barycentric coordinate coefficients such that θ 1 +θ 2 +θ 3 = 1, and a tilde superscript denotes a value interpolated with the barycentric weights.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Substituting Eq.8 into Eq.6 yields</Sentence>
        
          9
          w n = θ n φ G / φ  ̃ L .
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">That means the values w n are determined by those of the θ n coefficients, which we will compute in the following.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Note that, theoretically, θ n could take any values as long as they add up to one.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Before embedding the boundary conditions, the matrix entries of the pressure solve for a single tetrahedron are, according to Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(4)</CitSpan>, given by ∆t [ ] T V [ ]p = b.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The computation of the ghost fluid ρ values is independent of the right-hand side b, so we will restrict the discussion to the left hand side.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We denote the components of the local symmetric 4 × 4 matrix on the left hand side with:  λ 1 α β γ </Sentence>
        
          10
          α λ 2 a b    β a λ 3 c  γ b c λ 4
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.33">Assuming, without loss of generality, that the first vertex is the one outside of the liquid volume, we embed the boundary condition into
        M based on the w n coefficients.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Then the first row of the system is changed to:</Sentence>
        
          11
           1 −w 1 −w 2 −w 3   p G   0  α λ 2 a b p 1 b 1     =   .  β a λ 3 c   p 2   b 2  γ b c λ 4 p 3 b 3
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">We can extract two constraints for each θ n from this form, which, together with the barycentric coefficient constraint, give us a 3 × 3 matrix M that can be inverted analytically.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">A full derivation of these steps can be found in Appendix A. With this analytic expression we can compute the ghost pressure coefficients as:</Sentence>
        
          12
          φ G / φ  ̃ L  α  w = α + β + γ  β γ 
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">This boundary condition ensures second-order accuracy while maintaining symmetry when it is assembled into the matrix of Eq.</Sentence> <CitSpan>(4)</CitSpan>. <Sentence inAbstract="false" summaryRelevanceScore="1.0">If the quality of a tetrahedron is good, 0 &lt; θ n &lt; 1 is guaranteed.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In this case, the resulting matrix is symmetric positivedefinite and can be easily inverted by the commonly used preconditioned conjugate gradient methods.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">However, positive off-diagonal terms of the matrix can result in values of θ outside of the range <CitSpan>[0, 1]</CitSpan>, leading to an indefinite linear system.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In these cases we consider the tetrahedron to have a poor quality.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">When using ghost fluid boundary conditions with a regular MAC grid, it is common practice to clamp small values in the denominator of Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(9)</CitSpan> to prevent ill-conditioned pressure matrices.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Effectively, this means reverting to first-order accuracy when second-order accuracy is intractable.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We implement a similar step in our algorithm to overcome numerical problems resulting from badly shaped cells.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We check whether the ghost fluid boundary conditions would violate diagonal dominance of an equation in our linear system.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">If we detect such a case, we smoothly transition to first order accuracy.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Specifically, when we have computed M , we check if a resulting diagonal term M i,i is smaller than φλ 2..</Sentence>4 . <Sentence inAbstract="false" summaryRelevanceScore="1.0">Here, φ denotes a tolerance factor that we set to φ = 0.25.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Whenever we detect such a case, we compute a coefficient k with</Sentence>
        
          13
          φ − 1 φ − 1 φ − 1 k = min λ 2 , λ 3 , λ 4 , w 2 α w 3 β w 4 γ
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">and multiply each w n with k when embedding.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Note that this scaling does not break the symmetry of the resulting linear system.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">More specifically, for k = 1 this yields full second-order accuracy, while for badly shaped tetrahedra the resulting k = 0 means that we revert to the standard rounding strategy of a first order accurate method.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">With our BCC mesh, all regular BCC tetrahedra have very good quality and valid θ n values.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The graded BCC tetrahedra, on the other hand, can be of lower quality and can require the use of Eq.</Sentence> <CitSpan>(13)</CitSpan>. <Sentence inAbstract="false" summaryRelevanceScore="1.67">Luckily, in our tests these tetrahedra make up only a very small fraction of the mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Velocity Interpolation The FLIP advection step traces particles based on the velocities from the Eulerian grid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">For this we need to construct a continuous velocity field based on the discrete values in our tetrahedral mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">As we store velocities at the cell centers, the interpolation would ideally use the dual mesh consisting of the Voronoi cells of each node <CitSpan>[Brochu et al. 2010]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Unfortunately, performing interpolations within arbitrary Voronoi cells would be expensive and require a large amount of computation compared to the other steps of our simulator.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Instead, we have found the following approach to yield high speed and good accuracy: we first interpolate the centered velocities to the nodes, similar to <CitSpan>[Chentanez et al. 2007]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Instead of interpolating these averaged values directly (which would result in smeared out motion), we temporarily subdivide the cells of our mesh by inserting a vertex at the center where we have an accurate velocity sample.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We then perform barycentric interpolation based on these subdivided cells, ensuring a C 0 continuous velocity that retains the original velocities at cell centers.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Note that these four smaller tetrahedra do not have to be stored explicitly.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We construct them on the fly when a sample is requested from one of the original cells.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Manipulating FLIP particles The spacing between FLIP particles may drift over time, and high-frequency errors may contribute to a bumpy surface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We combat these problems by directly manipulating particle positions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">During each time step, we apply the position correction algorithm of <CitSpan>Ando et al. [2012]</CitSpan>; this algorithm essentially pushes each particle away from its neighbors to prevent clustering.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We also introduce two special behaviors when the particles are close to the liquid surface (less than a distance of six times the particle radius).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">First, we impose the constraint that the position correction step may only move particles near the surface tangentially to the fluid interface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Secondly, particles near the surface may leave gaps when they spread out quickly.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Our method naturally fills in these gaps by slightly pulling each particle towards the fluid interface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">For particles near the interface, this pulling force acts in addition to the position correction.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">FLIP particles that partake in splashes and sprays can pose a significant burden on computational resources, especially in an adaptive framework like ours.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This inefficiency stems from the fact that water droplets undergo extremely simple ballistic motion.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Theoretically, we know that such a small region with purely free-surface boundary conditions will yield zero internal forces, so we simply detect individual FLIP particles that have no neighbors within six times their radius, remove them from the pressure solve, and accelerate them with gravity instead.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">When these particles eventually enter the neighborhood of other particles at some point in the future, we resume treating them like fluid by returning them to the pressure solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">This decision allows us to avoid aggressively refining the tetrahedral mesh in locations where the physical motion is uninteresting.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Only a small percentage of the particles are simulated in this way, e.g., 1.7% on average for Figure 6 .</Sentence>
        
          
          Figure 3: A simple geometric setup creating a big splash inside a container. This simulation, with a maximum resolution of 256 cells, took 1.3 minutes per frame on average.
        
      
      
        <H1>4 Adaptivity</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="3.33">Our method achieves adaptivity by varying the mesh resolution over the computational domain.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our FLIP simulation performs computation on both a background volumetric mesh and on a set of particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">Given a sizing function that indicates the desired spatial level of detail, our method first creates a tetrahedral mesh with varying spatial resolution, and then it locally changes the particle density by splitting and merging operations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">To compute the spatially-varying background grid, we start with the Delaunay tetrahedralization of a set of points distributed in a body-centered cubic lattice configuration.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In order to make the mesh resolution change over space, we use the octree-based grading method which was proposed by <CitSpan>Labelle and Shewchuk [2007]</CitSpan> and later adopted in several adaptive simulation environments <CitSpan>[Chentanez et al. 2007; Wojtan and Turk 2008; Batty et al. 2010]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Similar to <CitSpan>[Batty et al. 2010]</CitSpan>, we generate a new tetrahedral mesh every ten time steps, instead of rebuilding the mesh on every consecutive step.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Also, the tetrahedral mesh is only temporarily used for the pressure solver, so no information is transferred from one time step to the next by storing it on the grid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Thus, we do not worry about re-sampling data when computing a new tetrahedral mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We change the size and number of particles in our simulation with splitting and merging operations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For this, we modify the strategy of <CitSpan>Ando et al. [2012]</CitSpan> to work within our framework: at each remeshing step, we loop through the particles and determine whether the resolution needs to be changed.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">If a particle is too small, then we merge it with its nearest neighboring particle, resulting in a particle whose radius is given by the combined volume of the two original particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">If a given particle is bigger than the desired size, then the particle is split in two.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The two new particles are placed randomly within the original particle’s radius and redistributed with a heuristic that attempts to fill in nearby gaps: We first compute the 24 midpoints m i between this particle and its 24 nearest neighbors.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Then we find the closest particle to each midpoint and store the squared distance as a weight ω i .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">The new particle’s position is equal to the weighted average of all nearby midpoints: x new = ω i m i / ω i .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">After a split or merge operation, the new particle’s velocity is computed using a volume-weighted average.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Also, we must take care to ensure that particles close to the surface do not introduce interfacial bumps when they split or merge; whenever we create a new particle that is less than 1.25 times its radius away from the surface (through either a split or a merge event), we move it in the surface normal direction such that its sphere lies exactly tangent to the liquid interface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Numerical viscosity in fluid simulations is tightly coupled to the spatial resolution resolving the flow.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We compensate for spatiallyvarying numerical viscosity caused by particles of various sizes in our simulation by adjusting the PIC/FLIP blending parameter in our FLIP simulation <CitSpan>[Bridson 2008]</CitSpan>.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Given quantities Q i,PIC and Q i,FLIP computed at particle i from PIC and FLIP simulations, respectively, the new quantity Q i is computed as a weighted blend between the two:</Sentence>
        
          
          Figure 4: For the perfectly planar particle placement shown in (a), the methods <CitSpan>[Zhu and Bridson 2005]</CitSpan> (b), <CitSpan>[Yu and Turk 2010]</CitSpan> (c), and <CitSpan>[Adams et al. 2007]</CitSpan> (d) do not result in a flat surface, while our method produces the desired result (e).
        
        
          14
          ν∆t ν∆t Q i = r i 2 Q i,PIC + (1 − r i 2 )Q i,FLIP
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where r i is the radius of particle i and ν is the viscosity of the flow.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We found that this strategy adequately eliminates any artifacts due to spatially varying numerical viscosity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Sizing Functions We define the level of detail in our simulations with a spatially varying sizing function S(x).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We have experimented with several different sizing functions depending on factors such as distance to a camera, distance to the liquid surface, curvature of the liquid surface, measures of fluid turbulence, and arbitrary analytical number fields.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our simulator is versatile enough to cope with any of these sizing functions, resulting in efficient simulations with highly variable levels of detail.</Sentence> E.g.<Sentence inAbstract="false" summaryRelevanceScore="1.33">, Figure 1 showcases a simulation where smallest and largest cells differ by a factor of 128.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In all of the examples in this paper, the sizing function is defined as a combination of five different metrics:</Sentence>
        
          15
          S(x) = max ( d(x), V (x, min(κ liquid (x), κ solid (x), e(x)) )
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">where x is the position of a point in space, and d(x) encodes the depth of the liquid by returning the absolute level set value of the liquid surface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This has the effect that motion near the surface has higher priority than motions far inside the bulk volume of the liquid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">V (x, y) is a view-dependent function that returns the value y if x is within the camera’s visible region and returns the maximum particle radius r max (representing the minimum surface resolution) otherwise.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The next two metrics are designed to prioritize geometric detail of the liquid surface and of obstacles by computing a desired resolution based on cuvature.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">κ liquid (x) returns 0.8 divided by the extrapolated curvature of the liquid interface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Similarly, κ solid (x) returns 1.6 W smooth (d solid , r max ) divided by the extrapolated curvature of the solid interface, where W smooth (x, h) is a smooth kernel function (1 − ||x|| 2 /h 2 ) 3 and d solid is the closest distance to the solid boundary.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">As a last component of our sizing function we found it beneficial to invest computational resources into keeping interesting motion of the flow field alive.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Inspired by turbulence models (used e.g. in <CitSpan>[Pfaff et al. 2010]</CitSpan>), we have found that the strain tensor of the flow field reliably indicates detailed motions, and we compute e(x) as 30 divided by the Frobenius norm of the fluid strain tensor computed from the velocity field.</Sentence>
      
      
        <H1>5 Surface Representation</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="4.00">We also introduce a new method for computing an implicit surface from a set of particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Given our set of FLIP particles with variable radii, we aim to implicitly represent the fluid surface by computing its signed distance function.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Several useful methods for computing a surface from a collection of particles have been proposed in the past <CitSpan>[Zhu and Bridson 2005; Adams et al. 2007; Yu and Turk 2010]</CitSpan>, but they tend to produce undesirably bumpy surfaces when considering particles of highly variable radii ( Figure 4 ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">In this section, we introduce a new strategy for computing an implicit surface from a set of particles of various sizes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">The main idea is to approximate the fluid surface with the union of the convex hulls of each triplet of nearby particles close to the surface.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">For each set of three FLIP particles near the surface, the convex hull forms a thickened triangle shape with rounded edges ( Figure 5 ).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We only consider particles that are less than a given distance apart, with the maximum distance equal to a constant scale factor l times the sum of the two particle radii.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">A small l shows more surface details, while a larger l tends to fill in small concavities.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We used l = 2 for most of the simulations in this paper.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We ultimately represent our surface as the union of all such local convex hull shapes, and the minimum signed distance from these shapes to a point in space defines the outer part of our level set function.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In practice, we compute the local convex hull by finding the two outermost planes tangent to a set of three spheres.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We efficiently compute the distance to these planes by analytically solving the polynomial system: ax 1 +by 1 +cz 1 +d = r 1 , ax 2 +by 2 +cz 2 +d = r 2 , ax 3 + by 3 + cz 3 + d = r 3 , a 2 + b 2 + c 2 = 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">where r i and x i , y i , z i are the radius and x, y, z coordinates of particle i, respectively.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">a, b, c, d are the variables defining our plane with the signed distance function ax + by + cz + d = 0.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Intuitively, the first three equations ensure that the plane is the right distance away from each particle with the normal facing away from them, and the final equation ensures that the plane equation is normalized to a distance function.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">These four equations represent the intersection of three hyperplanes and a hypercylinder in 4D {a, b, c, d} space.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We solve this system analytically by first finding the line of common intersection of the first three equations, and then intersecting this line with the cylinder represented by the final equation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The system has two solutions, representing the top and bottom planes of our convex hull shape.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The above calculation describes how to find the planar regions of the convex hull of a set of three spheres.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">By computing the conic and spherical convex hull facets ( Figure 5 , bottom right) in a similar fashion, we can easily compute the signed distance between this convex hull and a point in space.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">To evaluate our final level set value, we compute the minimum signed distance from a query point to all nearby convex hulls.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We evaluate the level set on each of the vertices of our adaptive BCC mesh, and we extract a triangle mesh using a marching tetrahedra algorithm.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We then perform a light mesh smoothing to increase the reliability of any curvature computations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The algorithm as described works perfectly for computing the level set outside of our particle surface, but it may lead to small gaps inside.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">To avoid the creation of holes, we temporarily reassign each particle’s radius: r i temp = max(r i , −kφ i ) where φ i is the particle’s stored level set value from the previous time step, and k is a constant set to 0.75 in our simulations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Using this temporary radius to compute the signed distance as described above will remove erroneous gaps inside the liquid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We need to compute liquid surfaces both for final visualization as well as for several calculations during the progress of our simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">For the final visualization, we compute an especially highresolution BCC mesh from all of our particles and proceed with the algorithm above.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The final surface creation is trivially parallelized, and takes around five minutes average per frame for all of our simulations.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We attempt to speed up the surface creation routine used for simulation computations by computing on the moderate-resolution BCC mesh used for simulation and ignoring ballistic particles (Section 3).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">We compare our surface creation routine with a few existing methods in Figure 4 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Most previous algorithms perform poorly in this comparison because they were not designed for particles with varying radii.</Sentence>
        
          
          Figure 5: The 2D version of our surface creation algorithm takes a pair of particles (top left) and computes their convex hull (bottom left). In 3D, we convert three nearby particles (top right) into a convex hull (bottom right) consisting of spherical (orange), conic (dark blue), and planar (light blue) segments.
        
      
      
        <H1>6 Implementation</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.33">At this point we have described all of the components of our simulator.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The resulting algorithm can be seen in Algorithm 1.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In the beginning of each step (line 2), we typically compute the level-set for the current particle configuration as described in Section 5.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We require the distance to the surface in several steps of our algorithm, so we store the level set values for each particle (line 3).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">When enough time has passed to trigger an update of the mesh, it becomes necessary to evaluate the sizing function.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">At this point, additional user-defined sizing functions could be computed as well.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Having the information from the sizing functions ready, we create a new BCC mesh and perform particle merging and splitting.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For mapping the particle velocities onto the grid (line 9) we use an SPH-like kernel function, which is weighted by the particle volume: max(v i (4r i 2 /d 2 − 1), 0), where v i is the particle volume and d is
        Algorithm 1: One step of our simulation algorithm.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">1 begin 2 Compute simulation surface S 3 Pre-compute φ for all particles 4 Correct particle positions x i 5 if Mesh update necessary then 6 Evaluate sizing function S(x) at x i 7 Build octree and BCC mesh 8 Merge and split particles 9 Compute mesh velocity u from particle velocities 10 Extrapolate u outside the liquid 11 Solve pressure p on the tetrahedral mesh, update u 12 Update particle velocities with gradient of p 13 Advect particles with u
        the distance to the particle center normalized with its radius.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The particle velocity update of line 12 uses barycentric interpolations as explained in Section 3.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Likewise, the grid-based velocity extrapolation of line 10 uses the nodal velocities of Section 3.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">A time step is completed by performing the pressure projection and advecting the particles in the resulting divergence-free velocity field.</Sentence>
      
      
        <H1>7 Results and Discussion</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="2.00">To evaluate the performance and robustness of our method in comparison to previous work we have performed an extensive series of tests.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">A selection of these can be found in the accompanying comparison video.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">One comparison that is particularly interesting is the one comparing our method to an FVM based simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Using a graded BCC mesh leads to problems with the latter, as the position of the circumcenter lies exactly on a face for the graded tetrahedrons.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In the graded region, this can result in two pressure samples from adjacent tetrahedra being placed at the exact same position.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">To alleviate this problem, <CitSpan>[Batty et al. 2010]</CitSpan> propose to slightly offset the pressure samples from the faces.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">However, our implementation of their method exhibited slow convergence and the velocity artifacts despite this fix.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The influence of the different components of our sizing function on the evolution of a simulation is difficult to depict with static images, so we refer to the accompanying video for a comparison.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">To evaluate the basis of our adaptive model without any influence of the camera dependent sizing function, we have simulated the simple geometric configuration shown in Figure 3 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For this setup, resolutions from 8 to 256 were used, resulting in 6 levels of adaptivity.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Timing information for the main steps of our algorithm over the course of this simulation can be found in Figure 8 and Figure 9 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">For this simulation, the initial configuration consisted of 168, 161 particles, and momentarily peaked up to 1, 048, 776 during the maximal extent of the splash (settling down again to around 250 thousand in the end).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Note that a full sampling of the initial configuration with a regular grid would have required approximately 6 million particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our measurements show that the run-time of our method has a strong linear relationship to the number of particles, and thus the visual complexity of the simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">The per-frame time is low at the beginning and end of the simulation, but strongly peaks during the complex splash in its middle.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Our visibility sizing function is highlighted by the setup shown in Figure 6 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Here the computational resources are focused on the visible region of a rotating camera, as the liquid splashes around a U-shaped corridor.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">Our solver efficiently resolves the complex motion near the camera, while effectively reducing the computational cost for parts that are not visible.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The simulation of Figure 7 shows</Sentence>
        
          
          Figure 6: Our visibility sizing function: as the liquid flows along the U-shaped corridor, the visible volume is simulated with a high resolution (surface shown in top row), while regions outside of the view frustrum are coarsened (particle view in bottom row).
        
        
          
             Setup Min. ∆x −1 Min. ∆x s −1 Max. ∆x −1 Duration frames
            
              
              
                
                   Figure 3
                   8
                   16
                   256
                   5h:09m
                   240
                
                
                   Figure 6
                   16
                   32
                   256
                   4h:26m
                   330
                
                
                   Figure 7
                   16
                   64
                   512
                   5h:55m
                   480
                
                
                   Figure 1
                   8
                   32
                   1024
                   12h:8m
                   160
                
              
            
          
          Setup Min. ∆x −1 Min. ∆x −1 s Max. ∆x −1 Duration frames Figure 3 8 16 256 5h:09m 240 Figure 6 16 32 256 4h:26m 330 Figure 7 16 64 512 5h:55m 480 Figure 1 8 32 1024 12h:8m 160
          Table 1: Resolutions and running times for our simulations (not including final surface creation). Here, ∆x −1 and ∆x −1 s denote the
        
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">number of BCC cells along one spatial axis for the simulation and for the surface generation, respectively.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">The simulations were run on a workstation with an Intel Core i7-3960X CPU with 3.30GHz running under Linux.</Sentence>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">a liquid interacting with a highly detailed obstacle.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The κ solid component of our sizing function ensures that geometrically complex regions near the obstacle are simulated with higher accuracy.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In this way, we can resolve the detailed flow of liquid through the holes in the obstacle.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Figure 1 shows a situation that would be challenging to simulate with a regular solver.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Without adaptivity, the large open liquid surface with complex splashes in a localized region would require huge amounts of computational resources.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Our method can simulate this setup very efficiently, and in a fully coupled manner with an effective high resolution.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">The large open region is successfully coarsened by our sizing function, resulting in subtle wave motions around the splashes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">In this case, the whole simulation with 8 different octree levels and a maximum resolution of up to 1024 cells took on average only 4.6 minutes per frame to compute.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Just to illustrate the amount of detail in this setup – our adaptive version initially used 1.7 million particles, while a regular sampling at the finest resolution would have required roughly 400 million.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Further runtime and resolution details for our simulations can be found in Table 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Discussion We found our discretization (Section 3) beneficial in a number of ways.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We store the pressure variables on tetrahedral vertices, and there are far fewer vertices than tetrahedra in a given mesh.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Consequently, the pressure solve has fewer variables and is faster to solve.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">Also, by counting degrees of freedom and constraints, we can see that our discretization prevents the locking ar- tifacts which are common in other methods.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">However, the lower number of pressure constraints also implies that the highest frequencies of the velocity field may be unconstrained.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In our case a regularization via PIC interpolation acts to diminish any highfrequency artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">Our method uses a FLIP scheme instead of a purely Eulerian method.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">We store all physical variables on the FLIP particles, so information is carried from one time step to the next in a Lagrangian manner.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">As a result, we are allowed to aggressively remesh the tetrahedral background grid without worrying about excessive damping or re-sampling artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">On the other hand, FLIP simulations have a well-known problem of creating noisy particle distributions, because there are typically several times more particles than velocity variables on the background grid.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We utilize particle repositioning to improve the distribution quality, at the expense of slight inaccuracies due to displacing physical variables.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">We noticed that our new surface creation routine is essential for maintaining detailed simulations in the presence of accurate freesurface boundary conditions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">One major benefit of our method is that it can easily create perfectly flat surfaces from a mixture of differently-sized particles.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">These flat surfaces represent the equilibrium state of a fluid simulation, so our animations are able to smoothly settle down as time progresses.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Without a method for accurately reproducing flat surfaces, second-order boundary conditions will introduce additional forces in the locations of surface bumps, which artificially prevent a simulation from settling down.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">While we believe that our surface creation routine is indispensable, it is quite expensive to compute.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.33">In the future we would like to optimize the surface computation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Our simulations perform quite well for large differences in resolutions, but we have only been able to push them to a certain point in our current implementation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">We found that using too sharp of a grading in our sizing function can place coarse and fine simulation elements too close together and potentially result in artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">For example, when small particles land in very coarse cells after violent splashes, these particles can get stuck in mid air.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">Occasionally, this can also lead to an overly strong weight for such particles during the velocity mapping, resulting in momentum artifacts.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">Our adaptive numerical viscosity in Eq.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">
<CitSpan>(14)</CitSpan> can also exhibit dangerously small damping values for very fine resolutions, so we clamped the blending coefficient to a minimum value of 0.1 in Figure 1 .</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">In Section 4 we introduced a novel collection of sizing functions for adaptively selecting details from a fluid simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">While we presented specific parameters for the sake of reproducibility, these values were not meticulously tuned and are certainly not optimal.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">The task of choosing an ideal sizing function is still an open problem that we are interested in pursuing in the future.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">In particular, we are interested in taking more temporal information into account.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.67">This could lead to more gradual changes in resolution, at the expense of a slightly higher particle count.</Sentence>
        
          Figure 8: This graph shows durations for the different parts of our algorithm over the course of the simulation from Figure 3 . Note that we only include the computationally more expensive steps here, and not the re-meshing (which is done in intervals).
        
        
          Figure 9: The time required for our re-meshing and particle merging &amp; splitting computations over time for Figure 3 . Note that we perform them only every ten simulation steps.
        
        
          
          Figure 7: A simulation of detailed flow through a complex obstacle. The liquid correctly flows through the orifices at the center of the filigree.
        
      
      
        <H1>8 Conclusions and Outlook</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="5.00">We have presented a novel framework for highly adaptive liquid simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">In our method, a novel, robust discretization works together with accurate embedded boundary conditions and a flexible sizing function to allow for aggressive adaptivity and high computational performance.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">In this way, we can efficiently compute tough simulation setups, such as large surfaces with very localized details.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="5.00">We have additionally presented a novel surface creation method that yields smooth surfaces in the presence of strongly varying particle radii, which turned out to be an important building block for our framework.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.67">We chose a BCC mesh generation because it is, to the best of our knowledge, the fastest way to generate high-quality meshes.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.67">However, despite its efficiency, mesh generation is still a bottleneck for our simulation.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">This is partly due to the fact that it is a mostly serial operation that is difficult to parallelize (most other steps of our algorithm parallelize easily).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.33">So, instead of computing the mesh from scratch each time, we are interested in exploring techniques for continuous re-meshing.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.67">Also, our choice of piece-wise constant basis functions for velocity indicates that our discretization could lead to difficulties when it is used for diffusion or viscosity solves.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="2.00">It will be interesting to see how these could be incorporated into our framework.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="4.00">Finally, we are highly interested in applying our method to other types of phenomena, such as smoke and fire simulations, or visco-elastic materials.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="3.00">It will be very interesting to leverage the benefits of our framework for extreme adaptivity in these situations.</Sentence>
      
      
        <H1>Acknowledgements</H1>
        <Sentence inAbstract="false" summaryRelevanceScore="1.0">We would like to thank the anonymous reviewers for their helpful feedback.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">We also wish to thank Reiji Tsuruno for providing us with computational resources, and Pascal Clausen as well as Ramprasad Sampath for constructive discussions.</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.0">This work was supported by the Japan Society for the Promotion of Science (JSPS).</Sentence> <Sentence inAbstract="false" summaryRelevanceScore="1.33">Finally, we would like to express our gratitude to the authors of the ANN library, which we use for kd-tree look-ups, and to the Mitsuba renderer, which we have used to render all images in this paper.</Sentence>
      
      
        <H1>References</H1>
        
          A DAMS , B., P AULY , M., K EISER , R., AND G UIBAS , L. J. 2007. Adaptively sampled particle fluids. In ACM SIGGRAPH 2007 papers, 48.
          A NDO , R., T HUEREY , N., AND T SURUNO , R. 2012. Preserving Fluid Sheets with Adaptively Sampled Anisotropic Particles. IEEE Transactions on Visualization and Computer Graphics 18 (8), 1202–1214.
          B ATTY , C., AND B RIDSON , R. 2008. Accurate viscous free surfaces for buckling, coiling, and rotating liquids. In Proceedings of the 2008 ACM/Eurographics Symposium on Computer Animation, 219–228.
          B ATTY , C., B ERTAILS , F., AND B RIDSON , R. 2007. A fast variational framework for accurate solid-fluid coupling. ACM Trans. Graph. 26, 3 (July).
          B ATTY , C., X ENOS , S., AND H OUSTON , B. 2010. Tetrahedral embedded boundary methods for accurate and flexible adaptive fluids. In Proceedings of Eurographics.
          B HATTACHARYA , H., G AO , Y., AND B ARGTEIL , A. W. 2011. A level-set method for skinning animated particle data. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          B OYD , L., AND B RIDSON , R. 2012. Multiflip for energetic twophase fluid simulation. ACM Trans. Graph. 31, 2, 16:1–16:12.
          B RIDSON , R. 2008. Fluid Simulation for Computer Graphics. AK Peters/CRC Press.
          B ROCHU , T., B ATTY , C., AND B RIDSON , R. 2010. Matching fluid simulation elements to surface geometry and topology. ACM Trans. Graph. 29, 4 (July), 47:1–47:9.
          C HENTANEZ , N., F ELDMAN , B. E., L ABELLE , F., O’B RIEN , J. F., AND S HEWCHUK , J. R. 2007. Liquid simulation on lattice-based tetrahedral meshes. In Proceedings of the 2007 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 219–228.
          C LAUSEN , P., W ICKE , M., S HEWCHUK , J., AND O’B RIEN , J. 2013. Simulating liquids and solid-liquid interactions with Lagrangian meshes. ACM Trans. Graph..
          E NRIGHT , D., N GUYEN , D., G IBOU , F., AND F EDKIW , R. 2003. Using the Particle Level Set Method and a Second Order Accurate Pressure Boundary Condition for Free-Surface Flows. Proc. of the 4th ASME-JSME Joint Fluids Engineering Conference.
          E NRIGHT , D., L OSASSO , F., AND F EDKIW , R. 2005. A fast and accurate semi-Lagrangian particle level set method. Comput. Struct. 83, 6-7, 479–490.
          H ARLOW , F., AND W ELCH , E. 1965. Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. Phys. Fluids 8 (12), 2182–2189.
          H ONG , W., H OUSE , D. H., AND K EYSER , J. 2009. An adaptive sampling approach to incompressible particle-based fluid. In TPCG, Eurographics Association, W. Tang and J. P. Collomosse, Eds., 69–76.
          I RVING , G., S CHROEDER , C., AND F EDKIW , R. 2007. Volume conserving finite element simulations of deformable models. ACM Trans. Graph. 26, 3 (July).
          K LINGNER , B. M., F ELDMAN , B. E., C HENTANEZ , N., AND O’B RIEN , J. F. 2006. Fluid animation with dynamic meshes. ACM Trans. Graph. 25, 3, 820–825.
          L ABELLE , F., AND S HEWCHUK , J. R. 2007. Isosurface stuffing: Fast tetrahedral meshes with good dihedral angles. ACM Trans. Graph. 26, 3 (July).
          L EW , A. J., AND B USCAGLIA , G. C. 2008. A discontinuousgalerkin-based immersed boundary method. International Journal for Numerical Methods in Engineering 76, 4, 427–454.
          L OSASSO , F., G IBOU , F., AND F EDKIW , R. 2004. Simulating water and smoke with an octree data structure. ACM Trans. Graph. 23, 3 (Aug.), 457–462.
          L OSASSO , F., F EDKIW , R., AND O SHER , S. 2005. Spatially adaptive techniques for level set methods and incompressible flow. Computers and Fluids 35, 2006.
          M ISZTAL , M. K., B RIDSON , R., E RLEBEN , K., B ÆRENTZEN , J. A., AND A NTON , F. 2010. Optimization-based fluid simulation on unstructured meshes. In VRIPHYS, Eurographics Association, 11–20.
          M ULLEN , P., C RANE , K., P AVLOV , D., T ONG , Y., AND D ES BRUN , M. 2009. Energy-preserving integrators for fluid animation. ACM Trans. Graph. 28 (July), 38:1–38:8.
          P FAFF , T., T HUEREY , N., C OHEN , J., T ARIQ , S., AND G ROSS , M. 2010. Scalable fluid simulation using anisotropic turbulence particles. In ACM Transactions on Graphics (TOG), vol. 29, ACM, 174.
          S IN , F., B ARGTEIL , A. W., AND H ODGINS , J. K. 2009. A pointbased method for animating incompressible flow. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          S OLENTHALER , B., AND G ROSS , M. 2011. Two-scale particle simulation. ACM Trans. Graph. 30, 4 (July), 81:1–81:8.
          S TAM , J. 1999. Stable fluids. In Proceedings of SIGGRAPH ’99, ACM, 121–128.
          W OJTAN , C., AND T URK , G. 2008. Fast viscoelastic behavior with thin features. ACM Trans. Graph. 27, 3, 1–8.
          Y U , J., AND T URK , G. 2010. Reconstructing surfaces of particlebased fluids using anisotropic kernels. In Proceedings of the 2010 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 217–225.
          Z HU , Y., AND B RIDSON , R. 2005. Animating sand as a fluid. ACM Trans. Graph. 24, 3 (July), 965–972.
        
      
      
        A Ghost Fluid Coefficients
        Here we describe how to compute the ghost fluid coefficients θ n given the 4 × 4 pressure matrix entries of a single tetrahedron. Reorganizing Eq. <CitSpan>(11)</CitSpan> gives:
        
          16
          λ 2 + αw 1 a + αw 2 b + αw 3 p 1 b 1 a + βw 1 λ 3 + βw 2 c + βw 3 p 2 = b 2 . b + γw 1 c + γw 2 λ 4 + γw 3 p 3 b 3
        
        Note that each of the θ n has two degree of freedom, and thus each w n also has two degrees of freedom. As we know that the resulting matrix needs to be symmetric, which gives us the following constraints: a + αw 2 = a + βw 1 , b + γw 1 = b + αw 3 , and c + βw 3 = c + γw 2 . As the w n linearly depend on θ n , that means: αθ 2 = βθ 1 , γθ 1 = αθ 3 , and βθ 3 = γθ 2 . When we re-write these constraints in matrix form, and include the barycentric coordinate constraint θ 1 + θ 2 + θ 3 = 1 we get the following linear system:
        
          17
           −β α 0   0  γ 0 −α θ 1 0   0 1 −γ 1 β 1   θ θ 3 2 =   1 0  
        
        As the rank of top three rows of the matrix is 2, we can drop one of them. Removing the first row from the system gives us the following full-rank, 3 × 3 matrix:
        
          18
          γ 0 −α θ 1 0 0 −γ β θ 2 = 0 1 1 1 θ 3 1
        
        The analytical solution of this system is:
        
          19
          θ 1 1 α θ 2 = β . θ 3 α + β + γ γ
        
        This means that for our discretization, the ghost pressure coefficients θ n are given by the tetrahedron’s matrix entries from Eq.10. More specifically, by those for the vertex that is located outside of the liquid, i.e., α, β and γ. Substituting this equation into Eq.9 and Eq.6 yields the final equation for the ghost pressure Eq. <CitSpan>(12)</CitSpan>.
      
    
  

</Document>
