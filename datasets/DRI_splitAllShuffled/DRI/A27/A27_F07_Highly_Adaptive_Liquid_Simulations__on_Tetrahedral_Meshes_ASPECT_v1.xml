<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Document xmlns:gate="http://www.gate.ac.uk" name="A27_F07_Highly_Adaptive_Liquid_Simulations__on_Tetrahedral_Meshes_ASPECT_v1.xml">


  
    1bc32fd79f71ddaed6dc90f472a41b0eaae0eba6d03053a8819e16a4b2305917
    3x6m
    http://dx.doi.org/10.1145/2461912.2461982
  
  
    
      
        <Title>Highly Adaptive Liquid Simulations on Tetrahedral Meshes</Title>
      
      
        
          Ryoichi Ando ∗ Nils Thürey † Kyushu University ScanlineVFX
          ∗
        
      
      ∗ E-mail: and@verygood.aid.design.kyushu-u.ac.jp † E-mail: nils.thuerey@scanlinevfx.com ‡ E-mail: wojtan@ist.ac.at
      
        
        Figure 1: Our adaptive simulation framework allows us to efficiently simulate highly detailed splashes on large open surfaces. In this case, maximum BCC mesh resolutions from 8 to 1024 cells were used, leading to strong horizontal grading along the surface.
      
      <Abstract>
<Sentence aspectClass="NONE" inAbstract="true">We introduce a new method for efficiently simulating liquid with extreme amounts of spatial adaptivity.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Our method combines several key components to drastically speed up the simulation of largescale fluid phenomena: We leverage an alternative Eulerian tetrahedral mesh discretization to significantly reduce the complexity of the pressure solve while increasing the robustness with respect to element quality and removing the possibility of locking.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Next, we enable subtle free-surface phenomena by deriving novel second-order boundary conditions consistent with our discretization.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">We couple this discretization with a spatially adaptive Fluid-Implicit Particle (FLIP) method, enabling efficient, robust, minimally-dissipative simulations that can undergo sharp changes in spatial resolution while minimizing artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Along the way, we provide a new method for generating a smooth and detailed surface from a set of particles with variable sizes.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">Finally, we explore several new sizing functions for determining spatially adaptive simulation resolutions, and we show how to couple them to our simulator.</Sentence> <Sentence aspectClass="NONE" inAbstract="true">We combine each of these elements to produce a simulation algorithm that is capable of creating animations at high maximum resolutions while avoiding common pitfalls like inaccurate boundary conditions and inefficient computation.</Sentence>
</Abstract>
	  I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Physically based modeling Keywords: motion editing, motion signal-processing, spacetime constraints, motion capture.	  
	  
      
        
          Chris Wojtan ‡ IST Austria
        
      
      Links:
      
        
      
      DL PDF
      
        
      
    
    
      
        <H1>1 Introduction</H1>
      
      <Sentence aspectClass="NOVELTY" inAbstract="false">This paper aims to produce fluid simulations with a high degree of spatial adaptivity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We desire to enable a simulator to focus its computational resources on the visually interesting regions of a fluid flow, while remaining computationally efficient and avoiding common artifacts due to a spatially adaptive pressure solve.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Previous approaches have made great strides towards this goal, but they often exhibit visual artifacts, a lack of computational robustness, or an unacceptably hefty computational expense.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">The groundbreaking work of <CitSpan>Losasso et al. [2004]</CitSpan> introduced an octree for spatial adaptivity, but it suffers from spurious flows at T-junctions.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">Finite volume methods <CitSpan>[Batty et al. 2010]</CitSpan> repair these spatial artifacts at the expense of solving a significantly larger system of equations and sacrificing computational stability near poorly-shaped elements.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Furthermore, many existing methods still are not truly spatially adaptive in the sense that their computational complexity is still tied to a uniform grid or spatial parameter.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We introduce a combination of techniques that successfully makes adaptive fluid simulation practical at large scales.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We first reduce memory and computational costs by switching from a finite volume method to a discretization with a significantly smaller linear system for the pressure solve, which has the side effect of increasing the simulator’s robustness to poor-quality elements and effectively preventing locking artifacts.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We next derive second-order Dirichlet boundary conditions consistent with our discretization to benefit from the subtle surface dynamics associated with an accurate pressure solve.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">We combine this robust and efficient tetrahedral meshbased fluid simulator with a spatially adaptive method for sampling particles for FLIP-based velocity advection, giving us a method free from any single spatial resolution.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">In addition to our adaptive FLIP simulator, we also introduce a new method for computing a surface from a distribution of particles with variable radii.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We found that this method out-performs previous methods in cases of extreme spatial adaptivity by exhibiting smoother surfaces without sacrificing detail.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our fluid simulator works well with spatially adaptive tetrahedral meshes, but it is another question to decide exactly how these adaptive meshes should be generated.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We investigate various methods for generating these adaptive meshes by experimenting with several sizing functions, allowing us to precisely dictate where simulation detail should occur.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Some examples are a surface curvature-based metric that adds detail only where needed on the fluid surface, a turbulence metric that adds detail only where interesting fluid motion occurs, and a visibility metric that adds detail only in front of a virtual camera.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">Concretely, the contributions of our work are: • a novel tetrahedral discretization of the pressure projection step that is efficient to solve and robust to poor-quality elements; • an accurate treatment of second-order boundary conditions within the tetrahedral mesh; • a new technique for extracting a smooth surface from particles with varying radii; • and the inclusion of a flexible sizing function to focus computational resources on important areas of the flow with minimal overhead.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">These contributions work together to produce a practical fluid simulator that exhibits low computational and memory complexity, fewer visual artifacts, and a high effective simulation resolution.</Sentence>
      
        <H1>2 Related Work</H1>
        <Sentence aspectClass="NONE" inAbstract="false">Our work is based on the Fluid-Implicit Particle (FLIP) method introduced to the computer graphics community by <CitSpan>Zhu and Bridson [2005]</CitSpan>, which arguably represents the state-of the art for detailed and robust liquid simulations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The algorithm still follows the general ideas of the Stable Fluid solver <CitSpan>[Stam 1999]</CitSpan>, and can be readily combined with second-order treatment of free surface boundary conditions <CitSpan>[Enright et al. 2003]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">FLIP derives its success from the fact that it uses particles to compute an accurate, nondiffusive transport of flow quantities, in combination with a gridbased solve to accurately enforce constraints for mass conservation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The FLIP algorithm is heavily used in the special effects industry, and recent advances have introduced accurate coupling with obstacles <CitSpan>[Batty et al. 2007]</CitSpan>, highly viscous materials <CitSpan>[Batty and Bridson 2008]</CitSpan>, and two-phase flows <CitSpan>[Boyd and Bridson 2012]</CitSpan>.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Traditionally, Cartesian grids are very popular for fluid simulations.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The Marker-And-Cell (MAC) approach <CitSpan>[Harlow and Welch 1965]</CitSpan>, which stores velocity components at cell faces and pressure samples at cell centers, results in discretizations with good properties in terms of stability and accuracy.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">An inherent difficulty is that simulations on regular grids become prohibitively expensive for large resolutions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus, many works have proposed methods to focus the computations on regions that are of particular interest.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One example are octrees, which were used by Losasso et al. [2004; 2005] to refine the computational grid in a controllable way.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This approach, however, suffers from numerical diffusion and an inconsistent discretization near the tree’s T-junctions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Targeting a similar direction as our work, <CitSpan>Hong et al. [2009] and Ando et al. [2012]</CitSpan> have demonstrated methods to adapt the resolution of FLIP particles in a simulation.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Both methods, in contrast to ours, focus on static computational grids and are restricted to smaller differences in particle size.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Although Cartesian grids are widely used, they are limited in their flexibility to adapt to a simulation setup.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">Because of this, tetrahedral grids are popular for methods targeting adaptivity.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In combination with a suitable method to discretize the problem at hand, they allow for very flexible computational grids.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One example is the work of Klingner et al. <CitSpan>[Klingner et al. 2006]</CitSpan> which demonstrated the use of a Stable Fluids based solver for tetrahedral grids conforming to object boundaries.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Another example is the non-linear fluid solver developed by <CitSpan>Mullen et al. [2009]</CitSpan>, which leads to an energy conserving solve.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Unlike these methods, we make use of a non-conforming grid with Body-Centered Cubic (BCC) lattices.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These meshes were also used by <CitSpan>Chentanez et al. [2007]</CitSpan> and by <CitSpan>Batty et al. [2010]</CitSpan> for liquid simulations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will denote this class of algorithms as Finite Volume Methods (FVM).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These methods are primarily suitable for uniformly sampled particles, and we will demonstrate in Section 7 that their placement of pressure samples at tetrahedral circumcenters leads to numerical problems in combination with graded BCC meshes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Another direction of research performs fluid simulations based on arbitrary elements.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>Clausen et al. [2013] and Misztal et al. [2010]</CitSpan> have proposed a method to simulate liquids with a computational grid conforming to a triangulation of a liquid surface.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Both methods lead to an increased computational cost in comparison to the more efficient tetrahedral BCC meshes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>Sin et al. [2009]</CitSpan> proposed an alternative method for hybrid Lagrangian-Eulerian solvers which combines a Voronoi-based pressure solver and particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Using this Vornoi-based approach for tetrahedral meshes would yield a pressure matrix similar to ours.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Like our method, <CitSpan>Brochu et al. [2010]</CitSpan> used this discretization in combination with embedded second-order boundary conditions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Both of these approaches discretize velocities with per-face flux values, while we store velocity vectors at cell barycenters.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Adaptive simulations have also been explored in the context of SPH simulations without Eulerian grids.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The work of <CitSpan>[Adams et al. 2007]</CitSpan> shares similarities with our approach, as it is able to simulate a wider range of particle radii, and it proposes a surface reconstruction method in the adaptive setting.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will show in Section 5 that our surface creation method results in surfaces with fewer visual artifacts.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">Additionally, a robust and efficient method for adaptive SPH simulations was introduced by <CitSpan>Solenthaler et al. [2011]</CitSpan>, but this work primarily targets the coupling of two different particle resolutions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Several other methods have been proposed to reconstruct smooth surfaces around collections of particles without orientation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One approach that is commonly used is to compute a signed distance function with averaged particle radii and centroids <CitSpan>[Zhu and Bridson 2005]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A variant of this approach, taking into account information about the spatial variance of the particle’s neighborhood was proposed by <CitSpan>Yu et al. [2010]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Both methods primarily target particles with constant radius.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More recently, a level-set based method was proposed that computes a constrained optimization with bihar- monic smoothing <CitSpan>[Bhattacharya et al. 2011]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, such an optimization would be complicated to apply in our unstructured setting.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In contrast to these methods, our approach for surface creation computes the union of convex hulls around triplets of particles, which leads to a smooth and closed surface around a collection of arbitrarily sized particles.</Sentence>
      
      
        <H1>3 Fluid Solver</H1>
        <Sentence aspectClass="NONE" inAbstract="false">The aim of our method is to solve the Navier-Stokes equations, which for incompressible, Newtonian, inviscid flows can be written as ρDu/Dt = − p + f , with the additional constraint · u = 0 to enforce a divergence-free velocity field.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Here, u, p and f denote velocity, pressure and external forces, respectively, while D/Dt denotes the material derivative.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The density ρ is constant in our case.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We solve these equations using operator splitting <CitSpan>[Stam 1999]</CitSpan>, and a level set φ(x) = 0 defines the position of the liquid-gas interface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Spatial Discretization An inherent strength of the FLIP algorithm is its hybrid nature.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The motion of the fluid is computed in a Lagrangian manner using particles, while the pressure projection step is computed on an Eulerian grid.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We will now describe how we compute the pressure projection using a tetrahedral discretization.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This projection of the velocities into a divergence-free state can be formulated as the Poisson problem</Sentence>
        
          1
          ∆t 2 p = · u ∗ , ρ
        
        <Sentence aspectClass="NONE" inAbstract="false">where u ∗ denotes an intermediate velocity after the advection.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the following, however, we prefer an alternate view that looks at this problem from an energy minimization perspective: we want to compute the minimal change in kinetic energy necessary to reach a divergence-free state of the flow similar to <CitSpan>[Batty et al. 2007]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This can be formulated as:</Sentence>
        
          2
          p = arg min 1 ||u ∗ − ∆t p|| 2 ρdV p Ω 2 ρ
        
        <Sentence aspectClass="NONE" inAbstract="false">Here, Ω represents the domain of the computational grid, and we choose to discretize this space using tetrahedral cells.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">This has the advantage of giving us a natural way to handle cells of different size, while yielding a consistent discretization of the differential operators involved.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We store pressure samples at the nodes of the tetrahedral mesh, while velocities are stored at cell centers.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This configuration is illustrated in Figure 2 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that by assuming a piece-wise constant velocity and a linear change of pressure within a cell, this setup results in a constant pressure gradient per tetrahedron, by construction.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the following, we denote the number of cells with m and the number of nodes with n, and we indicate discretized quantities with caret notation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Based on this representation we can discretize Eq.</Sentence> <CitSpan>(2)</CitSpan> with
        
          3
          m p = arg min 1 || u ˆ i ∗ − ∆t [ ] p|| 2 ρV i , p ˆ 2 ρ i
        
        <Sentence aspectClass="NONE" inAbstract="false">where we denote the volume of a cell with V i and the discretized gradient operator with [ ].</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It consists of a m×n matrix, computing a per-tetrahedron gradient from nodal values.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Consequently, we define the divergence operator to be the transpose of the discretized gradient.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Before we go ahead to define [ ], we want to outline the rest of the steps for our pressure solve.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We solve equation Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(3)</CitSpan> with the commonly used least squares technique, yielding</Sentence>
        
          4
          ∆t T T ∗ [ ] V [ ] p = [ ] V u ˆ , ρ
        
        
          
          
          
          Figure 2:
        
        <Sentence aspectClass="NONE" inAbstract="false">Our discretization compared to previous approaches: the MAC grid stores velocity components normal to faces and pressure values at the center.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The FVM discretizations follow along these lines and store velocities normal to faces and pressure values at the circumcenter of a cell.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our approach we store a 3component velocity vector at the barycenter of a cell and pressure values at each node.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">where V denotes a matrix containing the V i as diagonal entries.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The [ ] T [ ] matrix-matrix multiplication results in a square n × n matrix, which is symmetric and positive definite.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the following, we will denote the matrix on the left hand side of Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(4)</CitSpan> as A. Given appropriate boundary conditions, we can use standard tools, such as a commonly used pre-conditioned conjugate gradient solver to compute a solution (we use the one suggested in <CitSpan>[Bridson 2008]</CitSpan>).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Now, all that is left to construct the left-hand side matrix and the right-hand side terms for Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(4)</CitSpan> is to define [ ].</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As we assume a linear change of the pressure for each cell, we can use simple barycentric interpolation to retrieve the pressure p at a position inside a cell.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given the nodal pressure values p 1..</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">4 and barycentric weights σ 1..</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">4 this means p = σ 1 p 1 + σ 2 p 2 + σ 3 p 3 + σ 4 p 4 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In line with finite element methods using linear elements, we define the gradient based on the partial derivatives of the barycentric interpolation.</Sentence> E.g.<Sentence aspectClass="NONE" inAbstract="false">, the first component of the gradient for a cell is computed with</Sentence>
        
          5
          ∂ ∂σ 1 ∂σ 2 ∂σ 3 ∂σ 4 p = p 1 + p 2 + p 3 + p 4 . ∂x ∂x ∂x ∂x ∂x
        
        <Sentence aspectClass="NONE" inAbstract="false">To set up the final linear system of Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(4)</CitSpan> for the pressure solve, we loop over all tetrahedra to compute the derivatives of the barycentric interpolation, adding their contributions to the global matrix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In contrast to previous work, our pressure solve is a linear system that has n degrees of freedom, n being the number of nodes in the tetrahedral mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For our BCC mesh, n is in practice smaller than the number of tetrahedra m (by a factor of 6 on average).</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">A direct implication of this smaller linear system is that it is faster to solve.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">A second, less obvious implication of the smaller linear system is that it effectively prevents artifacts known as locking.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These artifacts are commonly observed in finite element methods for problems in elasticity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Different methods have been proposed to circumvent these problems, e.g., using linear elements for pressure instead of piece-wise constant ones <CitSpan>[Irving et al. 2007]</CitSpan>.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Other works explicitly smooth the pressure field to reduce locking problems <CitSpan>[Misztal et al. 2010]</CitSpan>.</Sentence> <Sentence aspectClass="COMMON_PRACTICE" inAbstract="false">In general, locking can be observed if the pressure basis can represent more, and higher-frequency, functions than the basis for the velocity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Thus, choosing a more restrictive basis for pressure, as in <CitSpan>[Irving et al. 2007]</CitSpan>, or explicitly removing high-frequency information from the pressure <CitSpan>[Misztal et al. 2010]</CitSpan>, reduces the chance of locking.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our method, by construction, has more degrees of freedom for representing velocity fields than pressure fields.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Although we cannot prove that a local configuration over-constraining the velocities will never occur, the larger number of degrees of freedom for our velocities effectively prevents locking artifacts, and we have not encountered any in our tests.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Boundary Conditions Second-order boundary conditions are a central component for accurate and visually appealing simulations with non-conforming grids.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Achieving second-order accuracy for obstacle boundary conditions is straightforward with our discretization: we can rely on the formulation of previous work <CitSpan>[Batty et al. 2007]</CitSpan>, and set the volume of a cell V i in Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(4)</CitSpan> to the volume that is filled with fluid.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the free surface, we have to ensure that the Dirichlet boundary condition p = 0 is satisfied at the interface position.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Usually, this means computing a pressure value for nodes outside of the liquid so that a linear interpolation along an edge of a cell gives zero at the correct position <CitSpan>[Enright et al. 2005; Lew and Buscaglia 2008]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Considering two pressure samples along an edge, we’ll denote values inside the air with a G subscript, and values inside the liquid with an L subscript in the following.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For a Cartesian MAC grid, the ghost pressure value p G is given by p G = p L φ G /φ L .</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">In our case, however, this approach does not yield the desired result.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The reason is that our velocity samples are not in line with the direct connections of the pressure samples – they are not locally orthogonal to each other.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Instead, we have to ensure the boundary conditions result in the correct pressure value at the cell center.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the following we will show how to derive suitable free-surface boundary conditions to ensure second-order accuracy within our framework.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to achieve accurate and smooth surface motions with our method, we compute the ghost pressure values p G with a linear combination of liquid pressure values as:</Sentence>
        
          6
          p G = w 1 p 1 + w 2 p 2 + w 3 p 3 ,
        
        <Sentence aspectClass="NONE" inAbstract="false">where w n and p n denote unknown coefficients and adjacent liquid pressures in the same tetrahedron.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that for p i that are not inside of the liquid, we set w i = 0.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In line with the traditional ghost fluid method, we define p G uniquely for each tetrahedron.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To handle the most general case, let’s suppose that p 1..</Sentence>
<Sentence aspectClass="NONE" inAbstract="false">3 are all liquid pressure values.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Once we have a value for p G , we can compute a pressure gradient for the tetrahedron and update the velocity at its center with:</Sentence>
        
          7
          u ˆ new = u ˆ ∗ − ∆t [ ] p G p 1 p 2 p 3 T ρ
        
        <Sentence aspectClass="NONE" inAbstract="false">In order to do this we need to compute the coefficients w n .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">p G can be rewritten in terms of a barycentric interpolation of the three values in the liquid as:</Sentence>
        
          8
          p G = p L φ G / φ  ̃ L
        
        <Sentence aspectClass="NONE" inAbstract="false">with φ  ̃ L = θ 1 φ 1 + θ 2 φ 2 + θ 3 φ 3 , and p L = θ 1 p 1 + θ 2 p 2 + θ 3 p 3 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Here the θ n are a set of barycentric coordinate coefficients such that θ 1 +θ 2 +θ 3 = 1, and a tilde superscript denotes a value interpolated with the barycentric weights.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Substituting Eq.8 into Eq.6 yields</Sentence>
        
          9
          w n = θ n φ G / φ  ̃ L .
        
        <Sentence aspectClass="NONE" inAbstract="false">That means the values w n are determined by those of the θ n coefficients, which we will compute in the following.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that, theoretically, θ n could take any values as long as they add up to one.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Before embedding the boundary conditions, the matrix entries of the pressure solve for a single tetrahedron are, according to Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(4)</CitSpan>, given by ∆t [ ] T V [ ]p = b.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The computation of the ghost fluid ρ values is independent of the right-hand side b, so we will restrict the discussion to the left hand side.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We denote the components of the local symmetric 4 × 4 matrix on the left hand side with:  λ 1 α β γ </Sentence>
        
          10
          α λ 2 a b    β a λ 3 c  γ b c λ 4
        
        <Sentence aspectClass="NONE" inAbstract="false">Assuming, without loss of generality, that the first vertex is the one outside of the liquid volume, we embed the boundary condition into
        M based on the w n coefficients.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then the first row of the system is changed to:</Sentence>
        
          11
           1 −w 1 −w 2 −w 3   p G   0  α λ 2 a b p 1 b 1     =   .  β a λ 3 c   p 2   b 2  γ b c λ 4 p 3 b 3
        
        <Sentence aspectClass="NONE" inAbstract="false">We can extract two constraints for each θ n from this form, which, together with the barycentric coefficient constraint, give us a 3 × 3 matrix M that can be inverted analytically.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A full derivation of these steps can be found in Appendix A. With this analytic expression we can compute the ghost pressure coefficients as:</Sentence>
        
          12
          φ G / φ  ̃ L  α  w = α + β + γ  β γ 
        
        <Sentence aspectClass="NONE" inAbstract="false">This boundary condition ensures second-order accuracy while maintaining symmetry when it is assembled into the matrix of Eq.</Sentence> <CitSpan>(4)</CitSpan>. <Sentence aspectClass="NONE" inAbstract="false">If the quality of a tetrahedron is good, 0 &lt; θ n &lt; 1 is guaranteed.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In this case, the resulting matrix is symmetric positivedefinite and can be easily inverted by the commonly used preconditioned conjugate gradient methods.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, positive off-diagonal terms of the matrix can result in values of θ outside of the range <CitSpan>[0, 1]</CitSpan>, leading to an indefinite linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In these cases we consider the tetrahedron to have a poor quality.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When using ghost fluid boundary conditions with a regular MAC grid, it is common practice to clamp small values in the denominator of Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(9)</CitSpan> to prevent ill-conditioned pressure matrices.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Effectively, this means reverting to first-order accuracy when second-order accuracy is intractable.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We implement a similar step in our algorithm to overcome numerical problems resulting from badly shaped cells.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We check whether the ghost fluid boundary conditions would violate diagonal dominance of an equation in our linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If we detect such a case, we smoothly transition to first order accuracy.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Specifically, when we have computed M , we check if a resulting diagonal term M i,i is smaller than φλ 2..</Sentence>4 . <Sentence aspectClass="NONE" inAbstract="false">Here, φ denotes a tolerance factor that we set to φ = 0.25.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Whenever we detect such a case, we compute a coefficient k with</Sentence>
        
          13
          φ − 1 φ − 1 φ − 1 k = min λ 2 , λ 3 , λ 4 , w 2 α w 3 β w 4 γ
        
        <Sentence aspectClass="NONE" inAbstract="false">and multiply each w n with k when embedding.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that this scaling does not break the symmetry of the resulting linear system.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">More specifically, for k = 1 this yields full second-order accuracy, while for badly shaped tetrahedra the resulting k = 0 means that we revert to the standard rounding strategy of a first order accurate method.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">With our BCC mesh, all regular BCC tetrahedra have very good quality and valid θ n values.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The graded BCC tetrahedra, on the other hand, can be of lower quality and can require the use of Eq.</Sentence> <CitSpan>(13)</CitSpan>. <Sentence aspectClass="NONE" inAbstract="false">Luckily, in our tests these tetrahedra make up only a very small fraction of the mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Velocity Interpolation The FLIP advection step traces particles based on the velocities from the Eulerian grid.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this we need to construct a continuous velocity field based on the discrete values in our tetrahedral mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As we store velocities at the cell centers, the interpolation would ideally use the dual mesh consisting of the Voronoi cells of each node <CitSpan>[Brochu et al. 2010]</CitSpan>.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Unfortunately, performing interpolations within arbitrary Voronoi cells would be expensive and require a large amount of computation compared to the other steps of our simulator.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Instead, we have found the following approach to yield high speed and good accuracy: we first interpolate the centered velocities to the nodes, similar to <CitSpan>[Chentanez et al. 2007]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Instead of interpolating these averaged values directly (which would result in smeared out motion), we temporarily subdivide the cells of our mesh by inserting a vertex at the center where we have an accurate velocity sample.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We then perform barycentric interpolation based on these subdivided cells, ensuring a C 0 continuous velocity that retains the original velocities at cell centers.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that these four smaller tetrahedra do not have to be stored explicitly.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We construct them on the fly when a sample is requested from one of the original cells.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Manipulating FLIP particles The spacing between FLIP particles may drift over time, and high-frequency errors may contribute to a bumpy surface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We combat these problems by directly manipulating particle positions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">During each time step, we apply the position correction algorithm of <CitSpan>Ando et al. [2012]</CitSpan>; this algorithm essentially pushes each particle away from its neighbors to prevent clustering.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also introduce two special behaviors when the particles are close to the liquid surface (less than a distance of six times the particle radius).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">First, we impose the constraint that the position correction step may only move particles near the surface tangentially to the fluid interface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Secondly, particles near the surface may leave gaps when they spread out quickly.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our method naturally fills in these gaps by slightly pulling each particle towards the fluid interface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For particles near the interface, this pulling force acts in addition to the position correction.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">FLIP particles that partake in splashes and sprays can pose a significant burden on computational resources, especially in an adaptive framework like ours.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">This inefficiency stems from the fact that water droplets undergo extremely simple ballistic motion.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Theoretically, we know that such a small region with purely free-surface boundary conditions will yield zero internal forces, so we simply detect individual FLIP particles that have no neighbors within six times their radius, remove them from the pressure solve, and accelerate them with gravity instead.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When these particles eventually enter the neighborhood of other particles at some point in the future, we resume treating them like fluid by returning them to the pressure solve.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">This decision allows us to avoid aggressively refining the tetrahedral mesh in locations where the physical motion is uninteresting.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Only a small percentage of the particles are simulated in this way, e.g., 1.7% on average for Figure 6 .</Sentence>
        
          
          Figure 3: A simple geometric setup creating a big splash inside a container. This simulation, with a maximum resolution of 256 cells, took 1.3 minutes per frame on average.
        
      
      
        <H1>4 Adaptivity</H1>
        <Sentence aspectClass="NONE" inAbstract="false">Our method achieves adaptivity by varying the mesh resolution over the computational domain.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our FLIP simulation performs computation on both a background volumetric mesh and on a set of particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given a sizing function that indicates the desired spatial level of detail, our method first creates a tetrahedral mesh with varying spatial resolution, and then it locally changes the particle density by splitting and merging operations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To compute the spatially-varying background grid, we start with the Delaunay tetrahedralization of a set of points distributed in a body-centered cubic lattice configuration.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In order to make the mesh resolution change over space, we use the octree-based grading method which was proposed by <CitSpan>Labelle and Shewchuk [2007]</CitSpan> and later adopted in several adaptive simulation environments <CitSpan>[Chentanez et al. 2007; Wojtan and Turk 2008; Batty et al. 2010]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similar to <CitSpan>[Batty et al. 2010]</CitSpan>, we generate a new tetrahedral mesh every ten time steps, instead of rebuilding the mesh on every consecutive step.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, the tetrahedral mesh is only temporarily used for the pressure solver, so no information is transferred from one time step to the next by storing it on the grid.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Thus, we do not worry about re-sampling data when computing a new tetrahedral mesh.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We change the size and number of particles in our simulation with splitting and merging operations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this, we modify the strategy of <CitSpan>Ando et al. [2012]</CitSpan> to work within our framework: at each remeshing step, we loop through the particles and determine whether the resolution needs to be changed.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If a particle is too small, then we merge it with its nearest neighboring particle, resulting in a particle whose radius is given by the combined volume of the two original particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">If a given particle is bigger than the desired size, then the particle is split in two.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The two new particles are placed randomly within the original particle’s radius and redistributed with a heuristic that attempts to fill in nearby gaps: We first compute the 24 midpoints m i between this particle and its 24 nearest neighbors.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Then we find the closest particle to each midpoint and store the squared distance as a weight ω i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The new particle’s position is equal to the weighted average of all nearby midpoints: x new = ω i m i / ω i .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">After a split or merge operation, the new particle’s velocity is computed using a volume-weighted average.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, we must take care to ensure that particles close to the surface do not introduce interfacial bumps when they split or merge; whenever we create a new particle that is less than 1.25 times its radius away from the surface (through either a split or a merge event), we move it in the surface normal direction such that its sphere lies exactly tangent to the liquid interface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Numerical viscosity in fluid simulations is tightly coupled to the spatial resolution resolving the flow.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We compensate for spatiallyvarying numerical viscosity caused by particles of various sizes in our simulation by adjusting the PIC/FLIP blending parameter in our FLIP simulation <CitSpan>[Bridson 2008]</CitSpan>.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given quantities Q i,PIC and Q i,FLIP computed at particle i from PIC and FLIP simulations, respectively, the new quantity Q i is computed as a weighted blend between the two:</Sentence>
        
          
          Figure 4: For the perfectly planar particle placement shown in (a), the methods <CitSpan>[Zhu and Bridson 2005]</CitSpan> (b), <CitSpan>[Yu and Turk 2010]</CitSpan> (c), and <CitSpan>[Adams et al. 2007]</CitSpan> (d) do not result in a flat surface, while our method produces the desired result (e).
        
        
          14
          ν∆t ν∆t Q i = r i 2 Q i,PIC + (1 − r i 2 )Q i,FLIP
        
        <Sentence aspectClass="NONE" inAbstract="false">where r i is the radius of particle i and ν is the viscosity of the flow.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We found that this strategy adequately eliminates any artifacts due to spatially varying numerical viscosity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Sizing Functions We define the level of detail in our simulations with a spatially varying sizing function S(x).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We have experimented with several different sizing functions depending on factors such as distance to a camera, distance to the liquid surface, curvature of the liquid surface, measures of fluid turbulence, and arbitrary analytical number fields.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our simulator is versatile enough to cope with any of these sizing functions, resulting in efficient simulations with highly variable levels of detail.</Sentence> E.g.<Sentence aspectClass="NONE" inAbstract="false">, Figure 1 showcases a simulation where smallest and largest cells differ by a factor of 128.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In all of the examples in this paper, the sizing function is defined as a combination of five different metrics:</Sentence>
        
          15
          S(x) = max ( d(x), V (x, min(κ liquid (x), κ solid (x), e(x)) )
        
        <Sentence aspectClass="NONE" inAbstract="false">where x is the position of a point in space, and d(x) encodes the depth of the liquid by returning the absolute level set value of the liquid surface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This has the effect that motion near the surface has higher priority than motions far inside the bulk volume of the liquid.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">V (x, y) is a view-dependent function that returns the value y if x is within the camera’s visible region and returns the maximum particle radius r max (representing the minimum surface resolution) otherwise.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The next two metrics are designed to prioritize geometric detail of the liquid surface and of obstacles by computing a desired resolution based on cuvature.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">κ liquid (x) returns 0.8 divided by the extrapolated curvature of the liquid interface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Similarly, κ solid (x) returns 1.6 W smooth (d solid , r max ) divided by the extrapolated curvature of the solid interface, where W smooth (x, h) is a smooth kernel function (1 − ||x|| 2 /h 2 ) 3 and d solid is the closest distance to the solid boundary.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">As a last component of our sizing function we found it beneficial to invest computational resources into keeping interesting motion of the flow field alive.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Inspired by turbulence models (used e.g. in <CitSpan>[Pfaff et al. 2010]</CitSpan>), we have found that the strain tensor of the flow field reliably indicates detailed motions, and we compute e(x) as 30 divided by the Frobenius norm of the fluid strain tensor computed from the velocity field.</Sentence>
      
      
        <H1>5 Surface Representation</H1>
        <Sentence aspectClass="NOVELTY" inAbstract="false">We also introduce a new method for computing an implicit surface from a set of particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Given our set of FLIP particles with variable radii, we aim to implicitly represent the fluid surface by computing its signed distance function.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Several useful methods for computing a surface from a collection of particles have been proposed in the past <CitSpan>[Zhu and Bridson 2005; Adams et al. 2007; Yu and Turk 2010]</CitSpan>, but they tend to produce undesirably bumpy surfaces when considering particles of highly variable radii ( Figure 4 ).</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">In this section, we introduce a new strategy for computing an implicit surface from a set of particles of various sizes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The main idea is to approximate the fluid surface with the union of the convex hulls of each triplet of nearby particles close to the surface.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For each set of three FLIP particles near the surface, the convex hull forms a thickened triangle shape with rounded edges ( Figure 5 ).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We only consider particles that are less than a given distance apart, with the maximum distance equal to a constant scale factor l times the sum of the two particle radii.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A small l shows more surface details, while a larger l tends to fill in small concavities.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We used l = 2 for most of the simulations in this paper.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We ultimately represent our surface as the union of all such local convex hull shapes, and the minimum signed distance from these shapes to a point in space defines the outer part of our level set function.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In practice, we compute the local convex hull by finding the two outermost planes tangent to a set of three spheres.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We efficiently compute the distance to these planes by analytically solving the polynomial system: ax 1 +by 1 +cz 1 +d = r 1 , ax 2 +by 2 +cz 2 +d = r 2 , ax 3 + by 3 + cz 3 + d = r 3 , a 2 + b 2 + c 2 = 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">where r i and x i , y i , z i are the radius and x, y, z coordinates of particle i, respectively.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">a, b, c, d are the variables defining our plane with the signed distance function ax + by + cz + d = 0.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Intuitively, the first three equations ensure that the plane is the right distance away from each particle with the normal facing away from them, and the final equation ensures that the plane equation is normalized to a distance function.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">These four equations represent the intersection of three hyperplanes and a hypercylinder in 4D {a, b, c, d} space.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We solve this system analytically by first finding the line of common intersection of the first three equations, and then intersecting this line with the cylinder represented by the final equation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The system has two solutions, representing the top and bottom planes of our convex hull shape.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The above calculation describes how to find the planar regions of the convex hull of a set of three spheres.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">By computing the conic and spherical convex hull facets ( Figure 5 , bottom right) in a similar fashion, we can easily compute the signed distance between this convex hull and a point in space.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To evaluate our final level set value, we compute the minimum signed distance from a query point to all nearby convex hulls.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We evaluate the level set on each of the vertices of our adaptive BCC mesh, and we extract a triangle mesh using a marching tetrahedra algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We then perform a light mesh smoothing to increase the reliability of any curvature computations.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">The algorithm as described works perfectly for computing the level set outside of our particle surface, but it may lead to small gaps inside.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To avoid the creation of holes, we temporarily reassign each particle’s radius: r i temp = max(r i , −kφ i ) where φ i is the particle’s stored level set value from the previous time step, and k is a constant set to 0.75 in our simulations.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Using this temporary radius to compute the signed distance as described above will remove erroneous gaps inside the liquid.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We need to compute liquid surfaces both for final visualization as well as for several calculations during the progress of our simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For the final visualization, we compute an especially highresolution BCC mesh from all of our particles and proceed with the algorithm above.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The final surface creation is trivially parallelized, and takes around five minutes average per frame for all of our simulations.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We attempt to speed up the surface creation routine used for simulation computations by computing on the moderate-resolution BCC mesh used for simulation and ignoring ballistic particles (Section 3).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We compare our surface creation routine with a few existing methods in Figure 4 .</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Most previous algorithms perform poorly in this comparison because they were not designed for particles with varying radii.</Sentence>
        
          
          Figure 5: The 2D version of our surface creation algorithm takes a pair of particles (top left) and computes their convex hull (bottom left). In 3D, we convert three nearby particles (top right) into a convex hull (bottom right) consisting of spherical (orange), conic (dark blue), and planar (light blue) segments.
        
      
      
        <H1>6 Implementation</H1>
        <Sentence aspectClass="NONE" inAbstract="false">At this point we have described all of the components of our simulator.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The resulting algorithm can be seen in Algorithm 1.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the beginning of each step (line 2), we typically compute the level-set for the current particle configuration as described in Section 5.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We require the distance to the surface in several steps of our algorithm, so we store the level set values for each particle (line 3).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">When enough time has passed to trigger an update of the mesh, it becomes necessary to evaluate the sizing function.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">At this point, additional user-defined sizing functions could be computed as well.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Having the information from the sizing functions ready, we create a new BCC mesh and perform particle merging and splitting.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For mapping the particle velocities onto the grid (line 9) we use an SPH-like kernel function, which is weighted by the particle volume: max(v i (4r i 2 /d 2 − 1), 0), where v i is the particle volume and d is
        Algorithm 1: One step of our simulation algorithm.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">1 begin 2 Compute simulation surface S 3 Pre-compute φ for all particles 4 Correct particle positions x i 5 if Mesh update necessary then 6 Evaluate sizing function S(x) at x i 7 Build octree and BCC mesh 8 Merge and split particles 9 Compute mesh velocity u from particle velocities 10 Extrapolate u outside the liquid 11 Solve pressure p on the tetrahedral mesh, update u 12 Update particle velocities with gradient of p 13 Advect particles with u
        the distance to the particle center normalized with its radius.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The particle velocity update of line 12 uses barycentric interpolations as explained in Section 3.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Likewise, the grid-based velocity extrapolation of line 10 uses the nodal velocities of Section 3.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A time step is completed by performing the pressure projection and advecting the particles in the resulting divergence-free velocity field.</Sentence>
      
      
        <H1>7 Results and Discussion</H1>
        <Sentence aspectClass="NONE" inAbstract="false">To evaluate the performance and robustness of our method in comparison to previous work we have performed an extensive series of tests.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">A selection of these can be found in the accompanying comparison video.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">One comparison that is particularly interesting is the one comparing our method to an FVM based simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Using a graded BCC mesh leads to problems with the latter, as the position of the circumcenter lies exactly on a face for the graded tetrahedrons.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the graded region, this can result in two pressure samples from adjacent tetrahedra being placed at the exact same position.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To alleviate this problem, <CitSpan>[Batty et al. 2010]</CitSpan> propose to slightly offset the pressure samples from the faces.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">However, our implementation of their method exhibited slow convergence and the velocity artifacts despite this fix.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The influence of the different components of our sizing function on the evolution of a simulation is difficult to depict with static images, so we refer to the accompanying video for a comparison.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">To evaluate the basis of our adaptive model without any influence of the camera dependent sizing function, we have simulated the simple geometric configuration shown in Figure 3 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this setup, resolutions from 8 to 256 were used, resulting in 6 levels of adaptivity.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Timing information for the main steps of our algorithm over the course of this simulation can be found in Figure 8 and Figure 9 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For this simulation, the initial configuration consisted of 168, 161 particles, and momentarily peaked up to 1, 048, 776 during the maximal extent of the splash (settling down again to around 250 thousand in the end).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Note that a full sampling of the initial configuration with a regular grid would have required approximately 6 million particles.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our measurements show that the run-time of our method has a strong linear relationship to the number of particles, and thus the visual complexity of the simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The per-frame time is low at the beginning and end of the simulation, but strongly peaks during the complex splash in its middle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our visibility sizing function is highlighted by the setup shown in Figure 6 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Here the computational resources are focused on the visible region of a rotating camera, as the liquid splashes around a U-shaped corridor.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our solver efficiently resolves the complex motion near the camera, while effectively reducing the computational cost for parts that are not visible.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The simulation of Figure 7 shows</Sentence>
        
          
          Figure 6: Our visibility sizing function: as the liquid flows along the U-shaped corridor, the visible volume is simulated with a high resolution (surface shown in top row), while regions outside of the view frustrum are coarsened (particle view in bottom row).
        
        
          
             Setup Min. ∆x −1 Min. ∆x s −1 Max. ∆x −1 Duration frames
            
              
              
                
                   Figure 3
                   8
                   16
                   256
                   5h:09m
                   240
                
                
                   Figure 6
                   16
                   32
                   256
                   4h:26m
                   330
                
                
                   Figure 7
                   16
                   64
                   512
                   5h:55m
                   480
                
                
                   Figure 1
                   8
                   32
                   1024
                   12h:8m
                   160
                
              
            
          
          Setup Min. ∆x −1 Min. ∆x −1 s Max. ∆x −1 Duration frames Figure 3 8 16 256 5h:09m 240 Figure 6 16 32 256 4h:26m 330 Figure 7 16 64 512 5h:55m 480 Figure 1 8 32 1024 12h:8m 160
          Table 1: Resolutions and running times for our simulations (not including final surface creation). Here, ∆x −1 and ∆x −1 s denote the
        
        <Sentence aspectClass="NONE" inAbstract="false">number of BCC cells along one spatial axis for the simulation and for the surface generation, respectively.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The simulations were run on a workstation with an Intel Core i7-3960X CPU with 3.30GHz running under Linux.</Sentence>
        <Sentence aspectClass="NONE" inAbstract="false">a liquid interacting with a highly detailed obstacle.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The κ solid component of our sizing function ensures that geometrically complex regions near the obstacle are simulated with higher accuracy.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this way, we can resolve the detailed flow of liquid through the holes in the obstacle.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Figure 1 shows a situation that would be challenging to simulate with a regular solver.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Without adaptivity, the large open liquid surface with complex splashes in a localized region would require huge amounts of computational resources.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Our method can simulate this setup very efficiently, and in a fully coupled manner with an effective high resolution.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">The large open region is successfully coarsened by our sizing function, resulting in subtle wave motions around the splashes.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In this case, the whole simulation with 8 different octree levels and a maximum resolution of up to 1024 cells took on average only 4.6 minutes per frame to compute.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Just to illustrate the amount of detail in this setup – our adaptive version initially used 1.7 million particles, while a regular sampling at the finest resolution would have required roughly 400 million.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Further runtime and resolution details for our simulations can be found in Table 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Discussion We found our discretization (Section 3) beneficial in a number of ways.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We store the pressure variables on tetrahedral vertices, and there are far fewer vertices than tetrahedra in a given mesh.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Consequently, the pressure solve has fewer variables and is faster to solve.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">Also, by counting degrees of freedom and constraints, we can see that our discretization prevents the locking ar- tifacts which are common in other methods.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">However, the lower number of pressure constraints also implies that the highest frequencies of the velocity field may be unconstrained.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In our case a regularization via PIC interpolation acts to diminish any highfrequency artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our method uses a FLIP scheme instead of a purely Eulerian method.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We store all physical variables on the FLIP particles, so information is carried from one time step to the next in a Lagrangian manner.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">As a result, we are allowed to aggressively remesh the tetrahedral background grid without worrying about excessive damping or re-sampling artifacts.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">On the other hand, FLIP simulations have a well-known problem of creating noisy particle distributions, because there are typically several times more particles than velocity variables on the background grid.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">We utilize particle repositioning to improve the distribution quality, at the expense of slight inaccuracies due to displacing physical variables.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We noticed that our new surface creation routine is essential for maintaining detailed simulations in the presence of accurate freesurface boundary conditions.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">One major benefit of our method is that it can easily create perfectly flat surfaces from a mixture of differently-sized particles.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">These flat surfaces represent the equilibrium state of a fluid simulation, so our animations are able to smoothly settle down as time progresses.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Without a method for accurately reproducing flat surfaces, second-order boundary conditions will introduce additional forces in the locations of surface bumps, which artificially prevent a simulation from settling down.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">While we believe that our surface creation routine is indispensable, it is quite expensive to compute.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In the future we would like to optimize the surface computation.</Sentence> <Sentence aspectClass="ADVANTAGE_DISADVANTAGE" inAbstract="false">Our simulations perform quite well for large differences in resolutions, but we have only been able to push them to a certain point in our current implementation.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">We found that using too sharp of a grading in our sizing function can place coarse and fine simulation elements too close together and potentially result in artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">For example, when small particles land in very coarse cells after violent splashes, these particles can get stuck in mid air.</Sentence> <Sentence aspectClass="DISADVANTAGE" inAbstract="false">Occasionally, this can also lead to an overly strong weight for such particles during the velocity mapping, resulting in momentum artifacts.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Our adaptive numerical viscosity in Eq.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">
<CitSpan>(14)</CitSpan> can also exhibit dangerously small damping values for very fine resolutions, so we clamped the blending coefficient to a minimum value of 0.1 in Figure 1 .</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In Section 4 we introduced a novel collection of sizing functions for adaptively selecting details from a fluid simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">While we presented specific parameters for the sake of reproducibility, these values were not meticulously tuned and are certainly not optimal.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">The task of choosing an ideal sizing function is still an open problem that we are interested in pursuing in the future.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">In particular, we are interested in taking more temporal information into account.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This could lead to more gradual changes in resolution, at the expense of a slightly higher particle count.</Sentence>
        
          Figure 8: This graph shows durations for the different parts of our algorithm over the course of the simulation from Figure 3 . Note that we only include the computationally more expensive steps here, and not the re-meshing (which is done in intervals).
        
        
          Figure 9: The time required for our re-meshing and particle merging &amp; splitting computations over time for Figure 3 . Note that we perform them only every ten simulation steps.
        
        
          
          Figure 7: A simulation of detailed flow through a complex obstacle. The liquid correctly flows through the orifices at the center of the filigree.
        
      
      
        <H1>8 Conclusions and Outlook</H1>
        <Sentence aspectClass="NOVELTY" inAbstract="false">We have presented a novel framework for highly adaptive liquid simulation.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">In our method, a novel, robust discretization works together with accurate embedded boundary conditions and a flexible sizing function to allow for aggressive adaptivity and high computational performance.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">In this way, we can efficiently compute tough simulation setups, such as large surfaces with very localized details.</Sentence> <Sentence aspectClass="NOVELTY" inAbstract="false">We have additionally presented a novel surface creation method that yields smooth surfaces in the presence of strongly varying particle radii, which turned out to be an important building block for our framework.</Sentence> <Sentence aspectClass="ADVANTAGE" inAbstract="false">We chose a BCC mesh generation because it is, to the best of our knowledge, the fastest way to generate high-quality meshes.</Sentence> <Sentence aspectClass="LIMITATION" inAbstract="false">However, despite its efficiency, mesh generation is still a bottleneck for our simulation.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This is partly due to the fact that it is a mostly serial operation that is difficult to parallelize (most other steps of our algorithm parallelize easily).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">So, instead of computing the mesh from scratch each time, we are interested in exploring techniques for continuous re-meshing.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Also, our choice of piece-wise constant basis functions for velocity indicates that our discretization could lead to difficulties when it is used for diffusion or viscosity solves.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It will be interesting to see how these could be incorporated into our framework.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, we are highly interested in applying our method to other types of phenomena, such as smoke and fire simulations, or visco-elastic materials.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">It will be very interesting to leverage the benefits of our framework for extreme adaptivity in these situations.</Sentence>
      
      
        <H1>Acknowledgements</H1>
        <Sentence aspectClass="NONE" inAbstract="false">We would like to thank the anonymous reviewers for their helpful feedback.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">We also wish to thank Reiji Tsuruno for providing us with computational resources, and Pascal Clausen as well as Ramprasad Sampath for constructive discussions.</Sentence> <Sentence aspectClass="NONE" inAbstract="false">This work was supported by the Japan Society for the Promotion of Science (JSPS).</Sentence> <Sentence aspectClass="NONE" inAbstract="false">Finally, we would like to express our gratitude to the authors of the ANN library, which we use for kd-tree look-ups, and to the Mitsuba renderer, which we have used to render all images in this paper.</Sentence>
      
      
        <H1>References</H1>
        
          A DAMS , B., P AULY , M., K EISER , R., AND G UIBAS , L. J. 2007. Adaptively sampled particle fluids. In ACM SIGGRAPH 2007 papers, 48.
          A NDO , R., T HUEREY , N., AND T SURUNO , R. 2012. Preserving Fluid Sheets with Adaptively Sampled Anisotropic Particles. IEEE Transactions on Visualization and Computer Graphics 18 (8), 1202–1214.
          B ATTY , C., AND B RIDSON , R. 2008. Accurate viscous free surfaces for buckling, coiling, and rotating liquids. In Proceedings of the 2008 ACM/Eurographics Symposium on Computer Animation, 219–228.
          B ATTY , C., B ERTAILS , F., AND B RIDSON , R. 2007. A fast variational framework for accurate solid-fluid coupling. ACM Trans. Graph. 26, 3 (July).
          B ATTY , C., X ENOS , S., AND H OUSTON , B. 2010. Tetrahedral embedded boundary methods for accurate and flexible adaptive fluids. In Proceedings of Eurographics.
          B HATTACHARYA , H., G AO , Y., AND B ARGTEIL , A. W. 2011. A level-set method for skinning animated particle data. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          B OYD , L., AND B RIDSON , R. 2012. Multiflip for energetic twophase fluid simulation. ACM Trans. Graph. 31, 2, 16:1–16:12.
          B RIDSON , R. 2008. Fluid Simulation for Computer Graphics. AK Peters/CRC Press.
          B ROCHU , T., B ATTY , C., AND B RIDSON , R. 2010. Matching fluid simulation elements to surface geometry and topology. ACM Trans. Graph. 29, 4 (July), 47:1–47:9.
          C HENTANEZ , N., F ELDMAN , B. E., L ABELLE , F., O’B RIEN , J. F., AND S HEWCHUK , J. R. 2007. Liquid simulation on lattice-based tetrahedral meshes. In Proceedings of the 2007 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 219–228.
          C LAUSEN , P., W ICKE , M., S HEWCHUK , J., AND O’B RIEN , J. 2013. Simulating liquids and solid-liquid interactions with Lagrangian meshes. ACM Trans. Graph..
          E NRIGHT , D., N GUYEN , D., G IBOU , F., AND F EDKIW , R. 2003. Using the Particle Level Set Method and a Second Order Accurate Pressure Boundary Condition for Free-Surface Flows. Proc. of the 4th ASME-JSME Joint Fluids Engineering Conference.
          E NRIGHT , D., L OSASSO , F., AND F EDKIW , R. 2005. A fast and accurate semi-Lagrangian particle level set method. Comput. Struct. 83, 6-7, 479–490.
          H ARLOW , F., AND W ELCH , E. 1965. Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. Phys. Fluids 8 (12), 2182–2189.
          H ONG , W., H OUSE , D. H., AND K EYSER , J. 2009. An adaptive sampling approach to incompressible particle-based fluid. In TPCG, Eurographics Association, W. Tang and J. P. Collomosse, Eds., 69–76.
          I RVING , G., S CHROEDER , C., AND F EDKIW , R. 2007. Volume conserving finite element simulations of deformable models. ACM Trans. Graph. 26, 3 (July).
          K LINGNER , B. M., F ELDMAN , B. E., C HENTANEZ , N., AND O’B RIEN , J. F. 2006. Fluid animation with dynamic meshes. ACM Trans. Graph. 25, 3, 820–825.
          L ABELLE , F., AND S HEWCHUK , J. R. 2007. Isosurface stuffing: Fast tetrahedral meshes with good dihedral angles. ACM Trans. Graph. 26, 3 (July).
          L EW , A. J., AND B USCAGLIA , G. C. 2008. A discontinuousgalerkin-based immersed boundary method. International Journal for Numerical Methods in Engineering 76, 4, 427–454.
          L OSASSO , F., G IBOU , F., AND F EDKIW , R. 2004. Simulating water and smoke with an octree data structure. ACM Trans. Graph. 23, 3 (Aug.), 457–462.
          L OSASSO , F., F EDKIW , R., AND O SHER , S. 2005. Spatially adaptive techniques for level set methods and incompressible flow. Computers and Fluids 35, 2006.
          M ISZTAL , M. K., B RIDSON , R., E RLEBEN , K., B ÆRENTZEN , J. A., AND A NTON , F. 2010. Optimization-based fluid simulation on unstructured meshes. In VRIPHYS, Eurographics Association, 11–20.
          M ULLEN , P., C RANE , K., P AVLOV , D., T ONG , Y., AND D ES BRUN , M. 2009. Energy-preserving integrators for fluid animation. ACM Trans. Graph. 28 (July), 38:1–38:8.
          P FAFF , T., T HUEREY , N., C OHEN , J., T ARIQ , S., AND G ROSS , M. 2010. Scalable fluid simulation using anisotropic turbulence particles. In ACM Transactions on Graphics (TOG), vol. 29, ACM, 174.
          S IN , F., B ARGTEIL , A. W., AND H ODGINS , J. K. 2009. A pointbased method for animating incompressible flow. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          S OLENTHALER , B., AND G ROSS , M. 2011. Two-scale particle simulation. ACM Trans. Graph. 30, 4 (July), 81:1–81:8.
          S TAM , J. 1999. Stable fluids. In Proceedings of SIGGRAPH ’99, ACM, 121–128.
          W OJTAN , C., AND T URK , G. 2008. Fast viscoelastic behavior with thin features. ACM Trans. Graph. 27, 3, 1–8.
          Y U , J., AND T URK , G. 2010. Reconstructing surfaces of particlebased fluids using anisotropic kernels. In Proceedings of the 2010 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 217–225.
          Z HU , Y., AND B RIDSON , R. 2005. Animating sand as a fluid. ACM Trans. Graph. 24, 3 (July), 965–972.
        
      
      
        A Ghost Fluid Coefficients
        Here we describe how to compute the ghost fluid coefficients θ n given the 4 × 4 pressure matrix entries of a single tetrahedron. Reorganizing Eq. <CitSpan>(11)</CitSpan> gives:
        
          16
          λ 2 + αw 1 a + αw 2 b + αw 3 p 1 b 1 a + βw 1 λ 3 + βw 2 c + βw 3 p 2 = b 2 . b + γw 1 c + γw 2 λ 4 + γw 3 p 3 b 3
        
        Note that each of the θ n has two degree of freedom, and thus each w n also has two degrees of freedom. As we know that the resulting matrix needs to be symmetric, which gives us the following constraints: a + αw 2 = a + βw 1 , b + γw 1 = b + αw 3 , and c + βw 3 = c + γw 2 . As the w n linearly depend on θ n , that means: αθ 2 = βθ 1 , γθ 1 = αθ 3 , and βθ 3 = γθ 2 . When we re-write these constraints in matrix form, and include the barycentric coordinate constraint θ 1 + θ 2 + θ 3 = 1 we get the following linear system:
        
          17
           −β α 0   0  γ 0 −α θ 1 0   0 1 −γ 1 β 1   θ θ 3 2 =   1 0  
        
        As the rank of top three rows of the matrix is 2, we can drop one of them. Removing the first row from the system gives us the following full-rank, 3 × 3 matrix:
        
          18
          γ 0 −α θ 1 0 0 −γ β θ 2 = 0 1 1 1 θ 3 1
        
        The analytical solution of this system is:
        
          19
          θ 1 1 α θ 2 = β . θ 3 α + β + γ γ
        
        This means that for our discretization, the ghost pressure coefficients θ n are given by the tetrahedron’s matrix entries from Eq.10. More specifically, by those for the vertex that is located outside of the liquid, i.e., α, β and γ. Substituting this equation into Eq.9 and Eq.6 yields the final equation for the ghost pressure Eq. <CitSpan>(12)</CitSpan>.
      
    
  

</Document>
